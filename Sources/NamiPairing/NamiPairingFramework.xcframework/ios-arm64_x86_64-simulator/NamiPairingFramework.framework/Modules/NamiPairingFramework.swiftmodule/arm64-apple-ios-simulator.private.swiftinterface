// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target arm64-apple-ios16-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name NamiPairingFramework
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1.2
import AVFoundation
import ActivityKit
import Combine
import CommonCrypto
import CoreBluetooth
import CoreGraphics
import CryptoKit
import DeveloperToolsSupport
import Dispatch
import DivKitSVG
import Foundation
import Lottie
@_exported import NamiPairingFramework
import Network
import SafariServices
import Security
import Swift
import SwiftUI
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
extension NamiPairingFramework.NamiDeviceModel {
  public init(from model: any NamiPairingFramework.DeviceModelProtocol)
}
extension NamiPairingFramework.NamiDeviceModel : Swift.Codable, Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension NamiPairingFramework.InMemoryStorage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol {
  final public func updateDeviceState(uid: NamiPairingFramework.DeviceUniversalID, state: Foundation.Data, seqTime: Swift.UInt64) throws
  final public func placeIds() -> Combine.AnyPublisher<[NamiPairingFramework.PlaceID], Swift.Never>
  final public func deviceUids(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.DeviceUniversalID], Swift.Never>
  public typealias DeviceConnectionsManager_PlaceKey = NamiPairingFramework.NamiPlaceKey
}
extension Combine.Publisher {
  public func retry(_ retries: Swift.Int, if condition: @escaping (Self.Failure) -> Swift.Bool) -> Combine.Publishers.RetryIf<Self>
}
extension Combine.Publishers {
  public struct RetryIf<Upstream> : Combine.Publisher where Upstream : Combine.Publisher {
    public typealias Output = Upstream.Output
    public typealias Failure = Upstream.Failure
    public let publisher: Upstream
    public let retries: Swift.Int
    public let condition: (Upstream.Failure) -> Swift.Bool
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Upstream.Failure == S.Failure, Upstream.Output == S.Input
  }
}
public struct PlaceKey : Swift.Codable, Swift.Equatable, Swift.Identifiable, NamiPairingFramework.PlaceKeyProtocol {
  public init?(_ from: NamiPairingFramework.CloudPlaceKey)
  public init?(_ from: NamiPairingFramework.StorablePlaceKey)
  public let id: Swift.String
  public let placeId: NamiPairingFramework.PlaceID
  public let valid: Foundation.DateInterval
  public let key: Foundation.Data
  public static func decodeId(_ id: Swift.String) -> (placeId: NamiPairingFramework.PlaceID, valid: Foundation.DateInterval)?
  public static func == (a: NamiPairingFramework.PlaceKey, b: NamiPairingFramework.PlaceKey) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum AuthenticationError : Swift.Error {
  case loginRequired
  case tokenExpired
  case sessionCodeInvalid
  case unknown
  public static func == (a: NamiPairingFramework.AuthenticationError, b: NamiPairingFramework.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NamiPairingFramework.InMemoryStorage : @retroactive NamiPairingFramework.RemoteTemplateStateRepositoryProtocol {
  final public func place(id placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Place, Swift.Never>
  final public func zones(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Zone], Swift.Never>
  final public func rooms(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Room], Swift.Never>
  final public func rooms(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Room], Swift.Never>
  final public func device(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  final public func device(urn: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  final public func device(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  final public func devices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  final public func devices(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  final public func devices(roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  final public func devicesPerZone(in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZoneID : [NamiPairingFramework.RemoteTemplateUI_Device]], Swift.Never>
  final public func deviceState(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_DeviceState?, Swift.Never>
  final public func deleteRoom(_ roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Place, any Swift.Error>
}
public class Authenticator {
  public init(base: Foundation.URL, accessToken: NamiPairingFramework.AccessToken, refreshToken: Swift.String)
  public func validToken() -> Combine.AnyPublisher<NamiPairingFramework.AccessToken, any Swift.Error>
  public func requestWebToken() -> Combine.AnyPublisher<NamiPairingFramework.AccessToken, any Swift.Error>
  @objc deinit
}
public struct NamiPlace : Swift.Codable, Swift.Equatable, Swift.Identifiable {
  public init(id: NamiPairingFramework.PlaceID, urn: Swift.String, name: Swift.String, themeId: NamiPairingFramework.ThemeID, iconId: NamiPairingFramework.IconID, createdAt: Foundation.Date = Date(), updatedAt: Foundation.Date = Date(), alertMode: Swift.String)
  public init(_ place: NamiPairingFramework.Place)
  public var id: NamiPairingFramework.PlaceID
  public var urn: Swift.String
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var propertyTypeId: NamiPairingFramework.PropertyTypeID?
  public var propertyElevationId: NamiPairingFramework.PropertyElevationID?
  public var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID?
  public var petTypeId: NamiPairingFramework.PetTypeID?
  public var timeZone: Swift.String?
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var alertMode: Swift.String?
  public static func == (a: NamiPairingFramework.NamiPlace, b: NamiPairingFramework.NamiPlace) -> Swift.Bool
  public typealias ID = NamiPairingFramework.PlaceID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiPlaceUsageLimits : Swift.Codable, Swift.Equatable, Swift.Identifiable {
  public init(urn: Swift.String, limits: NamiPairingFramework.PlaceUsageLimits)
  public var urn: Swift.String
  public var membership: Swift.UInt
  public var id: NamiPairingFramework.URN {
    get
  }
  public static func == (a: NamiPairingFramework.NamiPlaceUsageLimits, b: NamiPairingFramework.NamiPlaceUsageLimits) -> Swift.Bool
  public typealias ID = NamiPairingFramework.URN
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiZone : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Hashable {
  public init(id: NamiPairingFramework.PlaceZoneID, externalId: Swift.String?, urn: Swift.String, name: Swift.String, placeId: NamiPairingFramework.PlaceID, alertMode: Swift.String, createdAt: Foundation.Date = Date(), updatedAt: Foundation.Date = Date())
  public init(_ zone: NamiPairingFramework.PlaceZone)
  public var id: NamiPairingFramework.PlaceZoneID
  public var externalId: Swift.String?
  public var urn: Swift.String
  public var name: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var namiAlertMode: NamiPairingFramework.NamiAlertMode
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var alertMode: Swift.String
  public static func == (a: NamiPairingFramework.NamiZone, b: NamiPairingFramework.NamiZone) -> Swift.Bool
  public typealias ID = NamiPairingFramework.PlaceZoneID
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiRoom : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Hashable {
  public init(id: NamiPairingFramework.RoomID, urn: Swift.String, name: Swift.String, placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID, iconId: NamiPairingFramework.IconID, createdAt: Foundation.Date = Date(), updatedAt: Foundation.Date = Date())
  public init(_ room: NamiPairingFramework.Room)
  public var id: NamiPairingFramework.RoomID
  public var urn: Swift.String
  public var name: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var iconId: NamiPairingFramework.IconID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.NamiRoom, b: NamiPairingFramework.NamiRoom) -> Swift.Bool
  public typealias ID = NamiPairingFramework.RoomID
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDevice : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Hashable {
  public init(id: NamiPairingFramework.DeviceID, uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, placeId: NamiPairingFramework.PlaceID, roomId: NamiPairingFramework.RoomID, bleDiscriminator: Swift.Int32?, name: Swift.String, codeName: Swift.String, productId: NamiPairingFramework.DeviceProductID, createdAt: Foundation.Date = Date(), updatedAt: Foundation.Date = Date())
  public init(_ device: NamiPairingFramework.Device, in placeId: NamiPairingFramework.PlaceID)
  public var id: NamiPairingFramework.DeviceID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var roomId: NamiPairingFramework.RoomID
  public var bleDiscriminator: Swift.Int32?
  public var name: Swift.String
  public var codeName: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var model: NamiPairingFramework.NamiDeviceModel
  public var isBorderRouter: Swift.Bool
  public static func == (a: NamiPairingFramework.NamiDevice, b: NamiPairingFramework.NamiDevice) -> Swift.Bool
  public typealias ID = NamiPairingFramework.DeviceID
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDeviceState : Swift.Codable, Swift.Equatable, Swift.Identifiable {
  public init?(_ device: NamiPairingFramework.Device)
  public init(from decoder: any Swift.Decoder) throws
  public init(id: NamiPairingFramework.DeviceID, uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, cloudAccessible: Swift.Bool?, lastCloudAccess: Foundation.Date?, seqTime: Swift.UInt64, state: Foundation.Data, stateUpdatedAt: Foundation.Date)
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id
    case uid
    case urn
    case cloudAccessible
    case lastCloudAccess
    case seqTime
    case state
    case stateUpdatedAt
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var id: NamiPairingFramework.DeviceID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var cloudAccessible: Swift.Bool?
  public var lastCloudAccess: Foundation.Date?
  public var seqTime: Swift.UInt64
  public var state: Foundation.Data
  public var stateUpdatedAt: Foundation.Date
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.NamiDeviceState, b: NamiPairingFramework.NamiDeviceState) -> Swift.Bool
  public typealias ID = NamiPairingFramework.DeviceID
}
public struct NamiAutomation : Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Identifiable {
  public init(_ placeId: NamiPairingFramework.PlaceID, _ automation: NamiPairingFramework.Automation)
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id
    case placeId
    case trigger
    case reactions
    case active
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var id: NamiPairingFramework.AutomationID
  public var placeId: NamiPairingFramework.PlaceID
  public var trigger: NamiPairingFramework.NamiAutomationTrigger
  public var reactions: [NamiPairingFramework.NamiAutomationReaction]
  public var active: Swift.Bool
  public static func == (a: NamiPairingFramework.NamiAutomation, b: NamiPairingFramework.NamiAutomation) -> Swift.Bool
  public typealias ID = NamiPairingFramework.AutomationID
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiAutomationTrigger : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public init(_ type: Swift.String, hour: Swift.Int, minute: Swift.Int, daysOfWeek: [Swift.String])
  public init(_ trigger: NamiPairingFramework.AutomationTrigger)
  public var type: Swift.String
  public var hour: Swift.Int
  public var minute: Swift.Int
  public var daysOfWeek: [Swift.String]
  public static func == (a: NamiPairingFramework.NamiAutomationTrigger, b: NamiPairingFramework.NamiAutomationTrigger) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiAutomationReaction : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public init(_ uuid: Swift.String, targetType: Swift.String, targetIds: [NamiPairingFramework.PlaceZoneID], action: NamiPairingFramework.NamiAutomationAction)
  public init(_ reaction: NamiPairingFramework.AutomationReaction)
  public var uuid: Swift.String
  public var targetType: Swift.String
  public var targetIds: [NamiPairingFramework.PlaceZoneID]
  public var action: NamiPairingFramework.NamiAutomationAction
  public static func == (a: NamiPairingFramework.NamiAutomationReaction, b: NamiPairingFramework.NamiAutomationReaction) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiAutomationAction : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public init(_ type: Swift.String, _ mode: NamiPairingFramework.AlertMode)
  public init(_ action: NamiPairingFramework.AutomationAction)
  public var type: Swift.String
  public var mode: NamiPairingFramework.NamiAlertMode
  public static func == (a: NamiPairingFramework.NamiAutomationAction, b: NamiPairingFramework.NamiAutomationAction) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiPlaceKey : Swift.Codable, Swift.Equatable, Swift.Identifiable, NamiPairingFramework.PlaceKeyProtocol {
  public init?(_ from: NamiPairingFramework.CloudPlaceKey)
  public let id: Swift.String
  public let placeId: NamiPairingFramework.PlaceID
  public let valid: Foundation.DateInterval
  public let key: Foundation.Data
  public static func decodeId(_ id: Swift.String) -> (placeId: NamiPairingFramework.PlaceID, valid: Foundation.DateInterval)?
  public static func == (a: NamiPairingFramework.NamiPlaceKey, b: NamiPairingFramework.NamiPlaceKey) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiPlaceUser : Swift.Codable, Swift.Equatable, Swift.Identifiable {
  public init(id: NamiPairingFramework.PlaceUserID, userId: NamiPairingFramework.UserID, urn: Swift.String, name: Swift.String, role: NamiPairingFramework.PlaceUserRole, placeId: NamiPairingFramework.PlaceID, iconId: NamiPairingFramework.UserIconID, themeId: NamiPairingFramework.IconID)
  public init(id: NamiPairingFramework.PlaceUserID, userId: NamiPairingFramework.UserID, urn: Swift.String, name: Swift.String, role: NamiPairingFramework.NamiPlaceUserRole, placeId: NamiPairingFramework.PlaceID, iconId: NamiPairingFramework.UserIconID, themeId: NamiPairingFramework.IconID)
  public init(_ user: NamiPairingFramework.PlaceUser)
  public init(from decoder: any Swift.Decoder) throws
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id
    case userId
    case name
    case urn
    case role
    case placeId
    case iconId
    case themeId
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var id: NamiPairingFramework.PlaceUserID
  public var userId: NamiPairingFramework.UserID
  public var name: Swift.String
  public var urn: Swift.String?
  public var role: NamiPairingFramework.NamiPlaceUserRole
  public var placeId: NamiPairingFramework.PlaceID
  public var iconId: NamiPairingFramework.UserIconID
  public var themeId: NamiPairingFramework.ThemeID
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.NamiPlaceUser, b: NamiPairingFramework.NamiPlaceUser) -> Swift.Bool
  public typealias ID = NamiPairingFramework.PlaceUserID
}
public struct NamiPlaceUserRole : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public init(id: Swift.String, name: Swift.String)
  public init(_ role: NamiPairingFramework.PlaceUserRole)
  public init(from decoder: any Swift.Decoder) throws
  public static var unknown: NamiPairingFramework.NamiPlaceUserRole
  public var id: Swift.String
  public var name: Swift.String
  public static func == (a: NamiPairingFramework.NamiPlaceUserRole, b: NamiPairingFramework.NamiPlaceUserRole) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NamiWiFiCredentialsUpdateStatus : Swift.String, Swift.Equatable, Swift.Codable {
  case inProgress
  case completed
  public init?(rawValue: Swift.String)
  public init(_ type: NamiPairingFramework.WiFiCredentialsUpdateStatus)
  public var status: NamiPairingFramework.WiFiCredentialsUpdateStatus {
    get
  }
  public static func == (lhs: NamiPairingFramework.NamiWiFiCredentialsUpdateStatus, rhs: NamiPairingFramework.NamiWiFiCredentialsUpdateStatus) -> Swift.Bool
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct NamiUpdatedDevice : Swift.Codable, Swift.Equatable, Swift.Identifiable {
  public init(_ updatedDevice: NamiPairingFramework.UpdatedDevice, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID)
  public init(from decoder: any Swift.Decoder) throws
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID
  public var id: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.NamiUpdatedDevice, b: NamiPairingFramework.NamiUpdatedDevice) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct NamiUpdatedDeviceUser : Swift.Codable, Swift.Equatable {
  public init(_ updatedDeviceUser: NamiPairingFramework.UpdatedDeviceUser, uid: NamiPairingFramework.DeviceUniversalID, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID)
  public init(from decoder: any Swift.Decoder) throws
  public var urn: Swift.String?
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID
  public static func == (a: NamiPairingFramework.NamiUpdatedDeviceUser, b: NamiPairingFramework.NamiUpdatedDeviceUser) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
extension NamiPairingFramework.NamiAlertMode {
  public init(_ mode: NamiPairingFramework.AlertMode)
  public var alertMode: NamiPairingFramework.AlertMode {
    get
  }
}
public struct NetworkError : Swift.Error {
  public init(statusCode: Swift.Int, body: Foundation.Data? = nil)
  public init(_ urlError: Foundation.URLError, body: Foundation.Data? = nil)
  public static var unknown: NamiPairingFramework.NetworkError
  public let code: NamiPairingFramework.NetworkErrorCode
  public var isRecoverable: Swift.Bool {
    get
  }
  public var customErrorDescription: Swift.String? {
    get
  }
  public func decodeBody<ErrorBody>(to type: ErrorBody.Type) -> ErrorBody? where ErrorBody : Swift.Decodable
}
public enum NetworkErrorCode : Swift.Equatable {
  case unknown(Swift.Int)
  case connectionError(Foundation.URLError)
  case invalidParameters
  case unauthorized
  case notFound
  case conflict
  case serverError
  case forbidden
  public init(statusCode: Swift.Int)
  public init(urlError: Foundation.URLError)
  public var code: Swift.Int {
    get
  }
  public static func == (lhs: NamiPairingFramework.NetworkErrorCode, rhs: NamiPairingFramework.NetworkErrorCode) -> Swift.Bool
}
public struct NamiDevicesQuery : NamiPairingFramework.DevicesQueryProtocol {
  public var placeIds: [NamiPairingFramework.PlaceID]
  public var zoneIds: [NamiPairingFramework.PlaceZoneID]
  public var roomIds: [NamiPairingFramework.RoomID]
  public var uids: [NamiPairingFramework.DeviceUniversalID]
  public var cursor: Swift.String?
  public init(anyDeviceQuery: any NamiPairingFramework.DevicesQueryProtocol)
  public init(placeIds: [NamiPairingFramework.PlaceID] = [], zoneIds: [NamiPairingFramework.PlaceZoneID] = [], roomIds: [NamiPairingFramework.RoomID] = [], uids: [NamiPairingFramework.DeviceUniversalID] = [], cursor: Swift.String? = nil)
  public static func parameters(placeIds: [NamiPairingFramework.PlaceID] = [], zoneIds: [NamiPairingFramework.PlaceZoneID] = [], roomIds: [NamiPairingFramework.RoomID] = [], uids: [NamiPairingFramework.DeviceUniversalID] = []) -> NamiPairingFramework.NamiDevicesQuery
  public static func cursor(_ cursor: Swift.String) -> NamiPairingFramework.NamiDevicesQuery
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDevicesResponse : NamiPairingFramework.DevicesResponseProtocol {
  public var devices: [NamiPairingFramework.Device]
  public var total: Swift.Int
  public var pageSize: Swift.Int
  public var cursor: Swift.String?
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias Device = NamiPairingFramework.Device
}
public struct Device : NamiPairingFramework.DeviceProtocol, Swift.Codable {
  public typealias State = NamiPairingFramework.DeviceCloudState
  public typealias CloudConnection = NamiPairingFramework.DeviceCloudConnectionStatus
  public var id: NamiPairingFramework.DeviceID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var roomId: NamiPairingFramework.RoomID
  public var bleDiscriminator: Swift.Int32?
  public var name: Swift.String
  public var codeName: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var model: any NamiPairingFramework.DeviceModelProtocol
  public var cloudConnection: NamiPairingFramework.Device.CloudConnection?
  public var deviceState: NamiPairingFramework.Device.State?
  public var isBorderRouter: Swift.Bool {
    get
  }
  public init(id: NamiPairingFramework.DeviceID, uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, roomId: NamiPairingFramework.RoomID, bleDiscriminator: Swift.Int32? = nil, name: Swift.String, codeName: Swift.String, productId: NamiPairingFramework.DeviceProductID, createdAt: Foundation.Date, updatedAt: Foundation.Date, model: any NamiPairingFramework.DeviceModelProtocol)
  public init(anyDevice: any NamiPairingFramework.DeviceProtocol)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct DeviceCloudConnectionStatus : Swift.Codable, Swift.Equatable, NamiPairingFramework.DeviceCloudConnectionStatusProtocol {
  public var isConnected: Swift.Bool
  public var updatedAt: Foundation.Date?
  public static func == (a: NamiPairingFramework.DeviceCloudConnectionStatus, b: NamiPairingFramework.DeviceCloudConnectionStatus) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DeviceCloudState : Swift.Codable, Swift.Equatable, NamiPairingFramework.DeviceStateProtocol {
  public init(payload: Foundation.Data, seqTime: Swift.UInt64, updatedAt: Foundation.Date)
  public init(from decoder: any Swift.Decoder) throws
  public var payload: Foundation.Data
  public var seqTime: Swift.UInt64
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.DeviceCloudState, b: NamiPairingFramework.DeviceCloudState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct DeviceModel : Swift.Codable, Swift.Equatable, NamiPairingFramework.DeviceModelProtocol {
  public var codeName: Swift.String
  public var productLabel: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public static func == (a: NamiPairingFramework.DeviceModel, b: NamiPairingFramework.DeviceModel) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlaceUsageLimits : Swift.Decodable, NamiPairingFramework.RemoteTemplateUI_PlaceUsageLimitsProtocol {
  public var urn: NamiPairingFramework.URN
  public var membership: Swift.UInt
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum AlertMode : Swift.String, Swift.Codable {
  case relaxed
  case aware
  case armed
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct Place : NamiPairingFramework.RemoteTemplateUI_PlaceProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public var id: NamiPairingFramework.PlaceID
  public var urn: Swift.String
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var propertyTypeId: NamiPairingFramework.PropertyTypeID?
  public var propertyElevationId: NamiPairingFramework.PropertyElevationID?
  public var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID?
  public var petTypeId: NamiPairingFramework.PetTypeID?
  public var timeZone: Swift.String?
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var alertMode: Swift.String?
  public var zones: [NamiPairingFramework.PlaceZone]
  public static func == (a: NamiPairingFramework.Place, b: NamiPairingFramework.Place) -> Swift.Bool
  public typealias ID = NamiPairingFramework.PlaceID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlaceZone : NamiPairingFramework.RemoteTemplateUI_ZoneProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public var id: NamiPairingFramework.PlaceZoneID
  public var urn: Swift.String
  public var name: Swift.String
  public var alertMode: Swift.String
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var externalId: Swift.String?
  public var placeId: NamiPairingFramework.PlaceID
  public var rooms: [NamiPairingFramework.Room]
  public init(id: NamiPairingFramework.PlaceZoneID, urn: Swift.String, name: Swift.String, alertMode: Swift.String, createdAt: Foundation.Date, updatedAt: Foundation.Date, externalId: Swift.String? = nil, placeId: NamiPairingFramework.PlaceID, rooms: [NamiPairingFramework.Room] = [])
  public static func == (a: NamiPairingFramework.PlaceZone, b: NamiPairingFramework.PlaceZone) -> Swift.Bool
  public typealias ID = NamiPairingFramework.PlaceZoneID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Room : NamiPairingFramework.RemoteTemplateUI_RoomProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public var id: NamiPairingFramework.RoomID
  public var urn: Swift.String
  public var name: Swift.String
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var iconId: NamiPairingFramework.IconID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var externalId: Swift.String?
  public var placeId: NamiPairingFramework.PlaceID
  public static func == (a: NamiPairingFramework.Room, b: NamiPairingFramework.Room) -> Swift.Bool
  public typealias ID = NamiPairingFramework.RoomID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlacesResponse : Swift.Decodable {
  public var places: [NamiPairingFramework.Place]
  public var permissions: [NamiPairingFramework.URN : NamiPairingFramework.UserPermissionsSet]
  public init(places: [NamiPairingFramework.Place], permissions: [NamiPairingFramework.URN : NamiPairingFramework.UserPermissionsSet])
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZoneRequest : Swift.Encodable {
  public init(name: Swift.String)
  public var name: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct RoomRequest : Swift.Encodable {
  public init(name: Swift.String, iconId: NamiPairingFramework.IconID)
  public var name: Swift.String
  public var iconId: NamiPairingFramework.IconID
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PlaceUserRole : Swift.Codable, Swift.Equatable, Swift.Hashable, NamiPairingFramework.RemoteTemplateUI_PlaceUserRoleProtocol {
  public init(id: Swift.String, name: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public static var unknown: NamiPairingFramework.PlaceUserRole
  public var id: Swift.String
  public var name: Swift.String
  public static func == (a: NamiPairingFramework.PlaceUserRole, b: NamiPairingFramework.PlaceUserRole) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NamiDevicesCommandResponse : NamiPairingFramework.DevicesCommandResponseProtocol, Swift.Encodable, Swift.Decodable {
  public typealias Result = NamiPairingFramework.NamiDeviceCommandResponseResult
  public var seqTime: Swift.UInt64
  public var results: [NamiPairingFramework.NamiDeviceCommandResponseResult]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDeviceCommandResponseResult : NamiPairingFramework.DevicesCommandResponseResultProtocol, Swift.Encodable, Swift.Decodable {
  public typealias DeviceConnections_DeviceCommandResponseContent = NamiPairingFramework.NamiDeviceCommandResponseContent
  public var devices: [NamiPairingFramework.DeviceUniversalID : NamiPairingFramework.NamiDeviceCommandResponseContent]
  public var isCloudResponse: Swift.Bool
  public init(anyResponseResult: any NamiPairingFramework.DevicesCommandResponseResultProtocol)
  public init(devices: [NamiPairingFramework.DeviceUniversalID : NamiPairingFramework.NamiDeviceCommandResponseContent], isCloudResponse: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDeviceCommandResponseContent : NamiPairingFramework.DeviceCommandResponseContentProtocol, Swift.Encodable, Swift.Decodable {
  public typealias DeviceConnections_DeviceCommandResponseError = NamiPairingFramework.NamiDeviceCommandResponseError
  public var error: NamiPairingFramework.NamiDeviceCommandResponseError?
  public var success: Swift.Bool
  public init(success: Swift.Bool, error: NamiPairingFramework.NamiDeviceCommandResponseError? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDeviceCommandResponseError : NamiPairingFramework.DeviceCommandResponseErrorProtocol, Swift.Encodable, Swift.Decodable {
  public var error: Swift.String
  public var errorCode: Swift.String
  public init(error: Swift.String, errorCode: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DevicesCommand : Swift.Encodable {
  public var devicesUids: [NamiPairingFramework.DeviceUniversalID]
  public var messages: [Foundation.Data]
  public init(devicesUids: [NamiPairingFramework.DeviceUniversalID], messages: [Foundation.Data])
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct DevicesCommandRequest : Swift.Encodable {
  public var seqTime: Swift.UInt64
  public var commands: [NamiPairingFramework.DevicesCommand]
  public init(seqTime: Swift.UInt64, commands: [NamiPairingFramework.DevicesCommand])
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PairDeviceResponse : Swift.Decodable, NamiPairingFramework.PairDeviceResponseProtocol {
  public var payload: NamiPairingFramework.WiredPlaceKeys
  public var device: NamiPairingFramework.Device
  public typealias Device = NamiPairingFramework.Device
  public typealias WiredPlaceKeys = NamiPairingFramework.WiredPlaceKeys
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingChallengeResponse : Swift.Decodable, NamiPairingFramework.PairingChallengeResponseProtocol {
  public var challenge: Swift.String
  public var model: NamiPairingFramework.DeviceModel
  public typealias DeviceModel = NamiPairingFramework.DeviceModel
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WiredPlaceKeys : Swift.Decodable, NamiPairingFramework.WiredPlaceKeysProtocol {
  public var ciphertext: Swift.String
  public var iv: Swift.String
  public var authTag: Swift.String
  public var serverKey: Swift.String
  public static func == (a: NamiPairingFramework.WiredPlaceKeys, b: NamiPairingFramework.WiredPlaceKeys) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CloudPlaceKey : Swift.Codable, Swift.Equatable, Swift.Identifiable {
  public init(id: Swift.String, key: Swift.String)
  public var id: Swift.String
  public var key: Swift.String
  public static func == (a: NamiPairingFramework.CloudPlaceKey, b: NamiPairingFramework.CloudPlaceKey) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DecodedPlaceKeys : Swift.Decodable {
  public init(keys: [NamiPairingFramework.CloudPlaceKey])
  public var keys: [NamiPairingFramework.CloudPlaceKey]
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlaceKeyRequest : Swift.Encodable {
  public var publicKey: Swift.String
  public init(publicKey: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct SessionCodeActivateResult : Swift.Decodable {
  public var sessionParameters: NamiPairingFramework.SessionParameters
  public var authentication: NamiPairingFramework.CompanionModeAuthentication
  public var place: NamiPairingFramework.Place
  public init(from decoder: any Swift.Decoder) throws
}
public struct SessionParameters : Swift.Codable, Swift.Equatable {
  public init(permissions: [Swift.String], mode: Swift.String, flatModeDefaults: [Swift.String : Swift.Int64], partnerName: Swift.String, partnerLogoUrl: Foundation.URL, redirectUri: Foundation.URL)
  public var permissions: [NamiPairingFramework.SessionPermission]
  public var mode: Swift.String
  public var flatModeDefaults: [Swift.String : Swift.Int64]
  public var partnerName: Swift.String
  public var partnerLogoUrl: Foundation.URL?
  public var redirectUri: Foundation.URL
  public static func == (a: NamiPairingFramework.SessionParameters, b: NamiPairingFramework.SessionParameters) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CompanionModeAuthentication : Swift.Decodable {
  public var accessToken: NamiPairingFramework.AccessToken
  public var refreshToken: NamiPairingFramework.TokenString
  public init(from decoder: any Swift.Decoder) throws
}
public struct AccessToken : Swift.Equatable, Swift.Codable {
  public var accessToken: NamiPairingFramework.TokenString
  public var expiresAt: Foundation.Date
  public init(accessToken: NamiPairingFramework.TokenString, expiresAt: Foundation.Date)
  public func isValid() -> Swift.Bool
  public static func == (a: NamiPairingFramework.AccessToken, b: NamiPairingFramework.AccessToken) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingChallengeRequest : Swift.Encodable {
  public var certificate: Swift.String
  public init(certificate: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PairDeviceRequest : Swift.Encodable {
  public var deviceName: Swift.String
  public var cloudChallenge: Swift.String
  public var deviceResponse: Swift.String
  public var deviceCertificate: Swift.String
  public var intent: Swift.String?
  public init(deviceName: Swift.String, cloudChallenge: Swift.String, deviceResponse: Swift.String, deviceCertificate: Swift.String, intent: Swift.String?)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct UpdatedDevice : Swift.Decodable, NamiPairingFramework.UpdatedDeviceProtocol {
  public var uid: NamiPairingFramework.DeviceUniversalID
  public static func == (a: NamiPairingFramework.UpdatedDevice, b: NamiPairingFramework.UpdatedDevice) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WiFiCredentialsUpdateSession : Swift.Decodable, NamiPairingFramework.WiFiCredentialsUpdateSessionProtocol {
  public var id: NamiPairingFramework.WiFiCredentialsUpdateSessionID
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var updatedDevices: [NamiPairingFramework.UpdatedDevice]?
  public static func == (lhs: NamiPairingFramework.WiFiCredentialsUpdateSession, rhs: NamiPairingFramework.WiFiCredentialsUpdateSession) -> Swift.Bool
  public typealias UpdatedDevice = NamiPairingFramework.UpdatedDevice
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum WiFiCredentialsUpdateStatus : Swift.String, Swift.Codable {
  case inProgress
  case completed
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct UpdatedDeviceUser : Swift.Decodable, Swift.Equatable {
  public init(urn: Swift.String?, name: Swift.String, themeId: NamiPairingFramework.ThemeID, iconId: NamiPairingFramework.IconID, id: NamiPairingFramework.UserID = 0, username: Swift.String = "")
  public var urn: Swift.String?
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var id: NamiPairingFramework.UserID
  public var username: Swift.String
  public static func == (a: NamiPairingFramework.UpdatedDeviceUser, b: NamiPairingFramework.UpdatedDeviceUser) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct MembershipResponse : NamiPairingFramework.RemoteTemplateUI_MemebershipResponseProtocol, Swift.Decodable {
  public typealias User = NamiPairingFramework.PlaceUser
  public typealias Invite = NamiPairingFramework.InviteLink
  public var users: [NamiPairingFramework.PlaceUser]
  public var invites: [NamiPairingFramework.InviteLink]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlaceUser : NamiPairingFramework.RemoteTemplateUI_PlaceUserProtocol, Swift.Decodable {
  public var userId: NamiPairingFramework.UserID
  public var urn: Swift.String
  public var iconId: NamiPairingFramework.UserIconID
  public var themeId: NamiPairingFramework.ThemeID
  public var placeId: NamiPairingFramework.PlaceID
  public var id: NamiPairingFramework.UserID
  public var name: Swift.String
  public var email: Swift.String
  public var role: NamiPairingFramework.PlaceUserRole
  public typealias PlaceUserRole = NamiPairingFramework.PlaceUserRole
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct InviteLink : NamiPairingFramework.RemoteTemplateUI_InviteLinkProtocol, Swift.Decodable {
  public var code: Swift.String
  public var name: Swift.String
  public var roleId: Swift.String
  public var roleName: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var placeName: Swift.String?
  public var state: Swift.String
  public var inviteUrl: Foundation.URL
  public var expiresAt: Foundation.Date
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct InvitePeek : NamiPairingFramework.RemoteTemplateUI_InvitePeekProtocol, Swift.Decodable {
  public var code: Swift.String
  public var name: Swift.String
  public var roleId: Swift.String
  public var roleName: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var placeName: Swift.String
  public var placeIconId: NamiPairingFramework.IconID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Automation : NamiPairingFramework.RemoteTemplateUI_NamiAutomationProtocol, Swift.Decodable {
  public typealias Trigger = NamiPairingFramework.AutomationTrigger
  public typealias Reaction = NamiPairingFramework.AutomationReaction
  public init(id: NamiPairingFramework.AutomationID, urn: Swift.String, trigger: NamiPairingFramework.AutomationTrigger, reactions: [NamiPairingFramework.AutomationReaction], active: Swift.Bool)
  public init(from decoder: any Swift.Decoder) throws
  public var id: NamiPairingFramework.AutomationID
  public var urn: Swift.String
  public var trigger: NamiPairingFramework.AutomationTrigger
  public var reactions: [NamiPairingFramework.AutomationReaction]
  public var active: Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct AutomationTrigger : Swift.Codable, NamiPairingFramework.RemoteTemplateUI_AutomationTriggerProtocol {
  public init(type: Swift.String, hour: Swift.Int, minute: Swift.Int, daysOfWeek: [Swift.String])
  public init(from decoder: any Swift.Decoder) throws
  public var type: Swift.String
  public var hour: Swift.Int
  public var minute: Swift.Int
  public var daysOfWeek: [Swift.String]
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct AutomationReaction : NamiPairingFramework.RemoteTemplateUI_AutomationReactionProtocol, Swift.Decodable {
  public typealias Action = NamiPairingFramework.AutomationAction
  public var action: NamiPairingFramework.AutomationAction
  public var uuid: Swift.String
  public var targetType: Swift.String
  public var targetIds: [NamiPairingFramework.PlaceZoneID]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AutomationAction : NamiPairingFramework.RemoteTemplateUI_AutomationActionProtocol, Swift.Codable {
  public var type: Swift.String
  public var mode: Swift.String
  public init(type: Swift.String, mode: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct CreateAutomationRequest : Swift.Encodable {
  public init(alertMode: Swift.String, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct UpdateAutomationRequest : Swift.Encodable {
  public init(alertMode: Swift.String, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ChangeAutomationActiveRequest : Swift.Encodable {
  public init(enable: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ZoneMotionEvent : NamiPairingFramework.RemoteTemplateUI_ZoneMotionEventProtocol, Swift.Decodable {
  public typealias Event = NamiPairingFramework.ActivityEvent
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var motionEvents: [NamiPairingFramework.ActivityEvent]
  public var occupancyEvents: [NamiPairingFramework.ActivityEvent]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ActivityEvent : NamiPairingFramework.RemoteTemplateUI_ActivityEventProtocol, Swift.Decodable {
  public var uuid: Foundation.UUID?
  public var startedAt: Foundation.Date
  public var endedAt: Foundation.Date?
  public var detection: Swift.Bool
  public var health: Swift.String
  public var timestamp: Foundation.Date
  public var eventType: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlaceMotionHistory : NamiPairingFramework.RemoteTemplateUI_PlaceMotionHistoryProtocol, Swift.Decodable {
  public typealias Event = NamiPairingFramework.ActivityEvent
  public var placeId: NamiPairingFramework.PlaceID
  public var motionEvents: [NamiPairingFramework.ActivityEvent]
  public var occupancyEvents: [NamiPairingFramework.ActivityEvent]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlaceMotionAggregates : Swift.Decodable, NamiPairingFramework.RemoteTemplateUI_PlaceMotionAggregatesProtocol {
  public typealias Aggregate = NamiPairingFramework.MotionAggregate
  public typealias Sparkline = NamiPairingFramework.ZoneSparkline
  public var placeId: NamiPairingFramework.PlaceID
  public var aggregates: [NamiPairingFramework.MotionAggregate]
  public var sparklines: [NamiPairingFramework.ZoneSparkline]?
  public init(placeId: NamiPairingFramework.PlaceID, aggregates: [NamiPairingFramework.MotionAggregate], sparklines: [NamiPairingFramework.ZoneSparkline]?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZoneMotionAggregates : NamiPairingFramework.RemoteTemplateUI_ZoneMotionAggregatesProtocol, NamiPairingFramework.RemoteTemplateUI_PlaceMotionAggregatesProtocol, Swift.Decodable {
  public var sparklines: [NamiPairingFramework.ZoneSparkline]?
  public typealias Aggregate = NamiPairingFramework.MotionAggregate
  public typealias Sparkline = NamiPairingFramework.ZoneSparkline
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var aggregates: [NamiPairingFramework.MotionAggregate]
  public var placeId: NamiPairingFramework.PlaceID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct MotionAggregate : NamiPairingFramework.RemoteTemplateUI_MotionAggregateProtocol, Swift.Decodable {
  public typealias Interval = NamiPairingFramework.MotionInterval
  public var intervals: [NamiPairingFramework.MotionInterval]
  public var metric: Swift.String
  public var resolution: Swift.String
  public var intervalLength: Foundation.TimeInterval
  public var value: Swift.Double
  public var period: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZoneSparkline : NamiPairingFramework.RemoteTemplateUI_ZoneSparklineProtocol, Swift.Decodable {
  public typealias Interval = NamiPairingFramework.MotionInterval
  public var intervals: [NamiPairingFramework.MotionInterval]
  public var zoneUrn: Swift.String
  public var metric: Swift.String
  public var resolution: Swift.String
  public var intervalLength: Foundation.TimeInterval
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var data: [Swift.Double]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct MotionInterval : NamiPairingFramework.RemoteTemplateUI_MotionIntervalProtocol, Swift.Codable {
  public var start: Foundation.Date
  public var value: Swift.UInt8
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RestEventsResponse : NamiPairingFramework.RemoteTemplateUI_RestEventsResponseProtocol, Swift.Decodable {
  public typealias RestEvent = NamiPairingFramework.NamiRestEvent
  public var restEvents: [NamiPairingFramework.NamiRestEvent]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiRestEvent : NamiPairingFramework.RemoteTemplateUI_RestEventProtocol, Swift.Decodable {
  public var deviceUid: NamiPairingFramework.DeviceUniversalID
  public var startedAt: Foundation.Date
  public var endedAt: Foundation.Date
  public var timestamp: Foundation.Date
  public var eventType: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiRestInsightsResponse : NamiPairingFramework.RemoteTemplateUI_RestInsightsResponseProtocol, Swift.Decodable {
  public typealias RestInsight = NamiPairingFramework.NamiRestInsight
  public var restInsights: [NamiPairingFramework.NamiRestInsight]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiRestInsight : NamiPairingFramework.RemoteTemplateUI_RestInsightProtocol, Swift.Decodable {
  public var deviceUid: NamiPairingFramework.DeviceUniversalID
  public var totalRestTime: Swift.Int
  public var numberOfInterruptions: Swift.Int
  public var timeToBed: Foundation.Date?
  public var outOfBedAt: Foundation.Date?
  public var value: Swift.Double
  public var type: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DeviceAttributeStateResponse : NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStateResponseProtocol, Swift.Decodable {
  public typealias DeviceAttributeState = NamiPairingFramework.NamiDeviceAttributeState
  public var deviceAttributeStates: [NamiPairingFramework.NamiDeviceAttributeState]
  public var total: Swift.Int
  public var pageSize: Swift.Int
  public var cursor: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDeviceAttributeState : NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStateProtocol, Swift.Codable {
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var path: Swift.String
  public var value: Swift.String?
  public var endpoint: Swift.Int
  public var isDeleted: Swift.Bool
  public var updatedAt: Foundation.Date
  public init(uid: NamiPairingFramework.DeviceUniversalID = DeviceUniversalID(0), path: Swift.String = "", value: Swift.String? = nil, endpoint: Swift.Int = 0, isDeleted: Swift.Bool = false, updatedAt: Foundation.Date = Date())
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct MoveDevicesRequest : Swift.Encodable {
  public init(devices: [NamiPairingFramework.DeviceUniversalID])
  public var devices: [NamiPairingFramework.DeviceUniversalID]
  public func encode(to encoder: any Swift.Encoder) throws
}
public typealias DeviceAttributeStatesQuery = NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStatesQuery
final public class WebAPI {
  public init(baseUrl: Foundation.URL, session: Foundation.URLSession = URLSession.shared, authentication: NamiPairingFramework.CompanionModeAuthentication)
  final public var errorPublisher: Combine.PassthroughSubject<any Swift.Error, Swift.Never>
  @objc deinit
}
extension NamiPairingFramework.WebAPI {
  final public func collectDevices(query: NamiPairingFramework.WebAPI.DevicesQuery) -> Combine.AnyPublisher<[NamiPairingFramework.Device], any Swift.Error>
}
extension NamiPairingFramework.WebAPI : NamiPairingFramework.RemoteTemplateUI_WebAPIProtocol, NamiPairingFramework.PairingWebAPIProtocol {
  public typealias RepresentablePlaceMotionAggregates = NamiPairingFramework.PlaceMotionAggregates
  public typealias RepresentableDevicesQuery = NamiPairingFramework.NamiDevicesQuery
  public typealias RepresentablePlace = NamiPairingFramework.Place
  public typealias RepresentableZone = NamiPairingFramework.PlaceZone
  public typealias RepresentableRoom = NamiPairingFramework.Room
  public typealias RepresentableMembershipResponse = NamiPairingFramework.MembershipResponse
  public typealias RepresentableInvitePeek = NamiPairingFramework.InvitePeek
  public typealias RepresentableDevice = NamiPairingFramework.Device
  public typealias RepresentableDevicesResponse = NamiPairingFramework.NamiDevicesResponse
  public typealias RepresentableDevicesCommandResponse = NamiPairingFramework.WebAPI.DevicesCommandResponse
  public typealias RepresentablePlaceAutomation = NamiPairingFramework.Automation
  public typealias RepresentableZoneMotionEvent = NamiPairingFramework.ZoneMotionEvent
  public typealias RepresentablePlaceMotionHistory = NamiPairingFramework.PlaceMotionHistory
  public typealias RepresentableZoneMotionAggregates = NamiPairingFramework.ZoneMotionAggregates
  public typealias RepresentableInviteLink = NamiPairingFramework.InviteLink
  public typealias RepresentableRestEventsResponse = NamiPairingFramework.RestEventsResponse
  public typealias RepresentableRestInsightsResponse = NamiPairingFramework.NamiRestInsightsResponse
  public typealias RepresentableDeviceAttributeStateResponse = NamiPairingFramework.DeviceAttributeStateResponse
  public typealias DevicesQuery = NamiPairingFramework.NamiDevicesQuery
  public typealias Pairing_DevicesQueryProtocol = NamiPairingFramework.WebAPI.DevicesQuery
  public typealias Pairing_DeviceResponse = NamiPairingFramework.Device
  public typealias Pairing_DevicesResponse = NamiPairingFramework.WebAPI.DevicesResponse
  public typealias Pairing_PairDeviceResponse = NamiPairingFramework.PairDeviceResponse
  public typealias Pairing_Place = NamiPairingFramework.Place
  public typealias Pairing_PlaceZone = NamiPairingFramework.PlaceZone
  public typealias Pairing_PairingChallengeResponse = NamiPairingFramework.PairingChallengeResponse
  public typealias Pairing_WiFiCredentialsUpdateSession = NamiPairingFramework.WiFiCredentialsUpdateSession
  final public func placeDetails(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  final public func listPlaceZones(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZone], any Swift.Error>
  final public func roomDetails(for roomId: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.Room, any Swift.Error>
  final public func deleteDevice(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func requestPairingChallenge(roomId: NamiPairingFramework.RoomID, deviceCertificate: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PairingChallengeResponse, any Swift.Error>
  final public func pairDevice(roomId: NamiPairingFramework.RoomID, deviceName: Swift.String, cloudChallenge: Swift.String, deviceResponse: Swift.String, deviceCertificate: Swift.String, intent: Swift.String?) -> Combine.AnyPublisher<NamiPairingFramework.PairDeviceResponse, any Swift.Error>
  final public func getWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  final public func deleteDeviceFromSession(uid: NamiPairingFramework.DeviceUniversalID, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  final public func leavePlace(id: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deletePlace(id: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deletePlaceZone(in placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  final public func deletePlaceRoom(in placeId: NamiPairingFramework.PlaceID, roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  final public func listPlaceMembers(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func deletePlaceUser(from placeId: NamiPairingFramework.PlaceID, user userId: NamiPairingFramework.UserID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func updatePlaceUser(for placeId: NamiPairingFramework.PlaceID, userId: NamiPairingFramework.UserID, roleId: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func revokeInvite(code: NamiPairingFramework.InviteCode, from placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func invitationDetails(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<NamiPairingFramework.InvitePeek, any Swift.Error>
  final public func acceptInvitation(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func declineInvitation(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func createZone(place: NamiPairingFramework.PlaceID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZone, any Swift.Error>
  final public func updateZone(id: NamiPairingFramework.PlaceZoneID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZone, any Swift.Error>
  final public func createRoom(zone: NamiPairingFramework.PlaceZoneID, name: Swift.String, icon: NamiPairingFramework.IconID) -> Combine.AnyPublisher<NamiPairingFramework.Room, any Swift.Error>
  final public func updateRoom(id: NamiPairingFramework.RoomID, name: Swift.String, icon: NamiPairingFramework.IconID) -> Combine.AnyPublisher<NamiPairingFramework.Room, any Swift.Error>
  final public func listDevices(query: any NamiPairingFramework.DevicesQueryProtocol) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevicesResponse, any Swift.Error>
  final public func moveDevices(deviceUIDs: [NamiPairingFramework.DeviceUniversalID], roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<[NamiPairingFramework.Device], any Swift.Error>
  final public func renameDevice(id: NamiPairingFramework.DeviceID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.Device, any Swift.Error>
  final public func sendDeviceCommandRequests(in placeId: NamiPairingFramework.PlaceID, uids: [NamiPairingFramework.DeviceUniversalID], messages: [Foundation.Data]) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevicesCommandResponse, any Swift.Error>
  final public func listAutomation(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.Automation], any Swift.Error>
  final public func createAutomation(placeId: NamiPairingFramework.PlaceID, alertMode: Swift.String, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.Automation, any Swift.Error>
  final public func updateAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, alertMode: Swift.String, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.Automation, any Swift.Error>
  final public func changeAutomationActive(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, active: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.Automation, any Swift.Error>
  final public func deleteAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<NamiPairingFramework.Automation, any Swift.Error>
  final public func getPlaceMotionHistory(for placeId: NamiPairingFramework.PlaceID, from: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.PlaceMotionHistory, any Swift.Error>
  final public func getZoneMotionHistory(for zoneIds: [NamiPairingFramework.PlaceZoneID], from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<[NamiPairingFramework.ZoneMotionEvent], any Swift.Error>
  final public func getPlaceMotionDataAggregates(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.PlaceMotionAggregates, any Swift.Error>
  final public func getZoneMotionDataAggregates(for zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.ZoneMotionAggregates, any Swift.Error>
  final public func generateInvite(to place: NamiPairingFramework.PlaceID, invitee name: Swift.String, roleId: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.InviteLink, any Swift.Error>
  final public func getRestHistory(roomId: NamiPairingFramework.RoomID, from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.RestEventsResponse, any Swift.Error>
  final public func getRestInsights(roomId: NamiPairingFramework.RoomID, day: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.NamiRestInsightsResponse, any Swift.Error>
  final public func getDeviceAttributeStatesHistory(query: NamiPairingFramework.DeviceAttributeStatesQuery) -> Combine.AnyPublisher<NamiPairingFramework.DeviceAttributeStateResponse, any Swift.Error>
  final public func getDeviceAttributeStatesRecent(query: NamiPairingFramework.DeviceAttributeStatesQuery) -> Combine.AnyPublisher<NamiPairingFramework.DeviceAttributeStateResponse, any Swift.Error>
}
extension NamiPairingFramework.WebAPI : NamiPairingFramework.DeviceConnectionsManagerWebAPIProtocol {
  public typealias DevicesCommandResponse = NamiPairingFramework.NamiDevicesCommandResponse
  final public func listDevices(query: NamiPairingFramework.NamiDevicesQuery) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevicesResponse, any Swift.Error>
  final public func listPlaceKeys() -> Combine.AnyPublisher<[NamiPairingFramework.CloudPlaceKey], any Swift.Error>
  public typealias CloudPlaceKey = NamiPairingFramework.CloudPlaceKey
  public typealias DevicesResponse = NamiPairingFramework.NamiDevicesResponse
}
final public class InMemoryStorage {
  @Combine.Published @_projectedValueProperty($placesStore) final public var placesStore: [NamiPairingFramework.NamiPlace] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $placesStore: Combine.Published<[NamiPairingFramework.NamiPlace]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($zonesStore) final public var zonesStore: [NamiPairingFramework.NamiZone] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $zonesStore: Combine.Published<[NamiPairingFramework.NamiZone]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($roomsStore) final public var roomsStore: [NamiPairingFramework.NamiRoom] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $roomsStore: Combine.Published<[NamiPairingFramework.NamiRoom]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($devicesStore) final public var devicesStore: [NamiPairingFramework.NamiDevice] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $devicesStore: Combine.Published<[NamiPairingFramework.NamiDevice]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($deviceStatesStore) final public var deviceStatesStore: [NamiPairingFramework.NamiDeviceState] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $deviceStatesStore: Combine.Published<[NamiPairingFramework.NamiDeviceState]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($automationsStore) final public var automationsStore: [NamiPairingFramework.NamiAutomation] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $automationsStore: Combine.Published<[NamiPairingFramework.NamiAutomation]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($deviceModelsStore) final public var deviceModelsStore: [NamiPairingFramework.NamiDeviceModel] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $deviceModelsStore: Combine.Published<[NamiPairingFramework.NamiDeviceModel]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($placeIntegrationsStore) final public var placeIntegrationsStore: [NamiPairingFramework.NamiPlaceIntegrations] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $placeIntegrationsStore: Combine.Published<[NamiPairingFramework.NamiPlaceIntegrations]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($placeUsageLimitsStore) final public var placeUsageLimitsStore: [NamiPairingFramework.NamiPlaceUsageLimits] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $placeUsageLimitsStore: Combine.Published<[NamiPairingFramework.NamiPlaceUsageLimits]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($placeUsersStore) final public var placeUsersStore: [NamiPairingFramework.NamiPlaceUser] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $placeUsersStore: Combine.Published<[NamiPairingFramework.NamiPlaceUser]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($updatedDevicesStore) final public var updatedDevicesStore: [NamiPairingFramework.NamiUpdatedDevice] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $updatedDevicesStore: Combine.Published<[NamiPairingFramework.NamiUpdatedDevice]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($deviceAttributeStatesStore) final public var deviceAttributeStatesStore: [NamiPairingFramework.NamiDeviceAttributeState] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $deviceAttributeStatesStore: Combine.Published<[NamiPairingFramework.NamiDeviceAttributeState]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($placeKeysStore) final public var placeKeysStore: [NamiPairingFramework.PlaceID : [NamiPairingFramework.StorablePlaceKey]] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $placeKeysStore: Combine.Published<[NamiPairingFramework.PlaceID : [NamiPairingFramework.StorablePlaceKey]]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  public init(api: NamiPairingFramework.WebAPI)
  public enum InMemoryError : Swift.Error {
    case missingData(description: Swift.String)
  }
  final public func place(id placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.NamiPlace, Swift.Never>
  final public func places() -> Combine.AnyPublisher<[NamiPairingFramework.NamiPlace], Swift.Never>
  final public func placesRemovedSinceLastUpdate() -> Combine.AnyPublisher<[NamiPairingFramework.NamiPlace], Swift.Never>
  final public func zones(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiZone], Swift.Never>
  final public func zonesWithDevices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiZone], Swift.Never>
  final public func rooms(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiRoom], Swift.Never>
  final public func rooms(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiRoom], Swift.Never>
  final public func device(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevice?, Swift.Never>
  final public func device(urn: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevice?, Swift.Never>
  final public func device(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevice?, Swift.Never>
  final public func devices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiDevice], Swift.Never>
  final public func devices(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiDevice], Swift.Never>
  final public func devices(roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiDevice], Swift.Never>
  final public func devicesPerZone(in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZoneID : [NamiPairingFramework.NamiDevice]], Swift.Never>
  final public func automations(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiAutomation], Swift.Never>
  final public func automation(id: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<NamiPairingFramework.NamiAutomation?, Swift.Never>
  final public func deviceModel(productId: NamiPairingFramework.DeviceProductID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDeviceModel, Swift.Never>
  final public func deviceModel(codeName: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.NamiDeviceModel, Swift.Never>
  final public func deviceModels(for deviceIds: [NamiPairingFramework.DeviceID]) -> Combine.AnyPublisher<[NamiPairingFramework.DeviceID : NamiPairingFramework.NamiDeviceModel], Swift.Never>
  final public func deviceState(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDeviceState?, Swift.Never>
  final public func deviceStates(for uids: [NamiPairingFramework.DeviceUniversalID]) -> Combine.AnyPublisher<[NamiPairingFramework.NamiDeviceState], Swift.Never>
  final public func deleteDeviceStates(devices: [NamiPairingFramework.NamiDevice]) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func usageLimits(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.NamiPlaceUsageLimits, Swift.Never>
  final public func placeKeys() -> Combine.AnyPublisher<[NamiPairingFramework.NamiPlaceKey], Swift.Never>
  final public func placeKeys(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiPlaceKey], Swift.Never>
  final public func allPlaceUsers() -> Combine.AnyPublisher<[NamiPairingFramework.NamiPlaceUser], Swift.Never>
  final public func placeIntegrations(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.NamiPlaceIntegrations, Swift.Never>
  @discardableResult
  final public func refreshPlaces() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  @discardableResult
  final public func refreshPlace(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  @discardableResult
  final public func refreshAllPlaceUsers() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshPlaceUsers(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshAllDevices() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshDevices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshDevices(ofType: NamiPairingFramework.NamiDeviceType) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshDevices(uids: [NamiPairingFramework.DeviceUniversalID]) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshPlaceKeys() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func createZone(placeId: NamiPairingFramework.PlaceID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZoneID, any Swift.Error>
  final public func createRoom(placeZoneId: NamiPairingFramework.PlaceZoneID, name: Swift.String, iconId: NamiPairingFramework.IconID) -> Combine.AnyPublisher<NamiPairingFramework.RoomID, any Swift.Error>
  final public func deleteAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func editZone(updated zone: NamiPairingFramework.NamiZone) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func editRoom(updated room: NamiPairingFramework.NamiRoom) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deletePlace(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func createOrUpdateDeviceState(uid: NamiPairingFramework.DeviceUniversalID, state: Foundation.Data, seqTime: Swift.UInt64)
  final public func updatePlace(_ place: NamiPairingFramework.Place)
  final public func updateRoom(_ room: NamiPairingFramework.Room)
  final public func updateZone(_ zone: NamiPairingFramework.PlaceZone)
  final public func deleteDevice(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deleteDeviceSkippingAPICall(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deleteZone(_ zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deleteRoom(_ roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.NamiPlace, any Swift.Error>
  final public func deletePlaceUser(_ userId: NamiPairingFramework.UserID, placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func deviceAttributeStates(for deviceUIDs: [NamiPairingFramework.DeviceUniversalID]) -> Combine.AnyPublisher<[NamiPairingFramework.NamiDeviceAttributeState], Swift.Never>
  final public func clearAll()
  @objc deinit
}
public enum SDKError : Swift.Error, Foundation.LocalizedError {
  case sessionActivateNoData
  case sessionActivateMalformedResponse(Foundation.Data)
  case roomUuidNotInTopology
  case incorrectDeviceUID
  case authenticationError(NamiPairingFramework.AuthenticationError)
  case storageError(NamiPairingFramework.StorageError)
  case incorrectTemplatesBaseUrl
  public var errorDescription: Swift.String? {
    get
  }
}
public struct NamiPlaceIntegrations : Swift.Equatable {
  public init(placeId: NamiPairingFramework.PlaceID)
  public let placeId: NamiPairingFramework.PlaceID
  public let availableIntegrations: [NamiPairingFramework.IntegrationState]
  public static func == (a: NamiPairingFramework.NamiPlaceIntegrations, b: NamiPairingFramework.NamiPlaceIntegrations) -> Swift.Bool
}
public struct IntegrationState : Swift.Equatable, Swift.Hashable {
  public var id: Swift.Int64
  public var urn: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var integrationId: Swift.Int64
  public var isEnabled: Swift.Bool
  public var provider: NamiPairingFramework.IntegrationProvider? {
    get
  }
  public static func == (a: NamiPairingFramework.IntegrationState, b: NamiPairingFramework.IntegrationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct IntegrationProvider : Swift.Equatable, Swift.Hashable {
  public var id: Swift.Int64
  public var urn: Swift.String
  public var icon: Foundation.URL
  public var badge: Foundation.URL?
  public var name: Swift.String
  public var description: Swift.String?
  public var howToEnable: Swift.String?
  public static func == (a: NamiPairingFramework.IntegrationProvider, b: NamiPairingFramework.IntegrationProvider) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URLRequest {
  public init(method: Swift.String = "GET", base: Foundation.URL, path: Swift.String, query: [Swift.String : Swift.String], headers: [Swift.String : Swift.String] = [:], body: Foundation.Data? = nil)
  public init(method: Swift.String = "GET", base: Foundation.URL, path: Swift.String, query: [Foundation.URLQueryItem] = [], headers: [Swift.String : Swift.String] = [:], body: Foundation.Data? = nil)
}
@_hasMissingDesignatedInitializers final public class InMemoryThreadDatasetStorage : NamiPairingFramework.ThreadSecureStorageProtocol {
  public static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  public static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, NamiPairingFramework.InMemoryThreadDatasetStorage.Thread_SecureStorageError>
  public static func delete(at key: Swift.String, server: Swift.String)
  public typealias Thread_SecureStorageError = NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError
  public enum StorageError : Swift.Error {
    case cantRetrieve
    public static func == (a: NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError, b: NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
public struct PublicWiFiNetwork : Swift.Equatable {
  public var ssid: Swift.String
  public var rssi: Swift.Int32
  public var open: Swift.Bool
  public var bssid: Foundation.Data
  public init()
  public static func == (a: NamiPairingFramework.PublicWiFiNetwork, b: NamiPairingFramework.PublicWiFiNetwork) -> Swift.Bool
}
public struct PublicPairingAdvertisement : Swift.Equatable {
  public var version: Swift.Int32
  public var productID: Swift.Int32
  public var discriminator: Swift.Int32
  public init()
  public static func == (a: NamiPairingFramework.PublicPairingAdvertisement, b: NamiPairingFramework.PublicPairingAdvertisement) -> Swift.Bool
}
public struct ThreadScanResult : Swift.Equatable {
  public var panID: Swift.UInt32
  public var extendedPanID: Swift.UInt64
  public var networkName: Swift.String
  public var channel: Swift.UInt32
  public var version: Swift.UInt32
  public var extendedAddress: Swift.UInt64
  public var rssi: Swift.Int32
  public var lqi: Swift.UInt32
  public init()
  public static func == (a: NamiPairingFramework.ThreadScanResult, b: NamiPairingFramework.ThreadScanResult) -> Swift.Bool
}
public struct PublicPairingError : Swift.Equatable {
  public enum ErrorType : Swift.Equatable {
    public typealias RawValue = Swift.Int
    case unknownError
    case secureSessionError
    case cloudChallengeError
    case wifiScanError
    case wifiJoinError
    case wifiJoinPasswordError
    case wifiJoinIpError
    case threadScanError
    case threadJoinError
    case UNRECOGNIZED(Swift.Int)
    public init()
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
    public static func == (a: NamiPairingFramework.PublicPairingError.ErrorType, b: NamiPairingFramework.PublicPairingError.ErrorType) -> Swift.Bool
  }
  public var error: NamiPairingFramework.PublicPairingError.ErrorType
  public static func == (a: NamiPairingFramework.PublicPairingError, b: NamiPairingFramework.PublicPairingError) -> Swift.Bool
}
public enum RemoteTemplateEntrypoint : Swift.String, NamiPairingFramework.RemoteTemplateEntrypointProtocol {
  case setupKitGuide
  case setupDeviceGuide
  case settings
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension NamiPairingFramework.ThreadOperationalDatasetProvider : NamiPairingFramework.PairingThreadOperationalDatasetProviderProtocol {
  public typealias Pairing_NamiThreadOperationalDataset = NamiPairingFramework.NamiThreadOperationalDataset
}
extension NamiPairingFramework.NamiThreadOperationalDataset : NamiPairingFramework.PairingNamiThreadOperationalDatasetProtocol {
}
public struct PairingHelper {
}
public struct DeveloperParameters {
  public let accessToken: NamiPairingFramework.AccessToken?
  public init(accessToken: NamiPairingFramework.AccessToken? = nil)
}
public struct NamiSdkConfig : NamiPairingFramework.RemoteTemplateUIConfigProtocol {
  public init(baseURL: Foundation.URL, countryCode: Swift.String, measurementSystem: NamiPairingFramework.NamiMeasurementSystem, clientId: Swift.String, language: Swift.String, appearance: NamiPairingFramework.NamiAppearance)
  public var baseURL: Foundation.URL
  public var countryCode: Swift.String
  public var measurementSystem: NamiPairingFramework.NamiMeasurementSystem
  public var clientId: Swift.String
  public var language: Swift.String
  public var appearance: NamiPairingFramework.NamiAppearance
  public var topologyRoomsSupported: Swift.Bool
}
public class NamiPairing<Container> where Container : NamiPairingFramework.PairingStepsContainer {
  public typealias PairingParameters = NamiPairingFramework.Tomonari<Container>.PairingParameters
  public var api: NamiPairingFramework.WebAPI
  public var wifiStorage: any NamiPairingFramework.PairingWiFiStorageProtocol
  public var threadDatasetProvider: any NamiPairingFramework.PairingThreadOperationalDatasetProviderProtocol
  public var devicePairingState: Combine.PassthroughSubject<NamiPairingFramework.Tomonari<Container>.DevicePairingState, any Swift.Error> {
    get
  }
  public var setupGuideState: Combine.PassthroughSubject<NamiPairingFramework.SetupGuideEvent, any Swift.Error>
  public var placeId: NamiPairingFramework.PlaceID {
    get
  }
  public init<WiFiStorage, SecureStorage>(sessionCode: Swift.String, wifiStorage: WiFiStorage = InMemoryWiFiStorage(), threadDatasetStore: SecureStorage.Type = InMemoryThreadDatasetStorage.self, developerParameters: NamiPairingFramework.DeveloperParameters = DeveloperParameters()) throws where WiFiStorage : NamiPairingFramework.PairingWiFiStorageProtocol, SecureStorage : NamiPairingFramework.ThreadSecureStorageProtocol
  public func startPairing(roomId: Swift.String, deviceType: NamiPairingFramework.NamiDeviceType = .unknown, pairingSteps: Container, pairingParameters: NamiPairingFramework.NamiPairing<Container>.PairingParameters = .none) throws -> some SwiftUICore.View
  
  public func startPositioning(deviceName: Swift.String, deviceUid: Swift.String, pairingSteps: Container, onPositioningEnded: @escaping (NamiPairingFramework.PositioningResult) -> Swift.Void) throws -> some SwiftUICore.View
  
  @_Concurrency.MainActor public func presentEntryPoint(entrypoint: NamiPairingFramework.RemoteTemplateEntrypoint, config: NamiPairingFramework.NamiSdkConfig, pairingSteps: Container) -> some SwiftUICore.View
  
  @objc deinit
}
extension NamiPairingFramework.RemoteTemplateUI_Zone {
  public init(zone: NamiPairingFramework.NamiZone, rooms: [NamiPairingFramework.NamiRoom], devices: [NamiPairingFramework.NamiDevice], devicesState: [NamiPairingFramework.NamiDeviceState])
}
extension NamiPairingFramework.RemoteTemplateUI_Room {
  public init(room: NamiPairingFramework.NamiRoom, devices: [NamiPairingFramework.NamiDevice], devicesState: [NamiPairingFramework.NamiDeviceState])
}
extension NamiPairingFramework.RemoteTemplateUI_DeviceState {
  public init(deviceState: NamiPairingFramework.NamiDeviceState)
}
extension NamiPairingFramework.RemoteTemplateUI_Device {
  public init(device: NamiPairingFramework.NamiDevice, deviceState: NamiPairingFramework.NamiDeviceState?)
}
public enum NamiPermission : Swift.String, Swift.CaseIterable, Swift.Codable {
  case pairDevice
  case view
  case update
  case destroy
  case destroyDependants
  case controlAlerting
  case linkClients
  case createSessionCodes
  case communicateWithDevices
  case updateMembership
  case updateWiFiCredential
  public init?(rawValue: Swift.String)
  public typealias AllCases = [NamiPairingFramework.NamiPermission]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [NamiPairingFramework.NamiPermission] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension Swift.Array where Element == Swift.String {
  public var knownPermissions: [NamiPairingFramework.NamiPermission] {
    get
  }
}
public typealias NamiPermissionsSet = [NamiPairingFramework.NamiPermission]
final public class InMemoryWiFiStorage : NamiPairingFramework.PairingWiFiStorageProtocol {
  public init()
  final public func save(password: Swift.String?, for networkSSID: Swift.String)
  final public func password(for networkSSID: Swift.String) -> Swift.String?
  final public func removeAll()
  @objc deinit
}
public enum StorageError : Swift.Error {
  case wifiCredentialsStorage
  case threadDatasetStorage
  case deviceConnectionsStorage
  public var localizedDescription: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.StorageError, b: NamiPairingFramework.StorageError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NamiDeviceCapability : Swift.Equatable {
  case deviceInformation
  case diagnostics
  case relay
  case sentinelAlarm
  case devkitLed
  case devkitAlarm
  case widar
  case doorSensorOpenClosed
  case doorSensorTempered
  case powerSupply
  case warning
  public var endpoint: NamiPairingFramework.NamiDeviceEndpoint {
    get
  }
  public static var `default`: [NamiPairingFramework.NamiDeviceCapability]
  public static var plug: [NamiPairingFramework.NamiDeviceCapability]
  public static var devkit: [NamiPairingFramework.NamiDeviceCapability]
  public static var pod: [NamiPairingFramework.NamiDeviceCapability]
  public static var alarmPod: [NamiPairingFramework.NamiDeviceCapability]
  public static var contactSensor: [NamiPairingFramework.NamiDeviceCapability]
  public static var motionSensor: [NamiPairingFramework.NamiDeviceCapability]
  public static var keypad: [NamiPairingFramework.NamiDeviceCapability]
  public static var widarSensor: [NamiPairingFramework.NamiDeviceCapability]
  public static func == (a: NamiPairingFramework.NamiDeviceCapability, b: NamiPairingFramework.NamiDeviceCapability) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NamiDeviceEndpoint : Swift.Equatable {
  public enum EndpointType : Swift.Equatable {
    public enum ReadableCluster {
      case stateOnOff
      case stateColorControl
      case stateLevelControlForLighting
      case stateDeviceInfo
      case stateWarning
      case stateWifiInfo
      case stateThreadNetworkInfo
      case stateWiDar
      case stateSensingConfig
      case stateDoorSensorOpenClosed
      case stateDoorSensorTempered
      case statePowerSupplyInfo
      public static func == (a: NamiPairingFramework.NamiDeviceEndpoint.EndpointType.ReadableCluster, b: NamiPairingFramework.NamiDeviceEndpoint.EndpointType.ReadableCluster) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum WritableCluster {
      case changeOnOff
      case changeColorControl
      case changeLevelControlForLighting
      case changeWiDar
      case changeWarning
      public static func == (a: NamiPairingFramework.NamiDeviceEndpoint.EndpointType.WritableCluster, b: NamiPairingFramework.NamiDeviceEndpoint.EndpointType.WritableCluster) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static func == (a: NamiPairingFramework.NamiDeviceEndpoint.EndpointType, b: NamiPairingFramework.NamiDeviceEndpoint.EndpointType) -> Swift.Bool
  }
  public var endpoint: Swift.Int32
  public var readable: [NamiPairingFramework.NamiDeviceEndpoint.EndpointType.ReadableCluster]
  public var writable: [NamiPairingFramework.NamiDeviceEndpoint.EndpointType.WritableCluster]
  public static func == (a: NamiPairingFramework.NamiDeviceEndpoint, b: NamiPairingFramework.NamiDeviceEndpoint) -> Swift.Bool
}
public enum MeasurementSystem {
  case metric
  case uk
  case us
  public static func == (a: NamiPairingFramework.MeasurementSystem, b: NamiPairingFramework.MeasurementSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SwiftUICore.EnvironmentValues {
  public var measurementSystem: NamiPairingFramework.MeasurementSystem {
    get
  }
}
extension Foundation.Locale {
  public var systemOfMeasurements: Swift.String? {
    get
  }
  public static let metricMeasurementSystem: Swift.String
  public static let usMeasurementSystem: Swift.String
  public static let ukMeasurementSystem: Swift.String
}
public enum NamiAlertReason : Swift.String, Swift.Comparable, Swift.Codable {
  case motion
  case device
  public static func < (lhs: NamiPairingFramework.NamiAlertReason, rhs: NamiPairingFramework.NamiAlertReason) -> Swift.Bool
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum NamiMeasurementSystem : Swift.String, Swift.CaseIterable, Swift.Identifiable {
  case metric
  case imperial
  public var id: NamiPairingFramework.NamiMeasurementSystem {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [NamiPairingFramework.NamiMeasurementSystem]
  public typealias ID = NamiPairingFramework.NamiMeasurementSystem
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [NamiPairingFramework.NamiMeasurementSystem] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum KitCategory : Swift.String, Swift.CaseIterable {
  case bss
  case hms
  public var name: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [NamiPairingFramework.KitCategory]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [NamiPairingFramework.KitCategory] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct KitPairedDeviceInfo : Swift.Codable {
  public var deviceName: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public var deviceUrn: Swift.String
  public var roomName: Swift.String
  public init(from decoder: any Swift.Decoder) throws
  public init(deviceName: Swift.String, productId: NamiPairingFramework.DeviceProductID, deviceUrn: Swift.String, roomName: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct CodeLinkingInfo : Swift.Decodable, Swift.Equatable {
  public init(code: NamiPairingFramework.SignInCode, requestedAt: Foundation.Date, expiresAt: Foundation.Date, ip: Swift.String? = nil, browser: Swift.String? = nil, os: Swift.String? = nil, city: Swift.String? = nil, country: Swift.String? = nil)
  public init(from decoder: any Swift.Decoder) throws
  public var code: NamiPairingFramework.SignInCode
  public var requestedAt: Foundation.Date
  public var expiresAt: Foundation.Date
  public var ip: Swift.String?
  public var browser: Swift.String?
  public var os: Swift.String?
  public var city: Swift.String?
  public var country: Swift.String?
  public static func == (a: NamiPairingFramework.CodeLinkingInfo, b: NamiPairingFramework.CodeLinkingInfo) -> Swift.Bool
}
extension NamiPairingFramework.NamiDeviceModel {
  public static let preset: [NamiPairingFramework.NamiDeviceModel]
}
public enum NamiDeviceConnectivity {
  case hasWiFi
  case hasThread
  public static func == (a: NamiPairingFramework.NamiDeviceConnectivity, b: NamiPairingFramework.NamiDeviceConnectivity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.CharacterSet {
  public static var hexDigits: Foundation.CharacterSet
}
extension Swift.String {
  public func replacingCharacters(from characterSet: Foundation.CharacterSet, with replacement: Swift.String) -> Swift.String
  public var trimmingWhitespaces: Swift.String {
    get
  }
}
public enum TimeZoneLoadingError : Swift.Error {
  case fileNotFound
  case decodingError
  case noTimezonesAvailable
  public static func == (a: NamiPairingFramework.TimeZoneLoadingError, b: NamiPairingFramework.TimeZoneLoadingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TimeZoneLoader {
  public static let shared: NamiPairingFramework.TimeZoneLoader
  public func findTimeZone(byId id: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.NamiTimeZone?, Swift.Never>
  public func getTimezones() -> Combine.AnyPublisher<[NamiPairingFramework.NamiTimeZone], NamiPairingFramework.TimeZoneLoadingError>
  @objc deinit
}
public struct TimeZoneLocation : Swift.Decodable, Swift.Hashable {
  public init(from decoder: any Swift.Decoder) throws
  public init?(code: Swift.String?)
  public let countryCode: Swift.String
  public let countryName: Swift.String?
  public static func == (a: NamiPairingFramework.TimeZoneLocation, b: NamiPairingFramework.TimeZoneLocation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NamiTimeZone : Swift.Decodable, Swift.Hashable {
  public init(from decoder: any Swift.Decoder) throws
  public init(id: Swift.String, city: Swift.String, location: NamiPairingFramework.TimeZoneLocation?, continent: Swift.String?, gmtOffset: Swift.String, aliases: [Swift.String])
  public let id: Swift.String
  public let city: Swift.String
  public let location: NamiPairingFramework.TimeZoneLocation?
  public let continent: Swift.String?
  public let gmtOffset: Swift.String
  public let aliases: [Swift.String]
  public var timeZone: Foundation.TimeZone {
    get
  }
  public static func == (lhs: NamiPairingFramework.NamiTimeZone, rhs: NamiPairingFramework.NamiTimeZone) -> Swift.Bool
  public func displayName() -> Swift.String
  public func displayNameWithGMT() -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias TokenString = Swift.String
public typealias UserID = Swift.Int64
public typealias UserIconID = Swift.Int64
public typealias URN = Swift.String
public typealias PlaceID = Swift.Int64
public typealias UserPermissionsSet = [Swift.String]
public typealias PlaceZoneID = Swift.Int64
public typealias ThemeID = Swift.Int64
public typealias IconID = Swift.Int64
public typealias PlaceUserID = Swift.Int64
public typealias RoomID = Swift.Int64
public typealias DeviceProductID = Swift.Int64
public typealias DeviceID = Swift.Int64
public typealias NamiAlertID = Swift.Int64
public typealias EventID = Swift.Int64
public typealias InviteCode = Swift.String
public typealias SessionCode = Swift.String
public typealias SignInCode = Swift.String
public typealias SessionPermission = Swift.String
public typealias WiFiCredentialsUpdateSessionID = Swift.Int64
public typealias PropertyTypeID = Swift.Int64
public typealias PropertyElevationID = Swift.Int64
public typealias PropertyAvgFloorAreaID = Swift.Int64
public typealias AutomationID = Swift.Int64
public typealias PetTypeID = Swift.Int64
public struct DeviceUniversalID : Swift.Equatable, Swift.Decodable, Swift.Hashable {
  public init?(_ string: Swift.String)
  public init(_ number: Swift.UInt64)
  public init(from decoder: any Swift.Decoder) throws
  public var macFormatted: Swift.String {
    get
  }
  public var uInt64Formatted: Swift.UInt64 {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension NamiPairingFramework.DeviceUniversalID {
  public static func == (lhs: NamiPairingFramework.DeviceUniversalID, rhs: NamiPairingFramework.DeviceUniversalID) -> Swift.Bool
}
extension NamiPairingFramework.DeviceUniversalID {
  public func hash(into hasher: inout Swift.Hasher)
}
extension NamiPairingFramework.DeviceUniversalID : Swift.Comparable {
  public static func < (lhs: NamiPairingFramework.DeviceUniversalID, rhs: NamiPairingFramework.DeviceUniversalID) -> Swift.Bool
}
extension NamiPairingFramework.DeviceUniversalID : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension NamiPairingFramework.DeviceUniversalID {
  public static func randomValue() -> NamiPairingFramework.DeviceUniversalID
}
extension NamiPairingFramework.DeviceUniversalID : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.UInt64 {
  public init(_ uid: NamiPairingFramework.DeviceUniversalID)
}
public struct RemoteTemplateUI_Place : Swift.Codable, Swift.Equatable {
  public init(id: NamiPairingFramework.PlaceID, urn: Swift.String, name: Swift.String, timeZone: Swift.String? = nil, createdAt: Foundation.Date, updatedAt: Foundation.Date, alertMode: Swift.String)
  public var id: NamiPairingFramework.PlaceID
  public var urn: Swift.String
  public var name: Swift.String
  public var timeZone: Swift.String?
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var alertMode: Swift.String
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_Place, b: NamiPairingFramework.RemoteTemplateUI_Place) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PlaceUser : Swift.Codable, Swift.Equatable {
  public var id: NamiPairingFramework.PlaceUserID
  public var userId: NamiPairingFramework.UserID
  public var name: Swift.String
  public var urn: Swift.String
  public var roleId: Swift.String
  public var roleName: Swift.String
  public var iconId: NamiPairingFramework.UserIconID
  public var themeId: NamiPairingFramework.ThemeID
  public var placeId: NamiPairingFramework.PlaceID
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PlaceUser, b: NamiPairingFramework.RemoteTemplateUI_PlaceUser) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_InviteLink : Swift.Codable, Swift.Equatable {
  public var code: NamiPairingFramework.InviteCode
  public var name: Swift.String
  public var roleId: Swift.String
  public var roleName: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var placeName: Swift.String?
  public var state: Swift.String
  public var inviteUrl: Foundation.URL
  public var expiresAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_InviteLink, b: NamiPairingFramework.RemoteTemplateUI_InviteLink) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PlaceUsageLimits : Swift.Codable, Swift.Equatable {
  public var urn: NamiPairingFramework.URN
  public var membership: Swift.UInt
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PlaceUsageLimits, b: NamiPairingFramework.RemoteTemplateUI_PlaceUsageLimits) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_Zone : Swift.Codable, Swift.Equatable {
  public init(id: NamiPairingFramework.PlaceZoneID, urn: Swift.String, name: Swift.String, alertMode: Swift.String, createdAt: Foundation.Date, updatedAt: Foundation.Date, rooms: [NamiPairingFramework.RemoteTemplateUI_Room], devices: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory)
  public var id: NamiPairingFramework.PlaceZoneID
  public var urn: Swift.String
  public var name: Swift.String
  public var alertMode: Swift.String
  public var rooms: [NamiPairingFramework.RemoteTemplateUI_Room]
  public var devices: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_Zone, b: NamiPairingFramework.RemoteTemplateUI_Zone) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_Room : Swift.Codable, Swift.Equatable {
  public init(id: NamiPairingFramework.RoomID, urn: Swift.String, name: Swift.String, zoneId: NamiPairingFramework.PlaceZoneID, iconId: NamiPairingFramework.IconID, createdAt: Foundation.Date, updatedAt: Foundation.Date, devices: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory)
  public var id: NamiPairingFramework.RoomID
  public var urn: Swift.String
  public var name: Swift.String
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var iconId: NamiPairingFramework.IconID
  public var devices: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_Room, b: NamiPairingFramework.RemoteTemplateUI_Room) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesByCategory : Swift.Codable, Swift.Equatable {
  public var activitySensors: [NamiPairingFramework.RemoteTemplateUI_Device]
  public var accessories: [NamiPairingFramework.RemoteTemplateUI_Device]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory, b: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DeviceState : Swift.Codable, Swift.Equatable {
  public init(cloudAccessible: Swift.Bool? = nil, lastCloudAccess: Foundation.Date? = nil, seqTime: Swift.UInt64, state: Foundation.Data, stateUpdatedAt: Foundation.Date)
  public var cloudAccessible: Swift.Bool?
  public var lastCloudAccess: Foundation.Date?
  public var seqTime: Swift.UInt64
  public var state: Foundation.Data
  public var stateUpdatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DeviceState, b: NamiPairingFramework.RemoteTemplateUI_DeviceState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_Device : Swift.Codable, Swift.Equatable {
  public init(id: NamiPairingFramework.DeviceID, uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, name: Swift.String, codeName: Swift.String, createdAt: Foundation.Date, updatedAt: Foundation.Date, isBr: Swift.Bool, state: NamiPairingFramework.RemoteTemplateUI_DeviceState)
  public var id: NamiPairingFramework.DeviceID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var name: Swift.String
  public var codeName: Swift.String
  public var isBr: Swift.Bool
  public var state: NamiPairingFramework.RemoteTemplateUI_DeviceState?
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_Device, b: NamiPairingFramework.RemoteTemplateUI_Device) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DeviceType : Swift.Codable, Swift.Equatable {
  public init(name: Swift.String, localizedName: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(_ deviceType: NamiPairingFramework.NamiDeviceType)
  public var localizedName: Swift.String
  public var name: Swift.String
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DeviceType, b: NamiPairingFramework.RemoteTemplateUI_DeviceType) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesKit : Swift.Codable, Swift.Equatable {
  public init(name: Swift.String, kitId: Swift.UInt64, firstInZone: Swift.Bool, includedDevices: [NamiPairingFramework.RemoteTemplateUI_DeviceType], pairedDevices: [NamiPairingFramework.DeviceUniversalID])
  public var name: Swift.String
  public var kitId: Swift.UInt64
  public var firstInZone: Swift.Bool
  public var includedDevices: [NamiPairingFramework.RemoteTemplateUI_DeviceType]
  public var pairedDevices: [NamiPairingFramework.DeviceUniversalID]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesKit, b: NamiPairingFramework.RemoteTemplateUI_DevicesKit) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_AutomationAction : Swift.Codable, Swift.Equatable {
  public init(type: Swift.String, mode: NamiPairingFramework.NamiAlertMode)
  public var type: Swift.String
  public var mode: NamiPairingFramework.NamiAlertMode
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_AutomationAction, b: NamiPairingFramework.RemoteTemplateUI_AutomationAction) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_AutomationReaction : Swift.Codable, Swift.Equatable {
  public init(uuid: Swift.String, targetType: Swift.String, targetIds: [NamiPairingFramework.PlaceZoneID], action: NamiPairingFramework.RemoteTemplateUI_AutomationAction)
  public var uuid: Swift.String
  public var targetType: Swift.String
  public var targetIds: [NamiPairingFramework.PlaceZoneID]
  public var action: NamiPairingFramework.RemoteTemplateUI_AutomationAction
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_AutomationReaction, b: NamiPairingFramework.RemoteTemplateUI_AutomationReaction) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_AutomationTrigger : Swift.Codable, Swift.Equatable {
  public init(type: Swift.String, hour: Swift.Int, minute: Swift.Int, daysOfWeek: [Swift.String])
  public var type: Swift.String
  public var hour: Swift.Int
  public var minute: Swift.Int
  public var daysOfWeek: [Swift.String]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_AutomationTrigger, b: NamiPairingFramework.RemoteTemplateUI_AutomationTrigger) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_NamiAutomation : Swift.Codable, Swift.Equatable {
  public init(id: NamiPairingFramework.AutomationID, trigger: NamiPairingFramework.RemoteTemplateUI_AutomationTrigger, reactions: [NamiPairingFramework.RemoteTemplateUI_AutomationReaction], active: Swift.Bool)
  public var id: NamiPairingFramework.AutomationID
  public var trigger: NamiPairingFramework.RemoteTemplateUI_AutomationTrigger
  public var reactions: [NamiPairingFramework.RemoteTemplateUI_AutomationReaction]
  public var active: Swift.Bool
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_NamiAutomation, b: NamiPairingFramework.RemoteTemplateUI_NamiAutomation) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_MemebershipResponse : Swift.Codable, Swift.Equatable {
  public init(users: [NamiPairingFramework.RemoteTemplateUI_PlaceUser], invites: [NamiPairingFramework.RemoteTemplateUI_InviteLink])
  public var users: [NamiPairingFramework.RemoteTemplateUI_PlaceUser]
  public var invites: [NamiPairingFramework.RemoteTemplateUI_InviteLink]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_MemebershipResponse, b: NamiPairingFramework.RemoteTemplateUI_MemebershipResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_InvitePeek : Swift.Codable, Swift.Equatable {
  public init(code: NamiPairingFramework.InviteCode, name: Swift.String, roleId: Swift.String, roleName: Swift.String, placeId: NamiPairingFramework.PlaceID, placeName: Swift.String, placeIconId: NamiPairingFramework.IconID)
  public var code: NamiPairingFramework.InviteCode
  public var name: Swift.String
  public var roleId: Swift.String
  public var roleName: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var placeName: Swift.String
  public var placeIconId: NamiPairingFramework.IconID
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_InvitePeek, b: NamiPairingFramework.RemoteTemplateUI_InvitePeek) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesResponse : Swift.Codable, Swift.Equatable {
  public init(devices: [NamiPairingFramework.RemoteTemplateUI_Device], total: Swift.Int, pageSize: Swift.Int, cursor: Swift.String? = nil)
  public var devices: [NamiPairingFramework.RemoteTemplateUI_Device]
  public var total: Swift.Int
  public var pageSize: Swift.Int
  public var cursor: Swift.String?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesResponse, b: NamiPairingFramework.RemoteTemplateUI_DevicesResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesCommandResponseResult : Swift.Codable, Swift.Equatable {
  public init(uid: NamiPairingFramework.DeviceUniversalID, success: Swift.Bool, errorMessage: Swift.String? = nil, errorCode: Swift.String? = nil)
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var success: Swift.Bool
  public var errorMessage: Swift.String?
  public var errorCode: Swift.String?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponseResult, b: NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponseResult) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesCommandResponse : Swift.Codable, Swift.Equatable {
  public init(seqTime: Swift.UInt64, results: [NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponseResult])
  public var seqTime: Swift.UInt64
  public var results: [NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponseResult]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponse, b: NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesQuery : Swift.Codable, Swift.Equatable {
  public init(placeIds: [NamiPairingFramework.PlaceID], zoneIds: [NamiPairingFramework.PlaceZoneID], roomIds: [NamiPairingFramework.RoomID], uids: [NamiPairingFramework.DeviceUniversalID], cursor: Swift.String? = nil)
  public var placeIds: [NamiPairingFramework.PlaceID]
  public var zoneIds: [NamiPairingFramework.PlaceZoneID]
  public var roomIds: [NamiPairingFramework.RoomID]
  public var uids: [NamiPairingFramework.DeviceUniversalID]
  public var cursor: Swift.String?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesQuery, b: NamiPairingFramework.RemoteTemplateUI_DevicesQuery) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_ActivityEvent : Swift.Codable, Swift.Equatable {
  public init(uuid: Foundation.UUID? = nil, startedAt: Foundation.Date, endedAt: Foundation.Date? = nil, detection: Swift.Bool, health: Swift.String)
  public var uuid: Foundation.UUID?
  public var startedAt: Foundation.Date
  public var endedAt: Foundation.Date?
  public var detection: Swift.Bool
  public var health: Swift.String
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_ActivityEvent, b: NamiPairingFramework.RemoteTemplateUI_ActivityEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_ZoneMotionEvent : Swift.Codable, Swift.Equatable {
  public init(zoneId: NamiPairingFramework.PlaceZoneID, motionEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent], occupancyEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent])
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var motionEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent]
  public var occupancyEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_ZoneMotionEvent, b: NamiPairingFramework.RemoteTemplateUI_ZoneMotionEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_ZoneMotionStatus : Swift.Codable, Swift.Equatable {
  public init(id: NamiPairingFramework.PlaceZoneID, detection: Swift.Bool? = nil, startedAt: Foundation.Date? = nil, health: Swift.String)
  public var id: NamiPairingFramework.PlaceZoneID
  public var detection: Swift.Bool?
  public var startedAt: Foundation.Date?
  public var health: Swift.String
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_ZoneMotionStatus, b: NamiPairingFramework.RemoteTemplateUI_ZoneMotionStatus) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PlaceMotionHistory : Swift.Codable, Swift.Equatable {
  public init(placeId: NamiPairingFramework.PlaceID, motionEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent], occupancyEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent])
  public var placeId: NamiPairingFramework.PlaceID
  public var motionEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent]
  public var occupancyEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PlaceMotionHistory, b: NamiPairingFramework.RemoteTemplateUI_PlaceMotionHistory) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_MotionInterval : Swift.Codable, Swift.Equatable {
  public init(start: Foundation.Date, value: Swift.UInt8)
  public var start: Foundation.Date
  public var value: Swift.UInt8
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_MotionInterval, b: NamiPairingFramework.RemoteTemplateUI_MotionInterval) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_MotionAggregate : Swift.Codable, Swift.Equatable {
  public init(metric: Swift.String, resolution: Swift.String, intervalLength: Foundation.TimeInterval, intervals: [NamiPairingFramework.RemoteTemplateUI_MotionInterval])
  public var metric: Swift.String
  public var resolution: Swift.String
  public var intervalLength: Foundation.TimeInterval
  public var intervals: [NamiPairingFramework.RemoteTemplateUI_MotionInterval]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_MotionAggregate, b: NamiPairingFramework.RemoteTemplateUI_MotionAggregate) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_ZoneSparkline : Swift.Codable, Swift.Equatable {
  public init(zoneUrn: Swift.String, metric: Swift.String, resolution: Swift.String, intervalLength: Foundation.TimeInterval, intervals: [NamiPairingFramework.RemoteTemplateUI_MotionInterval])
  public var zoneUrn: Swift.String
  public var metric: Swift.String
  public var resolution: Swift.String
  public var intervalLength: Foundation.TimeInterval
  public var intervals: [NamiPairingFramework.RemoteTemplateUI_MotionInterval]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_ZoneSparkline, b: NamiPairingFramework.RemoteTemplateUI_ZoneSparkline) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PlaceMotionAggregates : Swift.Codable, Swift.Equatable {
  public init(placeId: NamiPairingFramework.PlaceID, aggregates: [NamiPairingFramework.RemoteTemplateUI_MotionAggregate], sparklines: [NamiPairingFramework.RemoteTemplateUI_ZoneSparkline]? = nil)
  public var placeId: NamiPairingFramework.PlaceID
  public var aggregates: [NamiPairingFramework.RemoteTemplateUI_MotionAggregate]
  public var sparklines: [NamiPairingFramework.RemoteTemplateUI_ZoneSparkline]?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PlaceMotionAggregates, b: NamiPairingFramework.RemoteTemplateUI_PlaceMotionAggregates) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_ZoneMotionAggregates : Swift.Codable, Swift.Equatable {
  public init(zoneId: NamiPairingFramework.PlaceZoneID, aggregates: [NamiPairingFramework.RemoteTemplateUI_MotionAggregate])
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var aggregates: [NamiPairingFramework.RemoteTemplateUI_MotionAggregate]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_ZoneMotionAggregates, b: NamiPairingFramework.RemoteTemplateUI_ZoneMotionAggregates) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_RestEvent : Swift.Codable, Swift.Equatable {
  public init(deviceUid: NamiPairingFramework.DeviceUniversalID, startedAt: Foundation.Date, endedAt: Foundation.Date)
  public var deviceUid: NamiPairingFramework.DeviceUniversalID
  public var startedAt: Foundation.Date
  public var endedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_RestEvent, b: NamiPairingFramework.RemoteTemplateUI_RestEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_RestEventsResponse : Swift.Codable, Swift.Equatable {
  public init(restEvents: [NamiPairingFramework.RemoteTemplateUI_RestEvent])
  public var restEvents: [NamiPairingFramework.RemoteTemplateUI_RestEvent]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_RestEventsResponse, b: NamiPairingFramework.RemoteTemplateUI_RestEventsResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_RestInsight : Swift.Codable, Swift.Equatable {
  public init(deviceUid: NamiPairingFramework.DeviceUniversalID, totalRestTime: Swift.Int, numberOfInterruptions: Swift.Int, timeToBed: Foundation.Date? = nil, outOfBedAt: Foundation.Date? = nil)
  public var deviceUid: NamiPairingFramework.DeviceUniversalID
  public var totalRestTime: Swift.Int
  public var numberOfInterruptions: Swift.Int
  public var timeToBed: Foundation.Date?
  public var outOfBedAt: Foundation.Date?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_RestInsight, b: NamiPairingFramework.RemoteTemplateUI_RestInsight) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_RestInsightsResponse : Swift.Codable, Swift.Equatable {
  public init(restInsights: [NamiPairingFramework.RemoteTemplateUI_RestInsight])
  public var restInsights: [NamiPairingFramework.RemoteTemplateUI_RestInsight]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_RestInsightsResponse, b: NamiPairingFramework.RemoteTemplateUI_RestInsightsResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DeviceAttributeState : Swift.Codable, Swift.Equatable {
  public init(uid: NamiPairingFramework.DeviceUniversalID, endpoint: Swift.Int, path: Swift.String, value: Swift.String? = nil, updatedAt: Foundation.Date, isDeleted: Swift.Bool)
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var endpoint: Swift.Int
  public var path: Swift.String
  public var value: Swift.String?
  public var updatedAt: Foundation.Date
  public var isDeleted: Swift.Bool
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DeviceAttributeState, b: NamiPairingFramework.RemoteTemplateUI_DeviceAttributeState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DeviceAttributeStateResponse : Swift.Codable, Swift.Equatable {
  public init(deviceAttributeStates: [NamiPairingFramework.RemoteTemplateUI_DeviceAttributeState], total: Swift.Int, pageSize: Swift.Int, cursor: Swift.String? = nil)
  public var deviceAttributeStates: [NamiPairingFramework.RemoteTemplateUI_DeviceAttributeState]
  public var total: Swift.Int
  public var pageSize: Swift.Int
  public var cursor: Swift.String?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStateResponse, b: NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStateResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DeviceAttributeStatesQuery {
  public init(placeIds: [NamiPairingFramework.PlaceID], zoneIds: [NamiPairingFramework.PlaceZoneID], roomIds: [NamiPairingFramework.RoomID], uids: [NamiPairingFramework.DeviceUniversalID], from: Foundation.Date? = nil, to: Foundation.Date? = nil, cursor: Swift.String? = nil)
  public var placeIds: [NamiPairingFramework.PlaceID]
  public var zoneIds: [NamiPairingFramework.PlaceZoneID]
  public var roomIds: [NamiPairingFramework.RoomID]
  public var uids: [NamiPairingFramework.DeviceUniversalID]
  public var from: Foundation.Date?
  public var to: Foundation.Date?
  public var cursor: Swift.String?
  public static func parameters(placeIds: [NamiPairingFramework.PlaceID] = [], zoneIds: [NamiPairingFramework.PlaceZoneID] = [], roomIds: [NamiPairingFramework.RoomID] = [], uids: [NamiPairingFramework.DeviceUniversalID] = [], from: Foundation.Date? = nil, to: Foundation.Date? = nil, cursor: Swift.String? = nil) -> NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStatesQuery
  public func getQueryItems() -> [Foundation.URLQueryItem]
}
public struct NamiDeviceModel : Swift.Equatable {
  public init(codeName: Swift.String, hardwareModel: Swift.String, productLabel: Swift.String, productId: NamiPairingFramework.DeviceProductID, deviceType: NamiPairingFramework.NamiDeviceType, connectivity: [NamiPairingFramework.NamiDeviceConnectivity])
  public var codeName: Swift.String
  public var hardwareModel: Swift.String
  public var productLabel: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public var deviceType: NamiPairingFramework.NamiDeviceType
  public var connectivity: [NamiPairingFramework.NamiDeviceConnectivity]
  public static func == (a: NamiPairingFramework.NamiDeviceModel, b: NamiPairingFramework.NamiDeviceModel) -> Swift.Bool
}
extension NamiPairingFramework.NamiDeviceModel {
  public static let unknown: NamiPairingFramework.NamiDeviceModel
}
public enum NamiAppearance : Swift.String, Swift.Equatable, Swift.CaseIterable, Swift.Identifiable {
  case light
  case dark
  public var id: NamiPairingFramework.NamiAppearance {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [NamiPairingFramework.NamiAppearance]
  public typealias ID = NamiPairingFramework.NamiAppearance
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [NamiPairingFramework.NamiAppearance] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum NamiDeviceType : Swift.CaseIterable {
  case unknown
  case contactSensor
  case motionSensor
  case meshSensor
  case securityPod
  case alarmPod
  case wifiSensor
  case keypad
  case widarSensor
  public static var allCases: [NamiPairingFramework.NamiDeviceType] {
    get
  }
  public static var allSensorDevices: [NamiPairingFramework.NamiDeviceType] {
    get
  }
  public static var allThreadDevices: [NamiPairingFramework.NamiDeviceType] {
    get
  }
  public static var allAccessoryDevices: [NamiPairingFramework.NamiDeviceType] {
    get
  }
  public var capabilities: [NamiPairingFramework.NamiDeviceCapability] {
    get
  }
  public var localizedName: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.NamiDeviceType, b: NamiPairingFramework.NamiDeviceType) -> Swift.Bool
  public typealias AllCases = [NamiPairingFramework.NamiDeviceType]
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NamiAlertMode : Swift.Int, Swift.Comparable, Swift.Codable {
  case armed
  case stay
  case standby
  public init(mode: Swift.String)
  public static func < (lhs: NamiPairingFramework.NamiAlertMode, rhs: NamiPairingFramework.NamiAlertMode) -> Swift.Bool
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum NamiOutletType : Swift.CaseIterable {
  case typeE
  case typeF
  case typeG
  case typeB
  case typeA
  case unknown
  public static func == (a: NamiPairingFramework.NamiOutletType, b: NamiPairingFramework.NamiOutletType) -> Swift.Bool
  public typealias AllCases = [NamiPairingFramework.NamiOutletType]
  nonisolated public static var allCases: [NamiPairingFramework.NamiOutletType] {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class OutletTypeMapper {
  public static let shared: NamiPairingFramework.OutletTypeMapper
  public func getOutletType(by countryCode: Swift.String) -> NamiPairingFramework.NamiOutletType
  @objc deinit
}
public protocol PairDeviceResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype WiredPlaceKeys : NamiPairingFramework.WiredPlaceKeysProtocol
  associatedtype Device : NamiPairingFramework.DeviceProtocol
  var payload: Self.WiredPlaceKeys { get }
  var device: Self.Device { get }
}
public protocol PairingChallengeResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype DeviceModel : NamiPairingFramework.DeviceModelProtocol
  var challenge: Swift.String { get }
  var model: Self.DeviceModel { get }
}
public protocol WiFiCredentialsUpdateSessionProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype UpdatedDevice : NamiPairingFramework.UpdatedDeviceProtocol
  var id: NamiPairingFramework.WiFiCredentialsUpdateSessionID { get }
  var zoneId: NamiPairingFramework.PlaceZoneID { get }
  var updatedDevices: [Self.UpdatedDevice]? { get }
}
public protocol WiredPlaceKeysProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var ciphertext: Swift.String { get }
  var iv: Swift.String { get }
  var authTag: Swift.String { get }
  var serverKey: Swift.String { get }
}
public protocol UpdatedDeviceProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var uid: NamiPairingFramework.DeviceUniversalID { get }
}
public protocol DeviceModelProtocol : Swift.Decodable, Swift.Encodable {
  var codeName: Swift.String { get }
  var productLabel: Swift.String { get }
  var productId: NamiPairingFramework.DeviceProductID { get }
}
public protocol RemoteTemplateUI_PlaceProtocol : Swift.Encodable {
  var id: NamiPairingFramework.PlaceID { get }
  var urn: Swift.String { get }
  var name: Swift.String { get }
  var themeId: NamiPairingFramework.ThemeID { get }
  var iconId: NamiPairingFramework.IconID { get }
  var propertyTypeId: NamiPairingFramework.PropertyTypeID? { get }
  var propertyElevationId: NamiPairingFramework.PropertyElevationID? { get }
  var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID? { get }
  var petTypeId: NamiPairingFramework.PetTypeID? { get }
  var timeZone: Swift.String? { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
  var alertMode: Swift.String? { get }
}
public protocol RemoteTemplateUI_PlaceUserProtocol : Swift.Encodable {
  associatedtype PlaceUserRole = any NamiPairingFramework.RemoteTemplateUI_PlaceUserRoleProtocol
  var id: NamiPairingFramework.PlaceUserID { get }
  var userId: NamiPairingFramework.UserID { get }
  var name: Swift.String { get }
  var urn: Swift.String { get }
  var role: Self.PlaceUserRole { get }
  var iconId: NamiPairingFramework.UserIconID { get }
  var themeId: NamiPairingFramework.ThemeID { get }
  var placeId: NamiPairingFramework.PlaceID { get }
}
public protocol RemoteTemplateUI_PlaceUserRoleProtocol : Swift.Encodable {
  var id: Swift.String { get }
  var name: Swift.String { get }
}
public protocol RemoteTemplateUI_InviteLinkProtocol : Swift.Encodable {
  var code: NamiPairingFramework.InviteCode { get }
  var name: Swift.String { get }
  var roleId: Swift.String { get }
  var roleName: Swift.String { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var placeName: Swift.String? { get }
  var state: Swift.String { get }
  var inviteUrl: Foundation.URL { get }
  var expiresAt: Foundation.Date { get }
}
public protocol RemoteTemplateUI_PlaceUsageLimitsProtocol : Swift.Encodable {
  var urn: NamiPairingFramework.URN { get }
  var membership: Swift.UInt { get }
}
public protocol RemoteTemplateUI_ZoneProtocol : Swift.Encodable {
  var id: NamiPairingFramework.PlaceZoneID { get }
  var externalId: Swift.String? { get }
  var urn: Swift.String { get }
  var name: Swift.String { get }
  var alertMode: Swift.String { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
}
public protocol RemoteTemplateUI_RoomProtocol : Swift.Encodable {
  var id: NamiPairingFramework.RoomID { get }
  var urn: Swift.String { get }
  var name: Swift.String { get }
  var zoneId: NamiPairingFramework.PlaceZoneID { get }
  var iconId: NamiPairingFramework.IconID { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
}
public protocol DeviceProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype State : NamiPairingFramework.DeviceStateProtocol
  associatedtype CloudConnection : NamiPairingFramework.DeviceCloudConnectionStatusProtocol
  var id: NamiPairingFramework.DeviceID { get }
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var urn: Swift.String { get }
  var roomId: NamiPairingFramework.RoomID { get }
  var bleDiscriminator: Swift.Int32? { get }
  var name: Swift.String { get }
  var codeName: Swift.String { get }
  var productId: NamiPairingFramework.DeviceProductID { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
  var model: any NamiPairingFramework.DeviceModelProtocol { get }
  var isBorderRouter: Swift.Bool { get }
  var cloudConnection: Self.CloudConnection? { get }
  var deviceState: Self.State? { get }
}
public protocol DeviceStateProtocol : Swift.Decodable, Swift.Encodable {
  var payload: Foundation.Data { get }
  var seqTime: Swift.UInt64 { get }
  var updatedAt: Foundation.Date { get }
}
public protocol DeviceCloudConnectionStatusProtocol : Swift.Decodable, Swift.Encodable {
  var isConnected: Swift.Bool { get }
  var updatedAt: Foundation.Date? { get }
}
public protocol DeviceStateAnalyzerProtocol {
  func isBorderRouter(from stateData: Foundation.Data) -> Swift.Bool
}
public protocol RemoteTemplateUI_NamiAutomationProtocol : Swift.Encodable {
  associatedtype Trigger : NamiPairingFramework.RemoteTemplateUI_AutomationTriggerProtocol
  associatedtype Reaction : NamiPairingFramework.RemoteTemplateUI_AutomationReactionProtocol
  var id: NamiPairingFramework.AutomationID { get }
  var trigger: Self.Trigger { get }
  var reactions: [Self.Reaction] { get }
  var active: Swift.Bool { get }
}
public protocol RemoteTemplateUI_AutomationTriggerProtocol : Swift.Encodable {
  var type: Swift.String { get }
  var hour: Swift.Int { get }
  var minute: Swift.Int { get }
  var daysOfWeek: [Swift.String] { get }
}
public protocol RemoteTemplateUI_AutomationReactionProtocol : Swift.Encodable {
  associatedtype Action : NamiPairingFramework.RemoteTemplateUI_AutomationActionProtocol
  var uuid: Swift.String { get }
  var targetType: Swift.String { get }
  var targetIds: [NamiPairingFramework.PlaceZoneID] { get }
  var action: Self.Action { get }
}
public protocol RemoteTemplateUI_AutomationActionProtocol : Swift.Encodable {
  var type: Swift.String { get }
  var mode: Swift.String { get }
}
public protocol RemoteTemplateUI_MemebershipResponseProtocol : Swift.Encodable {
  associatedtype User : NamiPairingFramework.RemoteTemplateUI_PlaceUserProtocol
  associatedtype Invite : NamiPairingFramework.RemoteTemplateUI_InviteLinkProtocol
  var users: [Self.User] { get }
  var invites: [Self.Invite] { get }
}
public protocol RemoteTemplateUI_InvitePeekProtocol : Swift.Encodable {
  var code: NamiPairingFramework.InviteCode { get }
  var name: Swift.String { get }
  var roleId: Swift.String { get }
  var roleName: Swift.String { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var placeName: Swift.String { get }
  var placeIconId: NamiPairingFramework.IconID { get }
}
public protocol DevicesResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Device : NamiPairingFramework.DeviceProtocol
  var total: Swift.Int { get }
  var pageSize: Swift.Int { get }
  var cursor: Swift.String? { get }
  var devices: [Self.Device] { get }
}
public protocol DevicesCommandResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Result : NamiPairingFramework.DevicesCommandResponseResultProtocol
  var seqTime: Swift.UInt64 { get }
  var results: [Self.Result] { get }
}
public protocol DevicesCommandResponseResultProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype DeviceConnections_DeviceCommandResponseContent : NamiPairingFramework.DeviceCommandResponseContentProtocol
  var devices: [NamiPairingFramework.DeviceUniversalID : Self.DeviceConnections_DeviceCommandResponseContent] { get }
  var isCloudResponse: Swift.Bool { get }
}
public protocol DeviceCommandResponseContentProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype DeviceConnections_DeviceCommandResponseError : NamiPairingFramework.DeviceCommandResponseErrorProtocol
  var success: Swift.Bool { get }
  var error: Self.DeviceConnections_DeviceCommandResponseError? { get }
}
public protocol DeviceCommandResponseErrorProtocol : Swift.Decodable, Swift.Encodable, Swift.Error {
  var error: Swift.String { get }
  var errorCode: Swift.String { get }
}
public protocol DevicesQueryProtocol : Swift.Decodable, Swift.Encodable {
  var uids: [NamiPairingFramework.DeviceUniversalID] { get set }
  var cursor: Swift.String? { get set }
  var roomIds: [NamiPairingFramework.RoomID] { get set }
  var zoneIds: [NamiPairingFramework.PlaceZoneID] { get set }
  var placeIds: [NamiPairingFramework.PlaceID] { get set }
}
public protocol RemoteTemplateUI_ActivityEventProtocol : Swift.Encodable {
  var uuid: Foundation.UUID? { get }
  var startedAt: Foundation.Date { get }
  var endedAt: Foundation.Date? { get }
  var detection: Swift.Bool { get }
  var health: Swift.String { get }
}
public protocol RemoteTemplateUI_ZoneMotionEventProtocol : Swift.Encodable {
  associatedtype Event : NamiPairingFramework.RemoteTemplateUI_ActivityEventProtocol
  var zoneId: NamiPairingFramework.PlaceZoneID { get }
  var motionEvents: [Self.Event] { get }
  var occupancyEvents: [Self.Event] { get }
}
public protocol RemoteTemplateUI_PlaceMotionHistoryProtocol : Swift.Encodable {
  associatedtype Event : NamiPairingFramework.RemoteTemplateUI_ActivityEventProtocol
  var placeId: NamiPairingFramework.PlaceID { get }
  var motionEvents: [Self.Event] { get }
  var occupancyEvents: [Self.Event] { get }
}
public protocol RemoteTemplateUI_MotionIntervalProtocol : Swift.Encodable {
  var start: Foundation.Date { get }
  var value: Swift.UInt8 { get }
}
public protocol RemoteTemplateUI_MotionAggregateProtocol : Swift.Encodable {
  associatedtype Interval : NamiPairingFramework.RemoteTemplateUI_MotionIntervalProtocol
  var metric: Swift.String { get }
  var resolution: Swift.String { get }
  var intervalLength: Foundation.TimeInterval { get }
  var intervals: [Self.Interval] { get }
}
public protocol RemoteTemplateUI_ZoneSparklineProtocol : Swift.Encodable {
  associatedtype Interval : NamiPairingFramework.RemoteTemplateUI_MotionIntervalProtocol
  var zoneUrn: Swift.String { get }
  var metric: Swift.String { get }
  var resolution: Swift.String { get }
  var intervalLength: Foundation.TimeInterval { get }
  var intervals: [Self.Interval] { get }
}
public protocol RemoteTemplateUI_PlaceMotionAggregatesProtocol : Swift.Encodable {
  associatedtype Aggregate : NamiPairingFramework.RemoteTemplateUI_MotionAggregateProtocol
  associatedtype Sparkline : NamiPairingFramework.RemoteTemplateUI_ZoneSparklineProtocol
  var placeId: NamiPairingFramework.PlaceID { get }
  var aggregates: [Self.Aggregate] { get }
  var sparklines: [Self.Sparkline]? { get }
}
public protocol RemoteTemplateUI_ZoneMotionAggregatesProtocol : Swift.Encodable {
  associatedtype Aggregate : NamiPairingFramework.RemoteTemplateUI_MotionAggregateProtocol
  var zoneId: NamiPairingFramework.PlaceZoneID { get }
  var aggregates: [Self.Aggregate] { get }
}
public protocol RemoteTemplateUI_RestEventProtocol : Swift.Encodable {
  var deviceUid: NamiPairingFramework.DeviceUniversalID { get }
  var startedAt: Foundation.Date { get }
  var endedAt: Foundation.Date { get }
}
public protocol RemoteTemplateUI_RestEventsResponseProtocol : Swift.Encodable {
  associatedtype RestEvent : NamiPairingFramework.RemoteTemplateUI_RestEventProtocol
  var restEvents: [Self.RestEvent] { get }
}
public protocol RemoteTemplateUI_RestInsightProtocol : Swift.Encodable {
  var deviceUid: NamiPairingFramework.DeviceUniversalID { get }
  var totalRestTime: Swift.Int { get }
  var numberOfInterruptions: Swift.Int { get }
  var timeToBed: Foundation.Date? { get }
  var outOfBedAt: Foundation.Date? { get }
}
public protocol RemoteTemplateUI_RestInsightsResponseProtocol : Swift.Encodable {
  associatedtype RestInsight : NamiPairingFramework.RemoteTemplateUI_RestInsightProtocol
  var restInsights: [Self.RestInsight] { get }
}
public protocol RemoteTemplateUI_DeviceAttributeStateProtocol : Swift.Encodable {
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var endpoint: Swift.Int { get }
  var path: Swift.String { get }
  var value: Swift.String? { get }
  var updatedAt: Foundation.Date { get }
  var isDeleted: Swift.Bool { get }
}
public protocol RemoteTemplateUI_DeviceAttributeStateResponseProtocol : Swift.Encodable {
  associatedtype DeviceAttributeState : NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStateProtocol
  var deviceAttributeStates: [Self.DeviceAttributeState] { get }
  var total: Swift.Int { get }
  var pageSize: Swift.Int { get }
  var cursor: Swift.String? { get }
}
public protocol DeviceControlMessageProtocol : Swift.Decodable, Swift.Encodable {
  var data: Foundation.Data { get }
}
public protocol ThreadCredentialsMessageProtocol : Swift.Decodable, Swift.Encodable {
  var networkName: Swift.String { get }
  var extendedPanId: Foundation.Data { get }
  var panId: Swift.UInt16 { get }
  var channel: Swift.UInt8 { get }
  var pskc: Foundation.Data { get }
  var masterKey: Foundation.Data { get }
  var meshLocalPrefix: Foundation.Data { get }
  var operationalDataset: Foundation.Data { get }
  var borderAgentID: Foundation.Data { get }
}
public protocol RemoteTemplateStateRepositoryProtocol {
  func place(id placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Place, Swift.Never>
  func zones(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Zone], Swift.Never>
  func rooms(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Room], Swift.Never>
  func rooms(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Room], Swift.Never>
  func device(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  func device(urn: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  func device(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  func devices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  func devices(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  func devices(roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  func devicesPerZone(in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZoneID : [NamiPairingFramework.RemoteTemplateUI_Device]], Swift.Never>
  func deviceModel(productId: NamiPairingFramework.DeviceProductID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDeviceModel, Swift.Never>
  func deviceModel(codeName: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.NamiDeviceModel, Swift.Never>
  func deviceState(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_DeviceState?, Swift.Never>
  func refreshPlace(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func refreshDevices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func createZone(placeId: NamiPairingFramework.PlaceID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZoneID, any Swift.Error>
  func createRoom(placeZoneId: NamiPairingFramework.PlaceZoneID, name: Swift.String, iconId: NamiPairingFramework.IconID) -> Combine.AnyPublisher<NamiPairingFramework.RoomID, any Swift.Error>
  func deleteDevice(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func deleteZone(_ zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func deleteRoom(_ roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Place, any Swift.Error>
}
public protocol RemoteTemplateEntrypointProtocol : Swift.RawRepresentable where Self.RawValue == Swift.String {
}
extension NamiPairingFramework.RemoteTemplateEntrypointProtocol {
  public func url(base: Foundation.URL) -> Foundation.URL
}
public protocol PairingWebAPIProtocol {
  associatedtype Pairing_DevicesQueryProtocol : NamiPairingFramework.DevicesQueryProtocol
  associatedtype Pairing_DeviceResponse : NamiPairingFramework.DeviceProtocol
  associatedtype Pairing_DevicesResponse : NamiPairingFramework.DevicesResponseProtocol
  associatedtype Pairing_PairDeviceResponse : NamiPairingFramework.PairDeviceResponseProtocol
  associatedtype Pairing_Place : NamiPairingFramework.RemoteTemplateUI_PlaceProtocol
  associatedtype Pairing_PlaceZone : NamiPairingFramework.RemoteTemplateUI_ZoneProtocol
  associatedtype Pairing_PairingChallengeResponse : NamiPairingFramework.PairingChallengeResponseProtocol
  associatedtype Pairing_WiFiCredentialsUpdateSession : NamiPairingFramework.WiFiCredentialsUpdateSessionProtocol
  func placeDetails(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.Pairing_Place, any Swift.Error>
  func listDevices(query: any NamiPairingFramework.DevicesQueryProtocol) -> Combine.AnyPublisher<Self.Pairing_DevicesResponse, any Swift.Error>
  func listPlaceZones(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Self.Pairing_PlaceZone], any Swift.Error>
  func requestPairingChallenge(roomId: NamiPairingFramework.RoomID, deviceCertificate: Swift.String) -> Combine.AnyPublisher<Self.Pairing_PairingChallengeResponse, any Swift.Error>
  func pairDevice(roomId: NamiPairingFramework.RoomID, deviceName: Swift.String, cloudChallenge: Swift.String, deviceResponse: Swift.String, deviceCertificate: Swift.String, intent: Swift.String?) -> Combine.AnyPublisher<Self.Pairing_PairDeviceResponse, any Swift.Error>
  func renameDevice(id: NamiPairingFramework.DeviceID, name: Swift.String) -> Combine.AnyPublisher<Self.Pairing_DeviceResponse, any Swift.Error>
  func deleteDevice(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func getWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<Self.Pairing_WiFiCredentialsUpdateSession, any Swift.Error>
  func deleteDeviceFromSession(uid: NamiPairingFramework.DeviceUniversalID, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<Self.Pairing_WiFiCredentialsUpdateSession, any Swift.Error>
}
public protocol RemoteTemplateUI_StorageProtocol {
  associatedtype Place : NamiPairingFramework.RemoteTemplateUI_PlaceProtocol
  associatedtype Zone : NamiPairingFramework.RemoteTemplateUI_ZoneProtocol
  associatedtype Room : NamiPairingFramework.RemoteTemplateUI_RoomProtocol
  associatedtype Device : NamiPairingFramework.DeviceProtocol
  associatedtype PlaceAutomation : NamiPairingFramework.RemoteTemplateUI_NamiAutomationProtocol
  associatedtype PlaceUser : NamiPairingFramework.RemoteTemplateUI_PlaceUserProtocol
  associatedtype UserInvite : NamiPairingFramework.RemoteTemplateUI_InviteLinkProtocol
  associatedtype PlaceUsageLimits : NamiPairingFramework.RemoteTemplateUI_PlaceUsageLimitsProtocol
  func place(id placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.Place, Swift.Never>
  func zones(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Self.Zone], Swift.Never>
  func rooms(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Self.Room], Swift.Never>
  func devices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Self.Device], Swift.Never>
  func automations(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Self.PlaceAutomation], Swift.Never>
  func placeUsers(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Self.PlaceUser], Swift.Never>
  func placeInvites(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Self.UserInvite], Swift.Never>
  func usageLimits(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.PlaceUsageLimits, Swift.Never>
}
public protocol RemoteTemplateUI_WebAPIProtocol {
  associatedtype RepresentablePlace : NamiPairingFramework.RemoteTemplateUI_PlaceProtocol
  associatedtype RepresentableZone : NamiPairingFramework.RemoteTemplateUI_ZoneProtocol
  associatedtype RepresentableRoom : NamiPairingFramework.RemoteTemplateUI_RoomProtocol
  associatedtype RepresentableMembershipResponse : NamiPairingFramework.RemoteTemplateUI_MemebershipResponseProtocol
  associatedtype RepresentableInvitePeek : NamiPairingFramework.RemoteTemplateUI_InvitePeekProtocol
  associatedtype RepresentableDevice : NamiPairingFramework.DeviceProtocol
  associatedtype RepresentableDevicesQuery : NamiPairingFramework.DevicesQueryProtocol
  associatedtype RepresentableDevicesResponse : NamiPairingFramework.DevicesResponseProtocol
  associatedtype RepresentableDevicesCommandResponse : NamiPairingFramework.DevicesCommandResponseProtocol
  associatedtype RepresentablePlaceAutomation : NamiPairingFramework.RemoteTemplateUI_NamiAutomationProtocol
  associatedtype RepresentableZoneMotionEvent : NamiPairingFramework.RemoteTemplateUI_ZoneMotionEventProtocol
  associatedtype RepresentablePlaceMotionHistory : NamiPairingFramework.RemoteTemplateUI_PlaceMotionHistoryProtocol
  associatedtype RepresentablePlaceMotionAggregates : NamiPairingFramework.RemoteTemplateUI_PlaceMotionAggregatesProtocol
  associatedtype RepresentableZoneMotionAggregates : NamiPairingFramework.RemoteTemplateUI_ZoneMotionAggregatesProtocol
  associatedtype RepresentableInviteLink : NamiPairingFramework.RemoteTemplateUI_InviteLinkProtocol
  associatedtype RepresentableRestEventsResponse : NamiPairingFramework.RemoteTemplateUI_RestEventsResponseProtocol
  associatedtype RepresentableRestInsightsResponse : NamiPairingFramework.RemoteTemplateUI_RestInsightsResponseProtocol
  associatedtype RepresentableDeviceAttributeStateResponse : NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStateResponseProtocol
  func leavePlace(id: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func deletePlace(id: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func deletePlaceZone(in placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<Self.RepresentablePlace, any Swift.Error>
  func deletePlaceRoom(in placeId: NamiPairingFramework.PlaceID, roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<Self.RepresentablePlace, any Swift.Error>
  func listPlaceMembers(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.RepresentableMembershipResponse, any Swift.Error>
  func deletePlaceUser(from placeId: NamiPairingFramework.PlaceID, user userId: NamiPairingFramework.UserID) -> Combine.AnyPublisher<Self.RepresentableMembershipResponse, any Swift.Error>
  func updatePlaceUser(for placeId: NamiPairingFramework.PlaceID, userId: NamiPairingFramework.UserID, roleId: Swift.String) -> Combine.AnyPublisher<Self.RepresentableMembershipResponse, any Swift.Error>
  func revokeInvite(code: NamiPairingFramework.InviteCode, from placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.RepresentableMembershipResponse, any Swift.Error>
  func invitationDetails(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<Self.RepresentableInvitePeek, any Swift.Error>
  func acceptInvitation(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func declineInvitation(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func createZone(place: NamiPairingFramework.PlaceID, name: Swift.String) -> Combine.AnyPublisher<Self.RepresentableZone, any Swift.Error>
  func updateZone(id: NamiPairingFramework.PlaceZoneID, name: Swift.String) -> Combine.AnyPublisher<Self.RepresentableZone, any Swift.Error>
  func createRoom(zone: NamiPairingFramework.PlaceZoneID, name: Swift.String, icon: NamiPairingFramework.IconID) -> Combine.AnyPublisher<Self.RepresentableRoom, any Swift.Error>
  func updateRoom(id: NamiPairingFramework.RoomID, name: Swift.String, icon: NamiPairingFramework.IconID) -> Combine.AnyPublisher<Self.RepresentableRoom, any Swift.Error>
  func listDevices(query: Self.RepresentableDevicesQuery) -> Combine.AnyPublisher<Self.RepresentableDevicesResponse, any Swift.Error>
  func deleteDevice(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func moveDevices(deviceUIDs: [NamiPairingFramework.DeviceUniversalID], roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<[Self.RepresentableDevice], any Swift.Error>
  func renameDevice(id: NamiPairingFramework.DeviceID, name: Swift.String) -> Combine.AnyPublisher<Self.RepresentableDevice, any Swift.Error>
  func sendDeviceCommandRequests(in placeId: NamiPairingFramework.PlaceID, uids: [NamiPairingFramework.DeviceUniversalID], messages: [Foundation.Data]) -> Combine.AnyPublisher<Self.RepresentableDevicesCommandResponse, any Swift.Error>
  func listAutomation(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Self.RepresentablePlaceAutomation], any Swift.Error>
  func createAutomation(placeId: NamiPairingFramework.PlaceID, alertMode: Swift.String, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<Self.RepresentablePlaceAutomation, any Swift.Error>
  func updateAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, alertMode: Swift.String, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<Self.RepresentablePlaceAutomation, any Swift.Error>
  func changeAutomationActive(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, active: Swift.Bool) -> Combine.AnyPublisher<Self.RepresentablePlaceAutomation, any Swift.Error>
  func deleteAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<Self.RepresentablePlaceAutomation, any Swift.Error>
  func getPlaceMotionHistory(for placeId: NamiPairingFramework.PlaceID, from: Foundation.Date) -> Combine.AnyPublisher<Self.RepresentablePlaceMotionHistory, any Swift.Error>
  func getZoneMotionHistory(for zoneIds: [NamiPairingFramework.PlaceZoneID], from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<[Self.RepresentableZoneMotionEvent], any Swift.Error>
  func getPlaceMotionDataAggregates(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.RepresentablePlaceMotionAggregates, any Swift.Error>
  func getZoneMotionDataAggregates(for zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<Self.RepresentableZoneMotionAggregates, any Swift.Error>
  func generateInvite(to place: NamiPairingFramework.PlaceID, invitee name: Swift.String, roleId: Swift.String) -> Combine.AnyPublisher<Self.RepresentableInviteLink, any Swift.Error>
  func getRestHistory(roomId: NamiPairingFramework.RoomID, from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<Self.RepresentableRestEventsResponse, any Swift.Error>
  func getRestInsights(roomId: NamiPairingFramework.RoomID, day: Foundation.Date) -> Combine.AnyPublisher<Self.RepresentableRestInsightsResponse, any Swift.Error>
}
public protocol DeviceConnectionsManagerProtocol {
  associatedtype Storage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol
  associatedtype API : NamiPairingFramework.DeviceConnectionsManagerWebAPIProtocol
  init(storage: Self.Storage, api: Self.API)
  func sendControlMessage(_ controlMessage: any NamiPairingFramework.DeviceControlMessageProtocol, for capability: NamiPairingFramework.NamiDeviceCapability, uid: NamiPairingFramework.DeviceUniversalID, in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<any NamiPairingFramework.DevicesCommandResponseProtocol, any Swift.Error>
  func deviceStateRequest(to device: NamiPairingFramework.DeviceUniversalID, connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Foundation.Data, any Swift.Error>
  func devicesStateRequest(connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Foundation.Data], any Swift.Error>
  func threadCredentialsRequest(to device: NamiPairingFramework.DeviceUniversalID, connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<any NamiPairingFramework.ThreadCredentialsMessageProtocol, any Swift.Error>
  func threadCredentialsRequest(connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[any NamiPairingFramework.ThreadCredentialsMessageProtocol], any Swift.Error>
}
public protocol DeviceConnectionsManagerWebAPIProtocol {
  associatedtype DevicesQuery : NamiPairingFramework.DevicesQueryProtocol
  associatedtype DevicesResponse : NamiPairingFramework.DevicesResponseProtocol
  associatedtype DevicesCommandResponse : NamiPairingFramework.DevicesCommandResponseProtocol
  associatedtype CloudPlaceKey : Swift.Decodable, Swift.Encodable
  func listDevices(query: Self.DevicesQuery) -> Combine.AnyPublisher<Self.DevicesResponse, any Swift.Error>
  func sendDeviceCommandRequests(in placeId: NamiPairingFramework.PlaceID, uids: [NamiPairingFramework.DeviceUniversalID], messages: [Foundation.Data]) -> Combine.AnyPublisher<Self.DevicesCommandResponse, any Swift.Error>
  func listPlaceKeys() -> Combine.AnyPublisher<[Self.CloudPlaceKey], any Swift.Error>
}
public protocol DeviceConnectionsManagerStorageProtocol {
  associatedtype DeviceConnectionsManager_PlaceKey : NamiPairingFramework.PlaceKeyProtocol
  func placeIds() -> Combine.AnyPublisher<[NamiPairingFramework.PlaceID], Swift.Never>
  func placeKeys() -> Combine.AnyPublisher<[Self.DeviceConnectionsManager_PlaceKey], Swift.Never>
  func deviceUids(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.DeviceUniversalID], Swift.Never>
  func updateDeviceState(uid: NamiPairingFramework.DeviceUniversalID, state: Foundation.Data, seqTime: Swift.UInt64) throws
  func refreshPlaceKeys() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func refreshDevices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
}
public protocol PlaceKeyProtocol : Swift.Decodable, Swift.Encodable {
  var id: Swift.String { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var valid: Foundation.DateInterval { get }
  var key: Foundation.Data { get }
}
public protocol RemoteTemplateUIConfigProtocol {
  var baseURL: Foundation.URL { get set }
  var countryCode: Swift.String { get set }
  var measurementSystem: NamiPairingFramework.NamiMeasurementSystem { get set }
  var clientId: Swift.String { get set }
  var language: Swift.String { get set }
  var appearance: NamiPairingFramework.NamiAppearance { get set }
  var topologyRoomsSupported: Swift.Bool { get set }
}
public protocol RemoteTemplatesUIControllerProtocol {
  associatedtype Storage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol, NamiPairingFramework.RemoteTemplateStateRepositoryProtocol
  associatedtype Event : NamiPairingFramework.RemoteTemplatesUIControllerEvent
  associatedtype Error : NamiPairingFramework.RemoteTemplatesUIControllerError
  associatedtype TemplatesView : SwiftUICore.View
  init(store: Self.Storage, deviceConnectionsManager: any NamiPairingFramework.DeviceConnectionsManagerProtocol)
  @_Concurrency.MainActor func present(entrypoint: some RemoteTemplateEntrypointProtocol, placeId: NamiPairingFramework.PlaceID, config: any NamiPairingFramework.RemoteTemplateUIConfigProtocol) -> Self.TemplatesView
  var eventsPublisher: Combine.PassthroughSubject<Self.Event, Self.Error> { get }
}
public protocol RemoteTemplatesUIControllerEvent {
}
public protocol RemoteTemplatesUIControllerError : Swift.Error {
}
public protocol SecureStorageProtocol {
  associatedtype SecureStorageError : Swift.Error
  static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, Self.SecureStorageError>
  static func delete(at key: Swift.String, server: Swift.String)
}
public enum I18n {
  public static let accountLinkingAuthorizeSignInRequest: Swift.String
  public static let accountLinkingDidYouMakeThisRequest: Swift.String
  public static let accountLinkingPleaseSignin: Swift.String
  public static let accountLinkingSignInConfirmedBodyMessage: Swift.String
  public static let accountLinkingSignInError: Swift.String
  public static func accountLinkingSignInRequestIpTimeBrowser(_ p1: Swift.UnsafePointer<Swift.CChar>, _ p2: Swift.UnsafePointer<Swift.CChar>, _ p3: Swift.UnsafePointer<Swift.CChar>) -> Swift.String
  public static func accountLinkingSignInRequestPlaceIpTimeBrowserAndroid(_ p1: Swift.UnsafePointer<Swift.CChar>, _ p2: Swift.UnsafePointer<Swift.CChar>, _ p3: Swift.UnsafePointer<Swift.CChar>, _ p4: Swift.UnsafePointer<Swift.CChar>) -> Swift.String
  public static let activityEventOngoing: Swift.String
  public static let activityMotion: Swift.String
  public static let activityMotionDetectedIn: Swift.String
  public static let activityNoMotion: Swift.String
  public static let activityNoPresence: Swift.String
  public static let activityPresence: Swift.String
  public static let activityPresenceDetectedIn: Swift.String
  public static let activityTitle: Swift.String
  public static let activityTotalMotionTime: Swift.String
  public static func alarmDetectedAtAndroid(_ p1: Any, _ p2: Any) -> Swift.String
  public static let alarmDisarm: Swift.String
  public static func alarmFalseAlarmCauseListTitle(_ p1: Any) -> Swift.String
  public static let alarmFalseAlarmCauseMyself: Swift.String
  public static let alarmFalseAlarmCauseOther: Swift.String
  public static let alarmFalseAlarmCauseSmallMovingObjects: Swift.String
  public static let alarmFalseAlarmReportButtonTitle: Swift.String
  public static func alarmFalseAlarmReportHint(_ p1: Any) -> Swift.String
  public static let alarmFalseAlarmSelectCauseTitle: Swift.String
  public static let alarmFalseAlarmSensitivityExplanatioAdjustSensitivityButton: Swift.String
  public static let alarmFalseAlarmSensitivityExplanatioArmSelectedZones: Swift.String
  public static let alarmFalseAlarmSensitivityExplanatioPossibleReasons: Swift.String
  public static let alarmFalseAlarmSensitivityExplanatioSensitivityLevelHint: Swift.String
  public static let alarmFalseAlarmSensitivityExplanationReduceFalseAlarmsTitle: Swift.String
  public static let alarmFalseAlarmTitle: Swift.String
  public static func alarmIntrusionDescription(_ p1: Any, _ p2: Any) -> Swift.String
  public static func alarmIntrusionDescriptionAndroid(_ p1: Any, _ p2: Any) -> Swift.String
  public static let alarmIntrusionTitle: Swift.String
  public static func alarmLiveAlarmActivitiesStopped(_ p1: Any) -> Swift.String
  public static func alarmLiveAlarmNoActivity(_ p1: Any) -> Swift.String
  public static func alarmLiveAlarmOngoingActivity(_ p1: Any) -> Swift.String
  public static let alarmLiveAlarmSecurityMonitoring: Swift.String
  public static func alarmLiveAlarmStartedAtInZone(_ p1: Any, _ p2: Any) -> Swift.String
  public static func alarmLiveAlarmStoppedActivity(_ p1: Any) -> Swift.String
  public static let alarmReasonIntrusion: Swift.String
  public static let alarmReportAlarmDisarmed: Swift.String
  public static let alarmReportAlarmTriggered: Swift.String
  public static func alarmReportDeviceClosed(_ p1: Any) -> Swift.String
  public static func alarmReportDeviceOpened(_ p1: Any) -> Swift.String
  public static let alarmReportDuration: Swift.String
  public static func alarmReportEventStartEndTime(_ p1: Any, _ p2: Any) -> Swift.String
  public static let alarmReportFalse: Swift.String
  public static func alarmReportMotionStartedIn(_ p1: Any) -> Swift.String
  public static let alarmReportSecurityLog: Swift.String
  public static func alarmReportStartedAt(_ p1: Any) -> Swift.String
  public static func alarmReportSubjectHistory(_ p1: Any) -> Swift.String
  public static let alarmReportTitle: Swift.String
  public static func alarmReportTotalActiveTime(_ p1: Any) -> Swift.String
  public static let alarmReportZonesAffected: Swift.String
  public static let appName: Swift.String
  public static let appWidgetDescriptionMedium: Swift.String
  public static let appWidgetDescriptionSmall: Swift.String
  public static let appWidgetErrorNoInternetConnection: Swift.String
  public static let appWidgetLabelMedium: Swift.String
  public static let appWidgetLabelSmall: Swift.String
  public static let appwidgetDefaultPlaceName: Swift.String
  public static let appwidgetErrorText: Swift.String
  public static let areYouWantToCancelPairingProcess: Swift.String
  public static let automationAt: Swift.String
  public static let automationBack: Swift.String
  public static let automationChangeModeTo: Swift.String
  public static let automationConflictAutomationDescription: Swift.String
  public static let automationConflictAutomationTitle: Swift.String
  public static let automationCreateAutomation: Swift.String
  public static let automationDeleteAutomation: Swift.String
  public static let automationDeleteAutomationDescription: Swift.String
  public static let automationEditAutomation: Swift.String
  public static let automationEveryDay: Swift.String
  public static let automationEveryWeekday: Swift.String
  public static let automationEveryWeekend: Swift.String
  public static let automationFor: Swift.String
  public static func automationFormatTimeZone(_ p1: Any) -> Swift.String
  public static func automationIsYourPlaceLocatedInThisTimeZone(_ p1: Any) -> Swift.String
  public static let automationModes: Swift.String
  public static let automationMsgEmptyAutomation: Swift.String
  public static let automationNewAutomation: Swift.String
  public static let automationNoAutomationAvailableYet: Swift.String
  public static let automationNoPermissionToMakeChangeDialogDescription: Swift.String
  public static let automationNoPermissionToMakeChangeDialogGotIt: Swift.String
  public static let automationNoPermissionToMakeChangeDialogTitle: Swift.String
  public static let automationNoZonesAvailable: Swift.String
  public static let automationNoZonesSelected: Swift.String
  public static let automationRepeatOn: Swift.String
  public static let automationSelectTime: Swift.String
  public static let automationSelectTimezone: Swift.String
  public static let automationSelectZone: Swift.String
  public static let automationTooltipStayModeOnlyAvailable: Swift.String
  public static func automationTooltipStayModeUnselectedZones(_ p1: Any) -> Swift.String
  public static let automationsActionCannotUndone: Swift.String
  public static let automationsAt: Swift.String
  public static let automationsAutomationCannotBeSaved: Swift.String
  public static let automationsCreateAutomation: Swift.String
  public static let automationsDateAndTimeBasedOn: Swift.String
  public static let automationsDeleteAutomation: Swift.String
  public static let automationsEditAutomation: Swift.String
  public static let automationsEveryWeekday: Swift.String
  public static let automationsEveryWeekend: Swift.String
  public static let automationsEveryday: Swift.String
  public static let automationsFor: Swift.String
  public static let automationsModes: Swift.String
  public static let automationsNewAutomation: Swift.String
  public static let automationsNoZonesAvailable: Swift.String
  public static let automationsNoZonesSelected: Swift.String
  public static let automationsRepeatOn: Swift.String
  public static let automationsSetAScheduleToActivateModesAutomatically: Swift.String
  public static let automationsYouHaveConflict: Swift.String
  public static let changeUsernameEmptyErrorMessage: Swift.String
  public static let changeUsernamePlaceholder: Swift.String
  public static let changeUsernamePromptMessage: Swift.String
  public static let chooseRoomConfirm: Swift.String
  public static let chooseRoomCreateRoom: Swift.String
  public static let chooseRoomHeader: Swift.String
  public static let chooseRoomLoadDataFailed: Swift.String
  public static let chooseRoomSelectOrCreateHeader: Swift.String
  public static let chooseZoneCreateZone: Swift.String
  public static let chooseZoneHeader: Swift.String
  public static let chooseZoneNoDevices: Swift.String
  public static func chooseZoneThreadDevicesCount(_ p1: Any) -> Swift.String
  public static func chooseZoneWifiDevicesCount(_ p1: Any) -> Swift.String
  public static let commissioningModeCheckupZoneContactIsntaller: Swift.String
  public static let commissioningModeCompanionLandingCancel: Swift.String
  public static let commissioningModeCompanionLandingContactSupport: Swift.String
  public static let commissioningModeCompanionLandingGoToPlaceButton: Swift.String
  public static let commissioningModeCompanionLandingLoadingInfo: Swift.String
  public static let commissioningModeCompanionLandingPlaceFound: Swift.String
  public static let commissioningModeConfirmPlaceConfirmButton: Swift.String
  public static let commissioningModeConfirmPlaceNamePlaceHint: Swift.String
  public static let commissioningModeConfirmPlaceNamePlacePlaceholder: Swift.String
  public static let commissioningModeLoadingScreenLoadingContent: Swift.String
  public static let commissioningModePlaceDetailsAddDevicesHint: Swift.String
  public static let commissioningModePlaceDetailsAddZone: Swift.String
  public static let commissioningModePlaceDetailsContactIsntaller: Swift.String
  public static let commissioningModePlaceDetailsCreatedAt: Swift.String
  public static let commissioningModePlaceDetailsCreatedAtAndroid: Swift.String
  public static let commissioningModePlaceDetailsExitButton: Swift.String
  public static let commissioningModePlaceDetailsUpdatedAt: Swift.String
  public static let commissioningModePlaceDetailsUpdatedAtAndroid: Swift.String
  public static let commissioningModePlaceDetailsZonesSectionTitle: Swift.String
  public static let commissioningModeSetupModeSettingsExitSetup: Swift.String
  public static let commissioningModeSetupModeSettingsPlaceSettings: Swift.String
  public static let commissioningModeSetupModeSettingsSettings: Swift.String
  public static let companionEditPlaceNameHint: Swift.String
  public static let companionExitSetup: Swift.String
  public static let companionExitSetupAndroid: Swift.String
  public static let companionHomeContactYourInstallerToSetUpYourPlace: Swift.String
  public static let companionZoneMotionSensingConnectLocalWifi: Swift.String
  public static let companionZoneMotionSensingMovementDetected: Swift.String
  public static let companionZoneMotionSensingNoMovementDetected: Swift.String
  public static let companionZones: Swift.String
  public static let confirmCancelPairing: Swift.String
  public static let confirmPlaceNameButtonConfirm: Swift.String
  public static let confirmPlaceNameHeader: Swift.String
  public static let confirmPlaceNameSubhead: Swift.String
  public static let confirmRoomNameButtonConfirm: Swift.String
  public static let confirmRoomNameHeader: Swift.String
  public static let confirmRoomNameSubhead: Swift.String
  public static let connectivityIndicatorDeviceConnected: Swift.String
  public static let connectivityIndicatorDeviceDisconnected: Swift.String
  public static func connectivityIndicatorDeviceRssi(_ p1: Swift.Int) -> Swift.String
  public static let contactSensorSetupBeforeYouContinue: Swift.String
  public static let contactSensorSetupGuideDescription1: Swift.String
  public static let contactSensorSetupGuideDescription2: Swift.String
  public static let createFirstPlaceCancel: Swift.String
  public static let createFirstPlaceCreatePlace: Swift.String
  public static let createFirstPlaceCreatePlaceSlideText: Swift.String
  public static let createFirstPlaceJoinPlace: Swift.String
  public static let createFirstPlaceJoinPlaceSlideText: Swift.String
  public static let createFirstPlaceLetsStart: Swift.String
  public static let createFirstPlaceWelcomeText: Swift.String
  public static let createPlaceSectionTitle: Swift.String
  public static let createZoneButtonConfirm: Swift.String
  public static let createZoneDescription: Swift.String
  public static let createZoneEnterNameHint: Swift.String
  public static let createZoneFirstFloor: Swift.String
  public static let createZoneHeader: Swift.String
  public static let createZoneNameTheZoneDescription: Swift.String
  public static let createZonePlaceholder: Swift.String
  public static let createZoneSecondFloorPlaceholder: Swift.String
  public static let createZoneTitle: Swift.String
  public static let dashboardAddNewPlace: Swift.String
  public static func dashboardFormatDisconnectedDeviceInMultipleZoneAndroid(_ p1: Swift.Int) -> Swift.String
  public static func dashboardFormatDisconnectedDeviceInOneZoneAndroid(_ p1: Swift.Int) -> Swift.String
  public static func dashboardFormatIssueInAPlace(_ p1: Any) -> Swift.String
  public static func dashboardFormatIssueInMultiplePlace(_ p1: Swift.Int) -> Swift.String
  public static let dashboardPlaceTileCurrentStatus: Swift.String
  public static let dashboardPlaceTileIntrusionDetected: Swift.String
  public static let dashboardPlaceTileMovementDetected: Swift.String
  public static let dashboardPlaceTileNoMovementDetected: Swift.String
  public static let dashboardPlaceTileNoSensingData: Swift.String
  public static let dashboardPlaceTileNotAvailable: Swift.String
  public static let dashboardPlaceTilePairMore: Swift.String
  public static let dashboardPlaceTilePairOneMore: Swift.String
  public static func dashboardPlaceTileSinceStartedDate(_ p1: Any) -> Swift.String
  public static func dashboardPlaceTileSinceStartedDateAndroid(_ p1: Any) -> Swift.String
  public static let dashboardPlaces: Swift.String
  public static let dashboardSensingLinkBrokenInMultipleZone: Swift.String
  public static let dashboardSensingLinkBrokenInOneZone: Swift.String
  public static let defaultNotificationChannelId: Swift.String
  public static let defaultNotificationChannelName: Swift.String
  public static let deletePlaceConfirmDeletePlace: Swift.String
  public static let deletePlaceConfirmLeavePlace: Swift.String
  public static let deletePlaceDeleteAllRelatedData: Swift.String
  public static let deletePlaceDeleteAllRelatedDataDescription: Swift.String
  public static let deletePlaceDeletePlaceAndData: Swift.String
  public static let deletePlaceDeletePlaceTitle: Swift.String
  public static let deletePlaceInviteAgain: Swift.String
  public static let deletePlaceLeavePlaceTitle: Swift.String
  public static let deletePlaceLoseAccessToAllData: Swift.String
  public static let deletePlaceLoseAccessToAllDataDescription: Swift.String
  public static let deletePlaceLoseAccessToAllDevices: Swift.String
  public static let deletePlaceLoseAccessToAllDevicesDescription: Swift.String
  public static let deletePlaceRemoveAllUsers: Swift.String
  public static let deletePlaceRemoveAllUsersDescription: Swift.String
  public static let deletePlaceResetAllDevices: Swift.String
  public static let deletePlaceResetAllDevicesDescription: Swift.String
  public static let deletePlaceThisActionIsIrreversible: Swift.String
  public static let deletePlaceThisWillAlso: Swift.String
  public static let deviceCategoryAccessories: Swift.String
  public static let deviceCategoryActivitySensors: Swift.String
  public static let deviceCategorySensing: Swift.String
  public static let deviceDetailDoorSensorLowBattery: Swift.String
  public static let deviceDetailDoorSensorLowBatteryWarning: Swift.String
  public static let deviceDetailDoorSensorLowBatteryWarningLearnHow: Swift.String
  public static let deviceDetailsConnected: Swift.String
  public static func deviceDetailsLoadDataFailed(_ p1: Any) -> Swift.String
  public static let deviceEditDeviceNamePlaceholder: Swift.String
  public static let deviceEditTitle: Swift.String
  public static let deviceEnginesAerialMotionV1: Swift.String
  public static let deviceEnginesMotion: Swift.String
  public static let deviceEnginesSecurity: Swift.String
  public static let deviceEnginesUnknown: Swift.String
  public static let deviceInfoBbsid: Swift.String
  public static let deviceInfoBorderRouter: Swift.String
  public static let deviceInfoCloudConnection: Swift.String
  public static let deviceInfoDeviceConnected: Swift.String
  public static let deviceInfoDeviceDisconnected: Swift.String
  public static let deviceInfoDeviceModel: Swift.String
  public static let deviceInfoDeviceModelId: Swift.String
  public static let deviceInfoFirmvareVesrion: Swift.String
  public static let deviceInfoLocalConnection: Swift.String
  public static let deviceInfoMacAddress: Swift.String
  public static let deviceInfoNonBorderRouter: Swift.String
  public static let deviceInfoPairedAt: Swift.String
  public static let deviceInfoPanid: Swift.String
  public static let deviceInfoRole: Swift.String
  public static let deviceInfoRssi: Swift.String
  public static let deviceInfoTechnicalInformation: Swift.String
  public static let deviceInfoThreadNetwork: Swift.String
  public static let deviceInfoTitle: Swift.String
  public static let deviceInfoWidarPosition: Swift.String
  public static let deviceInfoWidarPositionMispositioned: Swift.String
  public static let deviceInfoWidarPositionNotAvailable: Swift.String
  public static let deviceInfoWidarPositionOptimal: Swift.String
  public static let deviceInfoWidarPositionStatus: Swift.String
  public static let deviceInfoWidarPositioningInformation: Swift.String
  public static let deviceInfoWidarSensing: Swift.String
  public static let deviceInfoWifiNetwork: Swift.String
  public static let deviceInfoZone: Swift.String
  public static let deviceInstructionsBulletPoint1: Swift.String
  public static let deviceInstructionsBulletPoint2: Swift.String
  public static let deviceInstructionsBulletPoint3: Swift.String
  public static let deviceInstructionsBulletPoint4: Swift.String
  public static let deviceInstructionsConfirmButton: Swift.String
  public static let deviceInstructionsDescription: Swift.String
  public static let deviceInstructionsTitle: Swift.String
  public static let deviceIsDisconnectedToInternet: Swift.String
  public static let deviceOverviewConnection: Swift.String
  public static let deviceOverviewConnectionCloud: Swift.String
  public static let deviceOverviewConnectionDirect: Swift.String
  public static let deviceOverviewConnectionLost: Swift.String
  public static let deviceOverviewDeletionDeleteConfirm: Swift.String
  public static let deviceOverviewRelayExplanation: Swift.String
  public static let deviceOverviewRelayIsOff: Swift.String
  public static let deviceOverviewRelayIsOn: Swift.String
  public static let deviceOverviewStatus: Swift.String
  public static let deviceOverviewWifiDisconnected: Swift.String
  public static let deviceOverviewWifiPoor: Swift.String
  public static let devicePlacementAvoidPlacingDeviceNearMetalic: Swift.String
  public static let devicePlacementConfirmButton: Swift.String
  public static let devicePlacementDoNotConnectToPowerYet: Swift.String
  public static let devicePlacementDoNotInstallOrConnectToPowerYet: Swift.String
  public static let devicePlacementDoNotMountDoorSensorYet: Swift.String
  public static let devicePlacementDoNotMountKeypadYet: Swift.String
  public static let devicePlacementDoNotMountMotionSensorYet: Swift.String
  public static let devicePlacementDoorSensorGuideContent1: Swift.String
  public static func devicePlacementDoorSensorGuideContent2Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementDoorSensorGuideContent2Metric(_ p1: Any) -> Swift.String
  public static let devicePlacementFirstBssGuide1Imperial: Swift.String
  public static let devicePlacementFirstBssGuide1Metric: Swift.String
  public static let devicePlacementFirstBssSecondDeviceGuide2Imperial: Swift.String
  public static let devicePlacementFirstBssSecondDeviceGuide2Metric: Swift.String
  public static let devicePlacementFirstBssThirdDeviceGuide3Imperial: Swift.String
  public static let devicePlacementFirstBssThirdDeviceGuide3Metric: Swift.String
  public static let devicePlacementFirstDeviceSetup: Swift.String
  public static let devicePlacementFirstDeviceSetupStep1: Swift.String
  public static let devicePlacementFirstDeviceSetupStep2Imperial: Swift.String
  public static let devicePlacementFirstDeviceSetupStep2Metric: Swift.String
  public static let devicePlacementFirstHmsSecondDeviceGuide2Imperial: Swift.String
  public static let devicePlacementFirstHmsSecondDeviceGuide2Metric: Swift.String
  public static let devicePlacementFirstHmsThirdDeviceGuide3Imperial: Swift.String
  public static let devicePlacementFirstHmsThirdDeviceGuide3Metric: Swift.String
  public static let devicePlacementFirstSensePlugGuide1Imperial: Swift.String
  public static let devicePlacementFirstSensePlugGuide1Metric: Swift.String
  public static let devicePlacementFirstSensePlugGuide2: Swift.String
  public static let devicePlacementFirstWifiSensorGuide1Imperial: Swift.String
  public static let devicePlacementFirstWifiSensorGuide1Metric: Swift.String
  public static let devicePlacementFirstWifiSensorGuide2: Swift.String
  public static func devicePlacementFirstWifiSensorGuide3(_ p1: Any) -> Swift.String
  public static let devicePlacementKeypadGuideContent1: Swift.String
  public static let devicePlacementMotionSensorGuideContent1: Swift.String
  public static let devicePlacementNonFirstBssHasBrGuide2Imperial: Swift.String
  public static let devicePlacementNonFirstBssHasBrGuide2Metric: Swift.String
  public static let devicePlacementNonFirstBssNoBrGuide1Imperial: Swift.String
  public static let devicePlacementNonFirstBssNoBrGuide1Metric: Swift.String
  public static func devicePlacementNonFirstHssThirdDeviceNoDeviceGuide3Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstHssThirdDeviceNoDeviceGuide3Metric(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstSensePlugGuide2Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstSensePlugGuide2Metric(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstWidarHasBrGuide1Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstWidarHasBrGuide1Metric(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstWidarSensorGuide2Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstWidarSensorGuide2Metric(_ p1: Any) -> Swift.String
  public static let devicePlacementNonFirstWifiSensorGuide1Imperial: Swift.String
  public static let devicePlacementNonFirstWifiSensorGuide1Metric: Swift.String
  public static func devicePlacementNonFirstWifiSensorGuide2Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstWifiSensorGuide2Metric(_ p1: Any) -> Swift.String
  public static let devicePlacementNoticeNotice: Swift.String
  public static func devicePlacementNoticeNoticeKnownZone(_ p1: Any) -> Swift.String
  public static let devicePlacementPlaceDeviceOnSameFloor: Swift.String
  public static let devicePlacementRemainingDevicesSetup: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep1Imprerial: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep1Metric: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep2Imperial: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep2Metric: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep3: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep4: Swift.String
  public static let devicePlacementSecureAnyEntryOrRoomDoor: Swift.String
  public static let devicePlacementSensorDialogDescription: Swift.String
  public static let devicePlacementSensorDialogTitle: Swift.String
  public static let devicePlacementThreadBorderRouterDialogDescription: Swift.String
  public static let devicePlacementThreadBorderRouterDialogTitle: Swift.String
  public static let devicePlacementWhereToPlaceDevice: Swift.String
  public static let deviceSettingsCustomizeDeviceDescription: Swift.String
  public static let deviceSettingsCustomizeDeviceTitle: Swift.String
  public static let deviceSettingsDeviceInfoTitle: Swift.String
  public static let deviceSettingsErrorDeviceNotFound: Swift.String
  public static let deviceSettingsRemoveDevice: Swift.String
  public static func deviceSettingsRemoveDeviceName(_ p1: Any) -> Swift.String
  public static let deviceSettingsTechnicalInformationSubtitleThread: Swift.String
  public static let deviceSettingsTechnicalInformationSubtitleThreadEnd: Swift.String
  public static let deviceSettingsTechnicalInformationSubtitleWifi: Swift.String
  public static let deviceSettingsTitle: Swift.String
  public static let deviceSetupAccessories: Swift.String
  public static let deviceSetupActivitySensors: Swift.String
  public static let deviceSetupAlarmPod: Swift.String
  public static let deviceSetupContactSensor: Swift.String
  public static let deviceSetupMotionSensor: Swift.String
  public static let deviceSetupOthers: Swift.String
  public static let deviceSetupSecurityPod: Swift.String
  public static let deviceSetupSensePlug: Swift.String
  public static let deviceSetupWidarSensor: Swift.String
  public static let deviceSetupWifiSensor: Swift.String
  public static let deviceTypeSelectionAccessoriesWarning: Swift.String
  public static let deviceTypeSelectionAccessoriesWarningLearnMore: Swift.String
  public static let deviceWidarMispositionedWarningMessage: Swift.String
  public static let devicesAddNewDevice: Swift.String
  public static let devicesAddNewRoom: Swift.String
  public static let devicesAddNewZone: Swift.String
  public static let doorSensorBatteryLevel: Swift.String
  public static func doorSensorBatteryPercentageAndroid(_ p1: Swift.Int) -> Swift.String
  public static let doorSensorClosed: Swift.String
  public static let doorSensorOpen: Swift.String
  public static let editDeviceEditDeviceNameHint: Swift.String
  public static let editDeviceEditDeviceTitle: Swift.String
  public static let editIconHeader: Swift.String
  public static let editPlaceCategory: Swift.String
  public static let editPlaceDeletePlaceGuideDescription2Android: Swift.String
  public static let editPlaceDeletePlaceGuideDescription4Android: Swift.String
  public static let editPlaceDeletePlaceGuideDescription6Android: Swift.String
  public static let editPlaceDeletePlaceGuideDescriptionAndroid: Swift.String
  public static let editPlaceDeletionDeleteButton: Swift.String
  public static let editPlaceEditPlace: Swift.String
  public static let editPlaceEditPlaceDescription: Swift.String
  public static let editPlaceEnterName: Swift.String
  public static let editPlaceIcon: Swift.String
  public static let editPlaceLeavePlaceGuideDescription4Android: Swift.String
  public static let editPlaceLeavePlaceGuideTitle: Swift.String
  public static let editPlaceSensitivity: Swift.String
  public static let editPlaceZeroDeviceAndroid: Swift.String
  public static func editProfileLoadFailed(_ p1: Any) -> Swift.String
  public static func editProfileSaveFailed(_ p1: Any) -> Swift.String
  public static let editRoomCategory: Swift.String
  public static let editRoomDeleteButton: Swift.String
  public static func editRoomDeleteFailed(_ p1: Any) -> Swift.String
  public static func editRoomDeleteZoneFailed(_ p1: Any) -> Swift.String
  public static let editRoomDeletionDeleteRoomAlertMessage: Swift.String
  public static let editRoomDeletionDeleteZoneAlertMessage: Swift.String
  public static let editRoomEditRoom: Swift.String
  public static let editRoomEnterName: Swift.String
  public static let editRoomIcon: Swift.String
  public static func editRoomLoadFailed(_ p1: Any) -> Swift.String
  public static func editRoomSaveFailed(_ p1: Any) -> Swift.String
  public static let editUserProfileChooseImageColor: Swift.String
  public static let editUserProfileChooseProfileImage: Swift.String
  public static let editUserProfileEmptyErrorMessage: Swift.String
  public static let editUserProfilePlaceholder: Swift.String
  public static let editUserProfileProfileName: Swift.String
  public static let editUserProfileTitle: Swift.String
  public static let editZoneDeleteAlertDescription: Swift.String
  public static let editZoneDeleteAlertTitle: Swift.String
  public static let editZoneDeleteButton: Swift.String
  public static let editZoneEditZone: Swift.String
  public static let editZoneEnterName: Swift.String
  public static let editZoneFailToCreateZone: Swift.String
  public static let editZoneFailToDeleteZone: Swift.String
  public static let editZoneFailToEditZone: Swift.String
  public static let editZoneFailToGetZoneInformation: Swift.String
  public static let editZoneTitle: Swift.String
  public static let editZoneZoneNameAlreadyInUse: Swift.String
  public static let engineSettingsEngineSettingsDescription: Swift.String
  public static let engineSettingsMotionEngine: Swift.String
  public static let engineSettingsMotionEngineDescription: Swift.String
  public static let engineSettingsSecurityEngine: Swift.String
  public static let engineSettingsSecurityEngineDescription: Swift.String
  public static let engineSettingsTitle: Swift.String
  public static let errorInsufficientPermissionActionCanNotBeCompleted: Swift.String
  public static let errorNoInternetConnection: Swift.String
  public static let errorsAuthenticationLoginRequired: Swift.String
  public static let errorsAuthenticationTitle: Swift.String
  public static let errorsAuthenticationTokenExpired: Swift.String
  public static let errorsJoinThreadNetworkFailMessage: Swift.String
  public static let errorsJoinThreadNetworkFailTitle: Swift.String
  public static let errorsLinkingErrorResponseParseError: Swift.String
  public static let errorsMoveDeviceErrorNoDeviceSelected: Swift.String
  public static let errorsMoveDeviceErrorTitle: Swift.String
  public static func errorsNetworkErrorConflict(_ p1: Any) -> Swift.String
  public static func errorsNetworkErrorConnectionError(_ p1: Any) -> Swift.String
  public static let errorsNetworkErrorForbidden: Swift.String
  public static func errorsNetworkErrorInvalidParameters(_ p1: Any) -> Swift.String
  public static func errorsNetworkErrorNotFound(_ p1: Any) -> Swift.String
  public static func errorsNetworkErrorServerError(_ p1: Any) -> Swift.String
  public static let errorsNetworkErrorTitle: Swift.String
  public static func errorsNetworkErrorUnauthorized(_ p1: Any) -> Swift.String
  public static func errorsNetworkErrorUnknown(_ p1: Any) -> Swift.String
  public static func errorsPairingBleDisconnectedDescription(_ p1: Any) -> Swift.String
  public static let errorsPairingConnectionTimeOutDescription: Swift.String
  public static let errorsPairingDeviceNotFoundDescription: Swift.String
  public static let errorsPairingDeviceNotFoundTitle: Swift.String
  public static let errorsPairingErrorDeviceCloudChallengeError: Swift.String
  public static let errorsPairingErrorDeviceSecureSessionError: Swift.String
  public static let errorsPairingErrorDeviceThreadJoinError: Swift.String
  public static let errorsPairingErrorDeviceThreadScanError: Swift.String
  public static let errorsPairingErrorDeviceTitle: Swift.String
  public static let errorsPairingErrorDeviceUnknownUnrecognized: Swift.String
  public static let errorsPairingErrorDeviceWifiJoinError: Swift.String
  public static let errorsPairingErrorDeviceWifiJoinIpError: Swift.String
  public static let errorsPairingErrorDeviceWifiJoinPasswordError: Swift.String
  public static let errorsPairingErrorDeviceWifiScanError: Swift.String
  public static let errorsPairingIncorrectWifiPasswordDescription: Swift.String
  public static let errorsPairingIncorrectWifiPasswordTitle: Swift.String
  public static let errorsPairingMachineDeserializationError: Swift.String
  public static let errorsPairingMachineEncryptionError: Swift.String
  public static let errorsPairingMachineSeanceError: Swift.String
  public static let errorsPairingMachineSerializationError: Swift.String
  public static let errorsPairingMachineTitle: Swift.String
  public static let errorsPairingMachineUnexpectedMessage: Swift.String
  public static let errorsPairingMachineUnexpectedState: Swift.String
  public static let errorsPairingThreadSetupErrorMixedEnvironment: Swift.String
  public static let errorsPairingThreadSetupErrorThreadNetworkNotFound: Swift.String
  public static let errorsPairingThreadSetupErrorThreadOperationalDatasetMissing: Swift.String
  public static let errorsPairingTimedOutConnectWifi: Swift.String
  public static let externalSigninCheckIfUsersRequest: Swift.String
  public static let externalSigninConfirmRequest: Swift.String
  public static let externalSigninConfirmedTitle: Swift.String
  public static let externalSigninContinueOauth: Swift.String
  public static func externalSigninFromLocation(_ p1: Any) -> Swift.String
  public static func externalSigninOnOs(_ p1: Any) -> Swift.String
  public static let externalSigninRejectRequest: Swift.String
  public static let externalSigninRequestCodeCodeScreenTitle: Swift.String
  public static let externalSigninRequestCodeGrantAccess: Swift.String
  public static let externalSigninRequestCodeInstructions: Swift.String
  public static let externalSigninRequestCodePasteboardAccessExplained: Swift.String
  public static let externalSigninRequestedTitle: Swift.String
  public static func externalSigninSigninRequestPeekDescription(_ p1: Any, _ p2: Any, _ p3: Any, _ p4: Any) -> Swift.String
  public static let externalSigninSuccessMessage: Swift.String
  public static func externalSigninWithBrowser(_ p1: Any) -> Swift.String
  public static let faqTitle: Swift.String
  public static let fcmMessageTitle: Swift.String
  public static let generalAnd: Swift.String
  public static let generalAt: Swift.String
  public static let generalCamera: Swift.String
  public static let generalCancel: Swift.String
  public static let generalConnectionLost: Swift.String
  public static let generalConnectionLostExplanation: Swift.String
  public static let generalDelete: Swift.String
  public static let generalDone: Swift.String
  public static let generalError: Swift.String
  public static let generalErrorDescription: Swift.String
  public static let generalIntrusionTriggered: Swift.String
  public static let generalLoading: Swift.String
  public static let generalMore: Swift.String
  public static let generalMove: Swift.String
  public static let generalNext: Swift.String
  public static let generalNo: Swift.String
  public static let generalNotification: Swift.String
  public static let generalOk: Swift.String
  public static let generalSave: Swift.String
  public static let generalUnavailable: Swift.String
  public static let generalUndefined: Swift.String
  public static let generalYes: Swift.String
  public static func hintIssueAlarmIssues(_ p1: Any) -> Swift.String
  public static func hintIssuePluralSystemIssues(_ p1: Any) -> Swift.String
  public static func hintIssueSingularSystemIssue(_ p1: Any) -> Swift.String
  public static let homepageEmptyPlaceCreatePlace: Swift.String
  public static func homepageEmptyPlaceWelcome(_ p1: Any) -> Swift.String
  public static let homepageEmptyPlaceWelcomeDescription: Swift.String
  public static let installationGuideCompleteInstallation: Swift.String
  public static let installationGuideInstallContactSensor: Swift.String
  public static let installationGuideItems1: Swift.String
  public static let installationGuideItems2: Swift.String
  public static let installationGuideItems3Imperial: Swift.String
  public static let installationGuideItems3Metric: Swift.String
  public static let installationGuideItems4: Swift.String
  public static let installationGuideKeypadItem2: Swift.String
  public static func installationGuideTitle(_ p1: Any) -> Swift.String
  public static let internetConnection: Swift.String
  public static func intrusionBannerIntrusionDetectedAt(_ p1: Any) -> Swift.String
  public static let intrusionEventReportIntrusionHistory: Swift.String
  public static let intrusionHistoryErrorDataNotFound: Swift.String
  public static let intrusionHistoryHumanMotion: Swift.String
  public static let intrusionHistoryNoMotion: Swift.String
  public static func intrusionHistoryTimestamp(_ p1: Any) -> Swift.String
  public static let intrusionHistoryTitle: Swift.String
  public static let intrusionLiveDisarmSecuritySystem: Swift.String
  public static let intrusionLiveDisarmSecuritySystemDescription: Swift.String
  public static func intrusionLiveReportByDoorSensor(_ p1: Any, _ p2: Any) -> Swift.String
  public static let intrusionLiveReportDoorClosed: Swift.String
  public static let intrusionLiveReportDoorOpened: Swift.String
  public static let intrusionLiveReportMotion: Swift.String
  public static let intrusionLiveViewNoActivitySinceIntrusionBegan: Swift.String
  public static let invitationDetailAcceptButton: Swift.String
  public static let invitationDetailAgreementDetails: Swift.String
  public static let invitationDetailCancelButton: Swift.String
  public static let invitationDetailDeclineButton: Swift.String
  public static func invitationDetailHello(_ p1: Any) -> Swift.String
  public static func invitationDetailHelloAndroid(_ p1: Any) -> Swift.String
  public static let invitationDetailInviteFound: Swift.String
  public static let invitationDetailInviteNotFound: Swift.String
  public static func invitationDetailQuestion(_ p1: Any) -> Swift.String
  public static func invitationDetailQuestionAndroid(_ p1: Any) -> Swift.String
  public static let invitationDetailRetrievingInviteDetails: Swift.String
  public static let invitationDetailRole: Swift.String
  public static let invitationDetailsRevokeRevokeAlertMessage: Swift.String
  public static let inviteDetailsAskRevokeButton: Swift.String
  public static let inviteDetailsAskShareButton: Swift.String
  public static let inviteDetailsConfirmRevokeButton: Swift.String
  public static func inviteDetailsInviteExpirationText(_ p1: Any) -> Swift.String
  public static func inviteDetailsInviteExpirationTextAndroid(_ p1: Any) -> Swift.String
  public static let inviteDetailsInviteExpired: Swift.String
  public static func inviteDetailsInviteExpiresInText(_ p1: Any) -> Swift.String
  public static func inviteDetailsInviteTitle(_ p1: Any) -> Swift.String
  public static func inviteDetailsInviteTitleAndroid(_ p1: Any) -> Swift.String
  public static func inviteDetailsRevokeAlertMessage(_ p1: Any) -> Swift.String
  public static let inviteDetailsRevokeAlertTitle: Swift.String
  public static func inviteDetailsRevokeInvitationTitle(_ p1: Any) -> Swift.String
  public static let joinPlaceCameraPermissionGuide: Swift.String
  public static let joinPlaceInvalidInvite: Swift.String
  public static let joinPlaceInvalidQrCode: Swift.String
  public static let joinPlaceInviteFound: Swift.String
  public static let joinPlaceRoleGuide: Swift.String
  public static let joinPlaceRoleGuideAdmin: Swift.String
  public static let joinPlaceRoleUserGuide: Swift.String
  public static let joinPlaceScanAgain: Swift.String
  public static let joinPlaceScanInviteQr: Swift.String
  public static let keypadSetupGuideDescription2: Swift.String
  public static let keypadSetupGuideDescription3: Swift.String
  public static let kitExplanationFirstKitDesignedToHelpSecureYourPlace: Swift.String
  public static let kitExplanationFirstKitPlaceDevicesOnFirstFloor: Swift.String
  public static let kitExplanationNonFirstKitBssProvidesAdditionalSecurity: Swift.String
  public static let kitExplanationNonFirstKitHmsMonitorAdditionalAreas: Swift.String
  public static func kitTrackerPluralDeviceLeft(_ p1: Swift.Int) -> Swift.String
  public static func kitTrackerPluralDevicesAdded(_ p1: Swift.Int) -> Swift.String
  public static let letsAddDeviceDismissScreen: Swift.String
  public static let lostAccessPopupMessageMultiplePlaces: Swift.String
  public static let lostAccessPopupMessageSinglePlace: Swift.String
  public static func lostAccessPopupTitle(_ p1: Any) -> Swift.String
  public static let manageDevicesEmptyPlace: Swift.String
  public static let memberDetailsLeavePlace: Swift.String
  public static let memberDetailsRemoveMember: Swift.String
  public static func memberDetailsRemovePeopleMessage(_ p1: Any, _ p2: Any) -> Swift.String
  public static let motionHistoryActiveTime: Swift.String
  public static let motionHistoryDeviceIssue: Swift.String
  public static let motionHistoryDuration: Swift.String
  public static func motionHistoryFormatDaysAndroid(_ p1: Swift.Int) -> Swift.String
  public static func motionHistoryFormatHour(_ p1: Swift.Int) -> Swift.String
  public static func motionHistoryFormatHoursAndroid(_ p1: Swift.Int) -> Swift.String
  public static func motionHistoryFormatMinute(_ p1: Swift.Int) -> Swift.String
  public static func motionHistoryFormatSecond(_ p1: Swift.Int) -> Swift.String
  public static let motionHistoryIntensity: Swift.String
  public static let motionHistoryMonitorWasDegradedDueToDeviceIssue: Swift.String
  public static let motionHistoryMonitorWasDegradedInZonesWithDeviceIssue: Swift.String
  public static let motionHistoryMonitorWasDisabledDueToDeviceIssue: Swift.String
  public static let motionHistoryMonitorWasDisabledInZonesWithDeviceIssue: Swift.String
  public static let motionHistoryMotion: Swift.String
  public static let motionHistoryMotionToday: Swift.String
  public static let motionHistoryNoData: Swift.String
  public static let motionHistoryNotAvailable: Swift.String
  public static let motionHistorySensingDataNotAvailable: Swift.String
  public static let motionHistoryTileHistory: Swift.String
  public static let motionHistoryTileToday: Swift.String
  public static let motionHistoryTileTotalActiveTime: Swift.String
  public static let motionHistoryToday: Swift.String
  public static let motionNowConnectToWifi: Swift.String
  public static let motionNowConnectToWifiAsZone: Swift.String
  public static let motionNowConnectToWifiYourDeviceUsing: Swift.String
  public static let motionNowExplanationDescription1: Swift.String
  public static let motionNowExplanationDescription2: Swift.String
  public static let motionNowExplanationGotIt: Swift.String
  public static let motionNowExplanationLearnMore: Swift.String
  public static let motionNowExplanationSubTitle: Swift.String
  public static func motionNowFormatActiveZonesAndroid(_ p1: Swift.Int) -> Swift.String
  public static let motionNowGoToWifiSettings: Swift.String
  public static let motionNowHowPlaceGraphWorks: Swift.String
  public static let motionNowHowPlaceGraphWorksDescription: Swift.String
  public static let motionNowIntensity: Swift.String
  public static let motionNowMax: Swift.String
  public static let motionNowMin: Swift.String
  public static let motionNowMotionDetectedIn: Swift.String
  public static let motionNowNoSensingData: Swift.String
  public static let motionNowNow: Swift.String
  public static let motionNowThirtySecsAgo: Swift.String
  public static let motionNowTileConnectToWifi: Swift.String
  public static let motionNowTileMore: Swift.String
  public static let motionNowTileMovementDetected: Swift.String
  public static let motionNowTileNoMovementDetected: Swift.String
  public static let motionNowTileNoSensingData: Swift.String
  public static func motionNowTileNumberOfActiveZones(_ p1: Any) -> Swift.String
  public static let motionNowTileToViewMotionNow: Swift.String
  public static let motionNowTitle: Swift.String
  public static let motionSensorCoverageDoNotMountDeviceYet: Swift.String
  public static let motionSensorCoverageGuideTitle: Swift.String
  public static let motionSensorInstallationGuide1: Swift.String
  public static let motionSensorInstallationGuide2: Swift.String
  public static let motionSensorInstallationGuide3: Swift.String
  public static let motionSensorInstallationPreGuide1Imperial: Swift.String
  public static let motionSensorInstallationPreGuide1Metric: Swift.String
  public static let motionSensorInstallationPreGuide2Imperial: Swift.String
  public static let motionSensorInstallationPreGuide2Metric: Swift.String
  public static let motionSensorInstallationPreGuide3: Swift.String
  public static let motionSensorPreGuideDescription1: Swift.String
  public static let motionSensorPreGuideDescription2: Swift.String
  public static let motionSensorPreGuideDescription3: Swift.String
  public static let motionSensorPreGuideTitle1: Swift.String
  public static let motionSensorPreGuideTitle2: Swift.String
  public static let motionSensorPreGuideTitle3: Swift.String
  public static let motionSensorPreGuideTitle4: Swift.String
  public static let msgSessionExpired: Swift.String
  public static func muliplePlacesIntrusionInManyPlaces(_ p1: Swift.Int) -> Swift.String
  public static func muliplePlacesIntrusionInOnePlace(_ p1: Any) -> Swift.String
  public static let newInviteGenerateInviteButton: Swift.String
  public static let newInviteInviteAdminDescription: Swift.String
  public static let newInviteInviteDescription: Swift.String
  public static let newInviteInviteTitle: Swift.String
  public static let newInviteInviteUserDescription: Swift.String
  public static let newInviteInviteeNamePlaceholder: Swift.String
  public static let newInviteInviteeNameTitle: Swift.String
  public static let notificationGoToSettings: Swift.String
  public static func notificationMissingPermission(_ p1: Any) -> Swift.String
  public static func notificationMissingPermissionDesc(_ p1: Any, _ p2: Any) -> Swift.String
  public static let notificationPermissionGuide: Swift.String
  public static let pairDeviceGoToSettings: Swift.String
  public static func pairDeviceMissingPermission(_ p1: Any) -> Swift.String
  public static func pairDeviceMissingPermissionDesc(_ p1: Any, _ p2: Any) -> Swift.String
  public static let pairingAskToConnectConnectToWifi: Swift.String
  public static let pairingAskToConnectFirstThreadDeviceDescription1: Swift.String
  public static let pairingAskToConnectFirstThreadDeviceDescription2: Swift.String
  public static let pairingAskToConnectFirstThreadDeviceDescription3: Swift.String
  public static func pairingAskToConnectFirstWifiDeviceDescription1(_ p1: Any) -> Swift.String
  public static let pairingAskToConnectFirstWifiDeviceDescription2: Swift.String
  public static let pairingAskToConnectNonFirstThreadDeviceDescription1: Swift.String
  public static let pairingAskToConnectNonFirstThreadDeviceDescription2: Swift.String
  public static func pairingAskToConnectNonFirstThreadDeviceDescription3(_ p1: Any) -> Swift.String
  public static func pairingAskToConnectNonFirstWifiDeviceDescription1(_ p1: Any) -> Swift.String
  public static let pairingAskToConnectRemainingThreadDevice: Swift.String
  public static let pairingAskToConnectWifiDeviceImperialDistanceDescription: Swift.String
  public static let pairingAskToConnectWifiDeviceMetricDistanceDescription: Swift.String
  public static let pairingBluetoothDeviceFoundExplainedReadyToPair: Swift.String
  public static let pairingBluetoothDeviceFoundExplainedReadyToPairContactSensor: Swift.String
  public static let pairingBluetoothDeviceFoundHeader1: Swift.String
  public static let pairingBluetoothDeviceFoundHeader2: Swift.String
  public static let pairingBluetoothDeviceFoundHeaderConnectToPower: Swift.String
  public static let pairingBluetoothDeviceFoundNameAlreadyInUse: Swift.String
  public static let pairingBluetoothDeviceFoundNameDeviceExplained: Swift.String
  public static func pairingBluetoothDeviceFoundNameDeviceHeader(_ p1: Any) -> Swift.String
  public static let pairingBluetoothDeviceFoundNameYourDevice: Swift.String
  public static let pairingBluetoothDeviceFoundNextButton: Swift.String
  public static let pairingCancel: Swift.String
  public static let pairingConfirmCancelPairingDescription: Swift.String
  public static let pairingConfirmCancelPairingTitle: Swift.String
  public static func pairingConnectSuccessDeviceHasBeenSetupInZone(_ p1: Any, _ p2: Any) -> Swift.String
  public static func pairingConnectSuccessDeviceHasBeenSetupInZoneOptimizePosition(_ p1: Any, _ p2: Any) -> Swift.String
  public static func pairingConnectSuccessDeviceHasBeenSetupInZoneOptimizePositionIos(_ p1: Any, _ p2: Any) -> Swift.String
  public static let pairingConnectSuccessSetupAnotherDevice: Swift.String
  public static func pairingConnectWifiInputPassword(_ p1: Any) -> Swift.String
  public static let pairingConnectWifiNoWiFiNetworksFound: Swift.String
  public static let pairingConnectWifiSetUpAsBorderRouter: Swift.String
  public static let pairingConnectWifiSettingUpThisDevice: Swift.String
  public static let pairingDeviceSetupNavigagtionTitle: Swift.String
  public static let pairingDeviceSetupNavigationTitle: Swift.String
  public static let pairingDone: Swift.String
  public static let pairingEnableBluetoothInSettingsBluetoothDisabled: Swift.String
  public static let pairingEnableBluetoothInSettingsButtonSettings: Swift.String
  public static let pairingEnableBluetoothInSettingsHeader: Swift.String
  public static let pairingEnterWifiPasswordButtonReadyToConnect: Swift.String
  public static func pairingEnterWifiPasswordEnterPassword(_ p1: Any) -> Swift.String
  public static func pairingEnterWifiPasswordEnterPasswordIos(_ p1: Any) -> Swift.String
  public static func pairingEnterWifiPasswordHeader(_ p1: Any) -> Swift.String
  public static let pairingEnterWifiPasswordPasswordEntryFieldHint: Swift.String
  public static let pairingEnterWifiPasswordPasswordPlaceholder: Swift.String
  public static let pairingErrorAllBorderRouterOffline: Swift.String
  public static func pairingErrorAllBorderRouterOfflineDescription(_ p1: Any) -> Swift.String
  public static func pairingErrorAllBorderRouterOfflineDeviceInZone(_ p1: Any, _ p2: Any) -> Swift.String
  public static let pairingErrorMobilePhoneIsNotConnectedToWifi: Swift.String
  public static let pairingErrorMobilePhoneIsNotConnectedToWifiDescription: Swift.String
  public static let pairingErrorNoThreadBorderRouterInPlace: Swift.String
  public static let pairingErrorNoThreadBorderRouterInPlaceDescription: Swift.String
  public static let pairingErrorsActionIgnore: Swift.String
  public static let pairingErrorsActionRestart: Swift.String
  public static let pairingErrorsActionRestartSetup: Swift.String
  public static let pairingErrorsActionScanDeviceAgain: Swift.String
  public static let pairingErrorsActionTryAgain: Swift.String
  public static let pairingErrorsBleDisconnectedTitle: Swift.String
  public static func pairingErrorsContactSensorSetupErrorNoThreadNetworksFoundDescription1(_ p1: Any) -> Swift.String
  public static let pairingErrorsContactSensorSetupErrorNoThreadNetworksFoundDescription2: Swift.String
  public static let pairingErrorsContactSensorSetupErrorUnableJoinThreadNetworksDescription1: Swift.String
  public static func pairingErrorsContactSensorSetupErrorUnableJoinThreadNetworksDescription2(_ p1: Any) -> Swift.String
  public static let pairingErrorsDeviceSetupErrorDeviceMismatchDescription: Swift.String
  public static let pairingErrorsErrorOccurredTitle: Swift.String
  public static let pairingErrorsFailedToJoinWifiTitle: Swift.String
  public static let pairingErrorsNeedHelp: Swift.String
  public static let pairingErrorsThreadSetupErrorBorderRouterOffline: Swift.String
  public static func pairingErrorsThreadSetupErrorBorderRouterOfflineDescriptionAndroid(_ p1: Any, _ p2: Any) -> Swift.String
  public static let pairingErrorsThreadSetupErrorDeviceMismatchDescription: Swift.String
  public static let pairingErrorsThreadSetupErrorDeviceMismatchTitle: Swift.String
  public static let pairingErrorsThreadSetupErrorMissingThreadCredentials: Swift.String
  public static func pairingErrorsThreadSetupErrorNoThreadNetworksFoundDescription(_ p1: Any) -> Swift.String
  public static let pairingErrorsThreadSetupErrorNoThreadNetworksFoundTitle: Swift.String
  public static let pairingErrorsTimeoutDescription: Swift.String
  public static let pairingErrorsTimeoutTitle: Swift.String
  public static let pairingErrorsUnexpectedDescription: Swift.String
  public static let pairingErrorsUnexpectedTitle: Swift.String
  public static let pairingExit: Swift.String
  public static let pairingExitDeviceSetupDescription: Swift.String
  public static let pairingExitDeviceSetupTitle: Swift.String
  public static let pairingExitSetup: Swift.String
  public static let pairingFinishingSetupGameOfPong: Swift.String
  public static let pairingFinishingSetupHeader: Swift.String
  public static let pairingListWifiNetworksApOutOfReach: Swift.String
  public static let pairingListWifiNetworksAvailableNetworks: Swift.String
  public static let pairingListWifiNetworksButtonOtherNetwork: Swift.String
  public static let pairingListWifiNetworksConnectWifiTitle: Swift.String
  public static let pairingListWifiNetworksForget: Swift.String
  public static let pairingListWifiNetworksFoundSavedPassword: Swift.String
  public static let pairingListWifiNetworksNoNetworksFound: Swift.String
  public static let pairingListWifiNetworksProceed: Swift.String
  public static let pairingListWifiNetworksSelectNetwork: Swift.String
  public static func pairingListWifiNetworksUseSavedPassword(_ p1: Any) -> Swift.String
  public static func pairingLoadingDeviceConnecting(_ p1: Any) -> Swift.String
  public static let pairingNo: Swift.String
  public static let pairingOther: Swift.String
  public static let pairingOtherNetworkTitle: Swift.String
  public static let pairingOtherWifiNetworkDeviceConnectivityHint: Swift.String
  public static let pairingOtherWifiNetworkHeader: Swift.String
  public static let pairingOtherWifiNetworkNetworkNamePlaceholder: Swift.String
  public static let pairingPairedSuccessfullyButtonAddDevice: Swift.String
  public static let pairingPairedSuccessfullyButtonDone: Swift.String
  public static let pairingPairedSuccessfullyButtonNotNow: Swift.String
  public static let pairingPairedSuccessfullyButtonPairAnother: Swift.String
  public static let pairingPairedSuccessfullyButtonUpdateAnother: Swift.String
  public static let pairingPairedSuccessfullyCompleteSetupForMotionSensing: Swift.String
  public static func pairingPairedSuccessfullyCompleteSetupForMotionSensingDescription(_ p1: Any) -> Swift.String
  public static let pairingPairedSuccessfullyHeader3: Swift.String
  public static let pairingPowerOnAndScanningAskUserToWait: Swift.String
  public static let pairingPowerOnAndScanningScanning: Swift.String
  public static let pairingScanDeviceConnectingToThisDevice: Swift.String
  public static let pairingScanDeviceMissingBluetoothLocationPermissionExplanation: Swift.String
  public static let pairingScanDeviceMissingBluetoothLocationPermissionsTitle: Swift.String
  public static let pairingScanDeviceMissingBluetoothPermissionTitle: Swift.String
  public static let pairingScanDevicePleaseHold: Swift.String
  public static let pairingScanDeviceSearchingForDevice: Swift.String
  public static let pairingScanDeviceTheLedLightIsNotPulsing: Swift.String
  public static let pairingScanQrCodeErrorDescription: Swift.String
  public static let pairingScanQrCodeErrorTitle: Swift.String
  public static let pairingScanQrExpandCameraView: Swift.String
  public static let pairingScanQrSubtitle: Swift.String
  public static let pairingScanQrTitle: Swift.String
  public static let pairingScanQrWhereIsQr: Swift.String
  public static let pairingScanQrcodeMissingCameraPermissionDescription: Swift.String
  public static let pairingScanQrcodeMissingCameraPermissionTitle: Swift.String
  public static let pairingScanningBleFaq: Swift.String
  public static let pairingScanningBleHeaderContactSensor: Swift.String
  public static let pairingSuccess: Swift.String
  public static let paringScanDeviceBluetoothIsOffDescription: Swift.String
  public static let paringScanDeviceBluetoothIsOffTitle: Swift.String
  public static let paringScanDeviceBluetoothRestrictedDescription: Swift.String
  public static let paringScanDeviceBluetoothRestrictedTitle: Swift.String
  public static let pkanDevicePlacementTitle: Swift.String
  public static let placeCreation: Swift.String
  public static let placeCreationCustomizeColorSelection: Swift.String
  public static let placeCreationCustomizeHeader: Swift.String
  public static let placeCreationErrorNoCategory: Swift.String
  public static let placeCreationFailToCreatePlace: Swift.String
  public static let placeCreationFailToGetPlaceInformation: Swift.String
  public static let placeCreationFailToUpdatePlace: Swift.String
  public static let placeCreationFloorDescription: Swift.String
  public static func placeCreationFloorFloorNumber(_ p1: Swift.Int) -> Swift.String
  public static func placeCreationFloorFloorNumberAndroid(_ p1: Any) -> Swift.String
  public static let placeCreationFloorHeader: Swift.String
  public static let placeCreationHeader: Swift.String
  public static let placeCreationNameCreatePlace: Swift.String
  public static let placeCreationNameDefaultName: Swift.String
  public static let placeCreationNameDescription: Swift.String
  public static let placeCreationNameEditHint: Swift.String
  public static let placeCreationNameError: Swift.String
  public static let placeCreationNameHeader: Swift.String
  public static let placeCreationPetsDescription: Swift.String
  public static let placeCreationPetsHeader: Swift.String
  public static let placeCreationSizeDescription: Swift.String
  public static let placeCreationSizeHeader: Swift.String
  public static func placeCreationZoneDefaultNameMultipleFloor(_ p1: Any) -> Swift.String
  public static let placeCreationZoneDefaultNameSingleFloor: Swift.String
  public static func placeDetailDoorSensorOpenAlert(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailDoorSensorOpenAlertIos(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailFormatDisconnectedDeviceInOneZoneAndroid(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailNumberOfZone(_ p1: Swift.Int) -> Swift.String
  public static let placeDetailSystemNotReadyToSecure: Swift.String
  public static let placeDetailTimezone: Swift.String
  public static let placeDetailsChangePlaceModeToArmedContainDegradedDescription: Swift.String
  public static let placeDetailsChangePlaceModeToArmedContainUnhealthyDescription: Swift.String
  public static let placeDetailsChangePlaceModeToAwareContainDegradedDescription: Swift.String
  public static let placeDetailsChangePlaceModeToAwareContainUnhealthyDescription: Swift.String
  public static let placeDetailsCustomize: Swift.String
  public static let placeDetailsDashboard: Swift.String
  public static let placeDetailsEvents: Swift.String
  public static func placeDetailsFormatDisconnectedDeviceInMultipleZoneAndroid(_ p1: Swift.Int) -> Swift.String
  public static let placeDetailsGetHelp: Swift.String
  public static let placeDetailsGraph: Swift.String
  public static func placeDetailsMemberPendingExpiryTime(_ p1: Any) -> Swift.String
  public static func placeDetailsMemberPendingExpiryTimeDays(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsMemberPendingExpiryTimeDaysWithHours(_ p1: Swift.Int, _ p2: Swift.Int) -> Swift.String
  public static func placeDetailsMemberPendingExpiryTimeHours(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsMemberPendingExpiryTimeMinutes(_ p1: Swift.Int) -> Swift.String
  public static let placeDetailsMembersActive: Swift.String
  public static func placeDetailsMembersDays(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsMembersHours(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsMembersMinutes(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsMembersMonths(_ p1: Swift.Int) -> Swift.String
  public static let placeDetailsNoDevicesPaired: Swift.String
  public static let placeDetailsOffline: Swift.String
  public static let placeDetailsPeople: Swift.String
  public static let placeDetailsPlaceMode: Swift.String
  public static func placeDetailsProceedWithDegradedZone(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsProceedWithUnhealthyZone(_ p1: Swift.Int) -> Swift.String
  public static let placeDetailsSecurityMode: Swift.String
  public static let placeDetailsSecurityModeDescription: Swift.String
  public static let placeDetailsSensingLinkBrokenInMultipleZone: Swift.String
  public static let placeDetailsSensingLinkBrokenInOneZone: Swift.String
  public static let placeDetailsSensorsAreNotResponding: Swift.String
  public static let placeDetailsStayModeNotActivatedAllZones: Swift.String
  public static let placeDetailsStayModeNotActivatedAllZonesDescription: Swift.String
  public static let placeDetailsStayModeNotAvailable: Swift.String
  public static let placeDetailsStayModeNotAvailableDescription: Swift.String
  public static let placeDetailsSystemNotReadyToSecureDescription: Swift.String
  public static let placeDetailsYesProceed: Swift.String
  public static func placeDetailsZoneInMode(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsZonesInModeAndroid(_ p1: Swift.Int) -> Swift.String
  public static let placeEventDateFilter: Swift.String
  public static let placeEventToday: Swift.String
  public static let placeEventYesterday: Swift.String
  public static let placeEventsDownloadingHistory: Swift.String
  public static func placeEventsEmptyDescription(_ p1: Any) -> Swift.String
  public static func placeEventsEmptyHistoryPlaceholder(_ p1: Any) -> Swift.String
  public static func placeEventsEmptyHistoryPlaceholderAndroid(_ p1: Any) -> Swift.String
  public static let placeEventsSearchNotFoundDescription: Swift.String
  public static let placeInformationAvgFloorArea: Swift.String
  public static let placeInformationFloors: Swift.String
  public static let placeInformationName: Swift.String
  public static let placeInformationPets: Swift.String
  public static let placeInformationSearchTimeZone: Swift.String
  public static let placeInformationTitle: Swift.String
  public static let placeInformationType: Swift.String
  public static func placeIntegrationsDescriptionPlaceholder(_ p1: Any) -> Swift.String
  public static let placeIntegrationsEnablingPlaceholder: Swift.String
  public static func placeIntegrationsIntegrationIs(_ p1: Any) -> Swift.String
  public static let placeIntegrationsIntegrations: Swift.String
  public static let placeIntegrationsIsDisabled: Swift.String
  public static let placeIntegrationsIsEnabled: Swift.String
  public static let placeIntegrationsWantDisable: Swift.String
  public static let placeModeAlertDialogStayModeNotAllZonesMessage: Swift.String
  public static let placeModeAlertDialogStayModeNotAllZonesTitle: Swift.String
  public static let placeModeAlertDialogStayModeWarningConfirm: Swift.String
  public static let placeModeAlertDialogStayModeWarningMessage: Swift.String
  public static let placeModeAlertDialogStayModeWarningTitle: Swift.String
  public static func placeModeDoorSensorOfflineAlert(_ p1: Swift.Int) -> Swift.String
  public static func placeModeDoorSensorOfflineAlertIos(_ p1: Swift.Int) -> Swift.String
  public static func placeModeWidgetAlarmIntrusionSince(_ p1: Any) -> Swift.String
  public static let placeModeWidgetConfigureSelectPlace: Swift.String
  public static let placeModeWidgetConfigureTitle: Swift.String
  public static let placeModeWidgetDataNotAvailable: Swift.String
  public static let placeModeWidgetErrorNoPlaces: Swift.String
  public static let placeModeWidgetErrorNoSelectedPlace: Swift.String
  public static let placeModeWidgetErrorUserLoggedOut: Swift.String
  public static let placeModeWidgetLogIn: Swift.String
  public static let placeModeWidgetSensingWarning: Swift.String
  public static let placeOverviewGraphNow: Swift.String
  public static let placeOverviewGraphThirtySecsAgo: Swift.String
  public static func placeOverviewIntrusionDetectionEndTime(_ p1: Any) -> Swift.String
  public static func placeOverviewIntrusionDetectionEndTimeFormatHour(_ p1: Swift.Int) -> Swift.String
  public static func placeOverviewIntrusionDetectionEndTimeFormatMinute(_ p1: Swift.Int) -> Swift.String
  public static func placeOverviewIntrusionDetectionStartTime(_ p1: Any) -> Swift.String
  public static let placeOverviewIntrusionDetectionTitle: Swift.String
  public static let placeOverviewMotion: Swift.String
  public static let placeOverviewNoDevicesHasBeenAdded: Swift.String
  public static let placeOverviewPairKitUnlockMotionSensing: Swift.String
  public static let placeOverviewPairingRequestAddDeviceButton: Swift.String
  public static let placeOverviewPairingRequestSetupAKit: Swift.String
  public static let placeOverviewPairingRequestSetupAKitGuide: Swift.String
  public static let placeOverviewSetupKitButton: Swift.String
  public static let placeOverviewZones: Swift.String
  public static let placePairOneMoreDeviceToUnlockTheMotionSensing: Swift.String
  public static let placePeopleInviteTitle: Swift.String
  public static let placePets: Swift.String
  public static let placePetsBigPets: Swift.String
  public static let placePetsBigPetsImperial: Swift.String
  public static let placePetsBigPetsMetric: Swift.String
  public static let placePetsBothSmallBigPets: Swift.String
  public static let placePetsNone: Swift.String
  public static let placePetsSmallPets: Swift.String
  public static let placePetsSmallPetsImperial: Swift.String
  public static let placePetsSmallPetsMetric: Swift.String
  public static let placePropertiesApartment: Swift.String
  public static let placePropertiesHouse: Swift.String
  public static let placeSettingEditPlaceToolbar: Swift.String
  public static let placeSettingHeaderAddDevices: Swift.String
  public static let placeSettingHeaderAddDevicesDescription: Swift.String
  public static let placeSettingHeaderGeneral: Swift.String
  public static let placeSettingHeaderSetup: Swift.String
  public static let placeSettingHeaderSetupADeviceDescription: Swift.String
  public static let placeSettingHeaderSetupADeviceTitle: Swift.String
  public static let placeSettingHeaderSetupAKitDescriptionDisableNonFirstKit: Swift.String
  public static let placeSettingHeaderSetupAKitDescriptionDisableOldPlace: Swift.String
  public static let placeSettingHeaderSetupAKitDescriptionEnable: Swift.String
  public static let placeSettingHeaderSetupAKitTitle: Swift.String
  public static let placeSettingPlaceInformation: Swift.String
  public static let placeSettingPlaceInformationDescription: Swift.String
  public static let placeSettingPlaceInformationEditName: Swift.String
  public static let placeSettingPlaceInformationFloor: Swift.String
  public static let placeSettingPlaceInformationName: Swift.String
  public static let placeSettingPlaceInformationSize: Swift.String
  public static let placeSettingPlaceInformationType: Swift.String
  public static let placeSettingsClearThreadCredential: Swift.String
  public static let placeSettingsDeletePlaceButton: Swift.String
  public static func placeSettingsDevicesDescriptionAndroid(_ p1: Swift.Int) -> Swift.String
  public static let placeSettingsEditPlace: Swift.String
  public static let placeSettingsEditPlaceDescription: Swift.String
  public static let placeSettingsEngine: Swift.String
  public static let placeSettingsEngineDoesNotSupportSensitivity: Swift.String
  public static func placeSettingsLastAdminLeaveDialogDescription(_ p1: Any) -> Swift.String
  public static let placeSettingsLastAdminLeaveDialogTitle: Swift.String
  public static let placeSettingsLeavePlaceButton: Swift.String
  public static func placeSettingsManageDevices(_ p1: Swift.Int) -> Swift.String
  public static let placeSettingsMotion: Swift.String
  public static let placeSettingsPlaceSettings: Swift.String
  public static let placeSettingsSectionGeneral: Swift.String
  public static let placeSettingsSectionSetup: Swift.String
  public static let placeSettingsSecurity: Swift.String
  public static let placeSettingsSensitivity: Swift.String
  public static func placeSettingsSensitivityLevel(_ p1: Any) -> Swift.String
  public static let placeSettingsSetupKit: Swift.String
  public static let placeSettingsTitle: Swift.String
  public static let placeSettingsUpdateWifiNetwork: Swift.String
  public static let placeSettingsUpdateWifiNetworkDescription: Swift.String
  public static let placeSettingsZeroDeviceDescription: Swift.String
  public static func placeSettingsZonesDescriptionAndroid(_ p1: Swift.Int) -> Swift.String
  public static let placeUsersInvitationInvitePeople: Swift.String
  public static func placeUsersInvitationUsersLimitReached(_ p1: Any) -> Swift.String
  public static func placeUsersInvitationUsersLimitReachedAndroid(_ p1: Any) -> Swift.String
  public static let placeUsersRoleRole: Swift.String
  public static let placeWidgetDoorSensorIsRequiredToActivateStayMode: Swift.String
  public static let placeWidgetStayModeActivatedForZonesWithoutDoorSensor: Swift.String
  public static let placesCategoryApartment: Swift.String
  public static let placesCategoryBusiness: Swift.String
  public static let placesCategoryDetachedHouse: Swift.String
  public static let placesCategoryEating: Swift.String
  public static let placesCategoryHouse: Swift.String
  public static let placesCategoryShopping: Swift.String
  public static let placesCategoryTownhouse: Swift.String
  public static let placesCategoryUnknown: Swift.String
  public static let placesCategoryWork: Swift.String
  public static let planDevicePlacementAvoidPlacementNearElectronic: Swift.String
  public static let planDevicePlacementGuide1Imperial: Swift.String
  public static let planDevicePlacementGuide1Metric: Swift.String
  public static let planDevicePlacementGuide2Imperial: Swift.String
  public static let planDevicePlacementGuide2Metric: Swift.String
  public static let planDevicePlacementGuide3Imperial: Swift.String
  public static let planDevicePlacementGuide3Metric: Swift.String
  public static func planDevicePlacementGuide4Imperial(_ p1: Any) -> Swift.String
  public static func planDevicePlacementGuide4Metric(_ p1: Any) -> Swift.String
  public static let planDevicePlacementGuide5Imperial: Swift.String
  public static let planDevicePlacementGuide5Metric: Swift.String
  public static let planDevicePlacementTitle: Swift.String
  public static let profileAccount: Swift.String
  public static let profileAccountManagementAccountDeletionDescription: Swift.String
  public static let profileAccountManagementConfirmAccountDeletion: Swift.String
  public static let profileAccountManagementDeleteAccountAlertDescription: Swift.String
  public static let profileAccountManagementDeleteAccountAlertTitle: Swift.String
  public static let profileAccountManagementDeleteAccountButton: Swift.String
  public static let profileAccountManagementTitle: Swift.String
  public static let profileAppVersion: Swift.String
  public static let profileAuthentication: Swift.String
  public static let profileCopied: Swift.String
  public static let profileCopiedToClipboard: Swift.String
  public static let profileCopyRecoveryKey: Swift.String
  public static let profileDeveloperModeAlertDescription: Swift.String
  public static let profileDeveloperModeAlertTitle: Swift.String
  public static let profileDeveloperModeDeactivateAction: Swift.String
  public static let profileDeveloperModeDeactivateAlertDescription: Swift.String
  public static let profileDeveloperModeDeactivateAlertTitle: Swift.String
  public static let profileDeveloperModeTitle: Swift.String
  public static let profileGoConfirmSigninRequest: Swift.String
  public static let profileHelpAndFeedback: Swift.String
  public static let profileHelpNFeedback: Swift.String
  public static let profileLegal: Swift.String
  public static let profileLinkAccountGuideText: Swift.String
  public static let profileLinked3rdPartyAccount: Swift.String
  public static let profileLinkedThirdPartyAccounts: Swift.String
  public static let profileLinkedThirdPartyAccountsNotLinkYet: Swift.String
  public static let profileLinkedThirdPartyAccountsUnlink: Swift.String
  public static let profileNoLinkedAccountsMessage: Swift.String
  public static let profilePrivacyPolicy: Swift.String
  public static let profileRecoveryInfoTitle: Swift.String
  public static let profileRecoveryKey: Swift.String
  public static let profileRecoveryKeyHint: Swift.String
  public static let profileSectionTitleAccount: Swift.String
  public static let profileSectionTitleHelp: Swift.String
  public static let profileSendTestPush: Swift.String
  public static let profileSettings: Swift.String
  public static let profileSignOut: Swift.String
  public static let profileSupportArticle: Swift.String
  public static let profileSupportArticles: Swift.String
  public static let profileTermsOfServices: Swift.String
  public static let profileUnlinkAlertConfirm: Swift.String
  public static let profileUnlinkAlertMessage: Swift.String
  public static let profileUnlinkAlertMessageAndroid: Swift.String
  public static let profileUnlinkAlertTitle: Swift.String
  public static let profileUser: Swift.String
  public static let profileUsername: Swift.String
  public static let profileUsernameYou: Swift.String
  public static let qrscannerWhereQr: Swift.String
  public static let recoveryButtonRecover: Swift.String
  public static let recoveryError: Swift.String
  public static let recoveryRecoveryKeyPlaceholder: Swift.String
  public static let recoveryTextGuide: Swift.String
  public static let removeDeviceChangeThreadNetwork: Swift.String
  public static func removeDeviceChangeThreadNetworkDescription(_ p1: Any) -> Swift.String
  public static let removeDeviceDataRemovedWarningThread: Swift.String
  public static func removeDeviceDataRemovedWarningThreadInZone(_ p1: Any) -> Swift.String
  public static let removeDeviceDataRemovedWarningWifi: Swift.String
  public static let removeDeviceDisableSensingFunction: Swift.String
  public static func removeDeviceDisableSensingFunctionDescription(_ p1: Any) -> Swift.String
  public static func removeDeviceRemoveDeviceName(_ p1: Any) -> Swift.String
  public static let removeDeviceRemoveThisDevice: Swift.String
  public static let removeDeviceRemoveThreadNetwork: Swift.String
  public static func removeDeviceRemoveThreadNetworkDescription(_ p1: Any) -> Swift.String
  public static func removeDeviceRestoreSensingInZone(_ p1: Any) -> Swift.String
  public static let removeDeviceRestoreSensingInZoneDescription: Swift.String
  public static let reportFalseAlarmByContinuingIntrusionWillBeDisarmed: Swift.String
  public static let reportFalseAlarmReportingAsFalseAlarmWillAlsoDisarmTheIntrusion: Swift.String
  public static let reportFalseAlarmTheIntrusionWasTriggeredBy: Swift.String
  public static let roomNamePlaceholder: Swift.String
  public static let roomSelectionTitle: Swift.String
  public static let roomsCategoryBathroom: Swift.String
  public static let roomsCategoryBedroom: Swift.String
  public static let roomsCategoryDinningArea: Swift.String
  public static let roomsCategoryKitchen: Swift.String
  public static let roomsCategoryLivingRoom: Swift.String
  public static let roomsCategoryOffice: Swift.String
  public static let roomsCategoryOther: Swift.String
  public static let roomsCategoryRetailSpace: Swift.String
  public static let roomsCategoryStoreRoom: Swift.String
  public static let roomsCategoryUnknown: Swift.String
  public static let securityModeAddMoreZoneToShowZoneSettings: Swift.String
  public static let securityModeDegradedZone: Swift.String
  public static let securityModeDisabledZone: Swift.String
  public static let securityModeDiscard: Swift.String
  public static let securityModeDiscardChanges: Swift.String
  public static let securityModeDiscardChangesDescription: Swift.String
  public static let securityModeExplanationBottomSheetGotIt: Swift.String
  public static let securityModeExplanationBottomSheetLearnMore: Swift.String
  public static let securityModeExplanationGotIt: Swift.String
  public static let securityModeExplanationLearnMore: Swift.String
  public static let securityModeExplanationStatusArmedDescription: Swift.String
  public static let securityModeExplanationStatusStandbyDescription: Swift.String
  public static let securityModeExplanationStatusStayDescription: Swift.String
  public static let securityModeExplanationSubTitle: Swift.String
  public static let securityModeExplanationTitle: Swift.String
  public static let securityModeStatusArmedDescription: Swift.String
  public static let securityModeStatusAwareDescription: Swift.String
  public static let securityModeStatusRelaxedDescription: Swift.String
  public static let securityModeStatusStandbyDescription: Swift.String
  public static let securityModeStatusStayDescription: Swift.String
  public static let securityModeZoneMode: Swift.String
  public static let securityModeZoneModeDescription: Swift.String
  public static let selectDeviceSetupDescription: Swift.String
  public static let selectFloorAreaDescription: Swift.String
  public static let selectFloorAreaHeader: Swift.String
  public static let selectFloorAreaOption1Imperial: Swift.String
  public static let selectFloorAreaOption1Metric: Swift.String
  public static let selectFloorAreaOption2Imperial: Swift.String
  public static let selectFloorAreaOption2Metric: Swift.String
  public static let selectFloorAreaOption3Imperial: Swift.String
  public static let selectFloorAreaOption3Metric: Swift.String
  public static let selectFloorAreaOption4Imperial: Swift.String
  public static let selectFloorAreaOption4Metric: Swift.String
  public static let selectFloorNumberDescription: Swift.String
  public static let selectFloorNumberHeader: Swift.String
  public static let selectKitDescription: Swift.String
  public static let selectKitMonitoringKit: Swift.String
  public static let selectKitMonitoringKitDescription: Swift.String
  public static let selectKitSecurityKit: Swift.String
  public static let selectKitSecurityKitDescription: Swift.String
  public static let selectKitTitle: Swift.String
  public static let selectPlaceIconHeader: Swift.String
  public static let selectPlaceThemeHeader: Swift.String
  public static let selectPlaceTypeDescription: Swift.String
  public static let selectPlaceTypeHeader: Swift.String
  public static let selectRoomCategoryHeader: Swift.String
  public static let selectRoomIconHeader: Swift.String
  public static let selectUserIconChooseProfileImage: Swift.String
  public static let selectUserIconPromptMessage: Swift.String
  public static let selectZoneDescription: Swift.String
  public static func selectZoneFormatAccessoryDevices(_ p1: Swift.Int) -> Swift.String
  public static func selectZoneFormatSensingDevices(_ p1: Swift.Int) -> Swift.String
  public static func selectZoneFormatThreadDevices(_ p1: Swift.Int) -> Swift.String
  public static func selectZoneFormatWifidevices(_ p1: Swift.Int) -> Swift.String
  public static let selectZoneTitle: Swift.String
  public static let sensing: Swift.String
  public static let sensitivitySettingsDescriptionUnavailable: Swift.String
  public static let sensitivitySettingsEngineUnavailable: Swift.String
  public static func sensitivitySettingsLevelAndroid(_ p1: Any) -> Swift.String
  public static let sensitivitySettingsMaxTitle: Swift.String
  public static let sensitivitySettingsMaxTitleAndroid: Swift.String
  public static let sensitivitySettingsMinTitle: Swift.String
  public static let sensitivitySettingsMinTitleAndroid: Swift.String
  public static let sensitivitySettingsSensitivityLevelDescription: Swift.String
  public static let sensitivitySettingsSuccess: Swift.String
  public static let sensitivitySettingsTitle: Swift.String
  public static let setupADeviceRoomSelectionSubTittle: Swift.String
  public static let setupADeviceRoomSelectionTittle: Swift.String
  public static let setupADeviceToolbarTitle: Swift.String
  public static let setupAKitFeatureNotAvailableDescription: Swift.String
  public static let setupAKitFeatureNotAvailableHeader: Swift.String
  public static let setupAKitHowDeviceWorkDescription: Swift.String
  public static let setupAKitHowDeviceWorkTittle: Swift.String
  public static let setupAKitHowDeviceWorksExplanationContent1: Swift.String
  public static let setupAKitHowDeviceWorksExplanationContent2: Swift.String
  public static let setupAKitHowDeviceWorksExplanationContent3: Swift.String
  public static let setupAKitHowDeviceWorksExplanationContent4: Swift.String
  public static let setupAKitHowDeviceWorksExplanationContent5: Swift.String
  public static let setupAKitHowDeviceWorksGuideContent1: Swift.String
  public static let setupAKitHowDeviceWorksGuideContent2: Swift.String
  public static let setupAKitHowDeviceWorksGuideContent3: Swift.String
  public static let setupAKitHowDeviceWorksGuideContent4: Swift.String
  public static let setupAKitHowDeviceWorksGuideContent5: Swift.String
  public static let setupAKitHowDeviceWorksStart: Swift.String
  public static func setupAKitHowToPlaceDeviceAddDevice(_ p1: Any) -> Swift.String
  public static let setupAKitHowToPlaceDeviceAddFirstSensePlug: Swift.String
  public static let setupAKitHowToPlaceDeviceAddSecondSensePlug: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideContent1FirstPairedDevice: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideContent2FirstPairedDeviceImperial: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideContent2FirstPairedDeviceMetric: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideContent3NonFirstPairedDevice: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideFirstDevice: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideFirstDeviceInZone: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideNonFirstDevice: Swift.String
  public static let setupAKitHowToPlaceDeviceNonFirstPairedDeviceGuideContent1: Swift.String
  public static let setupAKitHowToPlaceDeviceNonFirstPairedDeviceGuideContent2Imperial: Swift.String
  public static let setupAKitHowToPlaceDeviceNonFirstPairedDeviceGuideContent2Metric: Swift.String
  public static let setupAKitHowToPlaceDeviceNonFirstWidarHasBrGuideContent3: Swift.String
  public static let setupAKitIntroduceZoneContent1: Swift.String
  public static let setupAKitIntroduceZoneContent2: Swift.String
  public static let setupAKitIntroduceZoneContent3: Swift.String
  public static let setupAKitIntroduceZoneContent4: Swift.String
  public static let setupAKitIntroduceZoneContent5: Swift.String
  public static let setupAKitIntroduceZoneTitle: Swift.String
  public static let setupAKitKitSelectionTittle: Swift.String
  public static let setupAKitSelectYourPreferredZoneTitle: Swift.String
  public static let setupAKitToolbarTittle: Swift.String
  public static let setupAKitWhereToSetupAddGuide: Swift.String
  public static let setupAKitWhereToSetupOneFloorTitle: Swift.String
  public static func setupAKitWhereToSetupPlaceSizeLargeCoverage1Floor(_ p1: Any) -> Swift.String
  public static func setupAKitWhereToSetupPlaceSizeLargeCoverageMoreFloors(_ p1: Any) -> Swift.String
  public static let setupAKitWhereToSetupPlaceSizeSmallCoverage1Floor: Swift.String
  public static let setupAKitWhereToSetupSubTittleMoreFloorMonitoring: Swift.String
  public static let setupAKitWhereToSetupSubTittleMoreFloorSecurity: Swift.String
  public static let setupAKitWhereToSetupSubtitleMonitorOneFloorBigSize: Swift.String
  public static let setupAKitWhereToSetupSubtitleOneFloorSmallSize: Swift.String
  public static let setupAKitWhereToSetupSubtitleSecurityOneFloorBigSize: Swift.String
  public static let setupAKitWhereToSetupTittle: Swift.String
  public static let setupKitKitTrackerAllDevicesAdded: Swift.String
  public static let setupKitSecurityModeControlHowYourPlaceIsProtected: Swift.String
  public static let setupKitSecurityModeSelectSecurityModeForPlace: Swift.String
  public static let setupKitSecurityModeWhatIsSecurityMode: Swift.String
  public static let setupKitSecurityModeYouCanChangeLater: Swift.String
  public static let setupKitTestSystemCompleteTest: Swift.String
  public static let setupKitTestSystemDoorSensorDescription: Swift.String
  public static let setupKitTestSystemDoorSensorFaq: Swift.String
  public static let setupKitTestSystemMotionSensingDescription: Swift.String
  public static let setupKitTestSystemMotionSensingFaq: Swift.String
  public static let setupKitTestSystemPreparingDevice: Swift.String
  public static let setupKitTestSystemSiren: Swift.String
  public static let setupKitTestSystemSirenDescription: Swift.String
  public static let setupKitTestSystemSirenFaq: Swift.String
  public static let setupKitTestSystemSkipAll: Swift.String
  public static let setupKitTestSystemSoundSiren: Swift.String
  public static let setupKitTestSystemStopSiren: Swift.String
  public static let setupKitTestSystemTitle: Swift.String
  public static let setupKitTitle: Swift.String
  public static let setupKitYourSystemIsReadyToSecureYourPlace: Swift.String
  public static let setupKitYoureAllSet: Swift.String
  public static let setupMotionSensingFirstBssFirstKit: Swift.String
  public static func setupMotionSensingFirstBssNonFirstKitHasBr(_ p1: Any) -> Swift.String
  public static let setupMotionSensingFirstBssNonFirstKitNoBr: Swift.String
  public static let setupMotionSensingFirstHmsFirstKit: Swift.String
  public static func setupMotionSensingFirstHmsNonFirstKitHasBr(_ p1: Any) -> Swift.String
  public static let setupMotionSensingFirstHmsNonFirstKitNoBr: Swift.String
  public static let setupMotionSensingFirstNot: Swift.String
  public static let setupMotionSensingFirstTheDoorSensorDoesNotDetectMotion: Swift.String
  public static let setupMotionSensingFirstTheDoorSensorDoesNotDetectMotionMarkdown: Swift.String
  public static let setupMotionSensingFirstTitle: Swift.String
  public static let setupMotionSensingFirstWidarFirstKit: Swift.String
  public static func setupMotionSensingFirstWidarNonFirstKitHasBr1(_ p1: Any) -> Swift.String
  public static let setupMotionSensingFirstWidarNonFirstKitHasBr2: Swift.String
  public static let setupMotionSensingFirstWidarNonFirstKitNoBr: Swift.String
  public static let signUpAnonymousAccountText: Swift.String
  public static let signUpAnonymousAccountText1: Swift.String
  public static let signUpAnonymousAccountText2: Swift.String
  public static let signUpAnonymousAccountText3: Swift.String
  public static let signUpButtonRecoveryKey: Swift.String
  public static let signUpButtonSignUpAnonymous: Swift.String
  public static let signUpContinueWithApple: Swift.String
  public static let signUpContinueWithGoogle: Swift.String
  public static let signUpOtherSignUpOptions: Swift.String
  public static let signUpPrivacyPolicy: Swift.String
  public static let signUpTermsOfService: Swift.String
  public static let signUpTosAndPrivacyPart1: Swift.String
  public static let signUpTosAndPrivacyPart2: Swift.String
  public static let signUpTosAndPrivacyPart2Android: Swift.String
  public static let signUpTosAndPrivacyPart3: Swift.String
  public static let signUpTosAndPrivacyPart4: Swift.String
  public static let signUpTosAndPrivacyPart4Android: Swift.String
  public static let signUpWelcomeText: Swift.String
  public static let statusAlert: Swift.String
  public static let statusArmed: Swift.String
  public static let statusArmedHint: Swift.String
  public static let statusArmedHintDisabled: Swift.String
  public static let statusAware: Swift.String
  public static let statusAwareHint: Swift.String
  public static func statusInSwitchingMode(_ p1: Any, _ p2: Any) -> Swift.String
  public static let statusRelaxed: Swift.String
  public static let statusRelaxedHint: Swift.String
  public static let statusStandby: Swift.String
  public static let statusStandbyHint: Swift.String
  public static let statusStay: Swift.String
  public static let statusStayHint: Swift.String
  public static let statusStayHintDisabled: Swift.String
  public static let systemSetupBasicSecuritySystem: Swift.String
  public static let systemSetupBasicSecuritySystemDescription: Swift.String
  public static let systemSetupHomeMonitoringSystem: Swift.String
  public static let systemSetupHomeMonitoringSystemDescription: Swift.String
  public static let systemSetupOthers: Swift.String
  public static let systemSetupSetupSingleDeviceDialogButton: Swift.String
  public static let systemSetupSetupSingleDeviceDialogDescription: Swift.String
  public static let systemSetupSetupSingleDeviceDialogTitle: Swift.String
  public static let systemSetupWidarDoorSensor: Swift.String
  public static let systemSetupWidarDoorSensorDescription: Swift.String
  public static let tabbarTitleAutomation: Swift.String
  public static let tabbarTitlePlace: Swift.String
  public static let tabbarTitleSettings: Swift.String
  public static let timeZoneNoResultsFound: Swift.String
  public static let timeZoneSearchTimeZone: Swift.String
  public static func updateWifiDeviceAlreadyUpdated(_ p1: Any) -> Swift.String
  public static func updateWifiDeviceNotInZone(_ p1: Any) -> Swift.String
  public static let updateWifiHowItWorksConfirmButton: Swift.String
  public static let updateWifiHowItWorksDescription: Swift.String
  public static let updateWifiHowItWorksHelp: Swift.String
  public static let updateWifiHowItWorksInstructionBulletPoint1: Swift.String
  public static let updateWifiHowItWorksInstructionBulletPoint2: Swift.String
  public static let updateWifiHowItWorksInstructionBulletPoint3: Swift.String
  public static let updateWifiHowItWorksInstructionBulletPoint4: Swift.String
  public static let updateWifiHowItWorksInstructionPart1: Swift.String
  public static let updateWifiHowItWorksInstructionPart2: Swift.String
  public static let updateWifiHowItWorksInstructionTitle: Swift.String
  public static let updateWifiHowItWorksTitle: Swift.String
  public static let updateWifiLocateDeviceButton: Swift.String
  public static let updateWifiNetworkCommissioningModeCustomizePlace: Swift.String
  public static func updateWifiNetworkDeviceQrCodeDeviceAlreadyRepairedAndroid(_ p1: Any) -> Swift.String
  public static func updateWifiNetworkDeviceQrCodeDeviceNotInZoneAndroid(_ p1: Any) -> Swift.String
  public static let updateWifiNetworkHowItWorksGuideSubtitle: Swift.String
  public static let updateWifiNetworkResetDeviceGuidePlugType: Swift.String
  public static let updateWifiNetworkResetDeviceGuidePod2: Swift.String
  public static let updateWifiNetworkResetDeviceGuidePodType: Swift.String
  public static let updateWifiNetworkUpdateSuccessfullyHeader1: Swift.String
  public static let updateWifiNetworkZoneStatusGuideCompletedUpdate: Swift.String
  public static let updateWifiNetworkZonesSelectionGuide: Swift.String
  public static let updateWifiNotNamiQrCodeNoZone: Swift.String
  public static let updateWifiQrCodeError: Swift.String
  public static let updateWifiQrDoesNotMatch: Swift.String
  public static let updateWifiResetDeviceConfirmButton: Swift.String
  public static let updateWifiResetDeviceDescription: Swift.String
  public static func updateWifiResetDeviceHowToReset(_ p1: Any) -> Swift.String
  public static let updateWifiResetDevicePlugResetInstructions1: Swift.String
  public static let updateWifiResetDevicePlugResetInstructions2: Swift.String
  public static let updateWifiResetDevicePlugResetInstructions3: Swift.String
  public static let updateWifiResetDevicePlugResetInstructions4: Swift.String
  public static let updateWifiResetDevicePodResetInstructions1: Swift.String
  public static let updateWifiResetDevicePodResetInstructions2: Swift.String
  public static let updateWifiResetDevicePodResetInstructions3: Swift.String
  public static let updateWifiResetDevicePodResetInstructions4: Swift.String
  public static let updateWifiResetDeviceTitle: Swift.String
  public static let updateWifiSelectZoneToUpdateConfirmButton: Swift.String
  public static let updateWifiSelectZoneToUpdateDescription: Swift.String
  public static let updateWifiSelectZoneToUpdateNonThreadZoneSupport: Swift.String
  public static func updateWifiSelectZoneToUpdateNumberOfDevices(_ p1: Any) -> Swift.String
  public static let updateWifiSelectZoneToUpdateSelectZone: Swift.String
  public static let updateWifiSelectZoneToUpdateTitle: Swift.String
  public static let updateWifiTitle: Swift.String
  public static let updateWifiZoneDeviceCheckScanQr: Swift.String
  public static let updateWifiZoneWifiUpdateConfirmButton: Swift.String
  public static let updateWifiZoneWifiUpdateCongratulations: Swift.String
  public static let updateWifiZoneWifiUpdateDescription: Swift.String
  public static let updateWifiZoneWifiUpdateDevicesUpdated: Swift.String
  public static let updateWifiZoneWifiUpdateFinishButton: Swift.String
  public static let updateWifiZoneWifiUpdateLastDeviceDescription: Swift.String
  public static let updateWifiZoneWifiUpdateLocateDevice: Swift.String
  public static let updateWifiZoneWifiUpdateSessionCompleted: Swift.String
  public static let updateWifiZoneWifiUpdateUpdateAnotherZoneButton: Swift.String
  public static func upgradeMultiZonesCreateFailed(_ p1: Any) -> Swift.String
  public static func upgradeMultiZonesLoadZoneFailed(_ p1: Any) -> Swift.String
  public static func upgradeMultiZonesUpdateFailed(_ p1: Any) -> Swift.String
  public static let userDetailsAskLeavePlaceButton: Swift.String
  public static let userDetailsAskRemoveUserButton: Swift.String
  public static let userDetailsConfirmLeavePlaceButton: Swift.String
  public static let userDetailsConfirmRemoveUserButton: Swift.String
  public static func userDetailsLeavePlaceAlertMessage(_ p1: Any) -> Swift.String
  public static let userDetailsLeavePlaceAlertTitle: Swift.String
  public static func userDetailsRemoveUserAlertMessage(_ p1: Any, _ p2: Any) -> Swift.String
  public static let userDetailsRemoveUserAlertTitle: Swift.String
  public static let userDetailsSaveChangesButton: Swift.String
  public static let userRemoveUserDescription: Swift.String
  public static func userRemoveUserTitle(_ p1: Any) -> Swift.String
  public static let userRoleAdministrator: Swift.String
  public static let userRoleUser: Swift.String
  public static let welcomePagePolicy: Swift.String
  public static let widarCancelPopupBackToPositioningButton: Swift.String
  public static let widarCancelPopupCancelButton: Swift.String
  public static let widarCancelPopupMessage: Swift.String
  public static let widarCancelPopupTitle: Swift.String
  public static let widarErrorDeviceNotFoundMessage: Swift.String
  public static let widarErrorExitButton: Swift.String
  public static let widarErrorRetryButton: Swift.String
  public static let widarErrorTitle: Swift.String
  public static let widarErrorWrongStep: Swift.String
  public static let widarHeaderTitle: Swift.String
  public static let widarInfoButtonText: Swift.String
  public static let widarInfoInfoAvoidMovingWhenOptimized: Swift.String
  public static let widarInfoInfoMustOptimisePosition: Swift.String
  public static let widarInfoTitle: Swift.String
  public static let widarPositionCancelButton: Swift.String
  public static let widarPositionFinishButton: Swift.String
  public static let widarPositionGuideImperial: Swift.String
  public static let widarPositionGuideMetric: Swift.String
  public static let widarPositionImperialGuide: Swift.String
  public static let widarPositionMetricGuide: Swift.String
  public static let widarPositionStatusChecking: Swift.String
  public static let widarPositionStatusGettingBetter: Swift.String
  public static let widarPositionStatusLabel: Swift.String
  public static let widarPositionStatusMispositioned: Swift.String
  public static let widarPositionStatusOptimized: Swift.String
  public static let widarPositionTertiaryButtonText: Swift.String
  public static let widarPositionTip: Swift.String
  public static let widarPositionTitle: Swift.String
  public static let widarRecommendationsButtonText: Swift.String
  public static let widarRecommendationsInfoAttachBase: Swift.String
  public static let widarRecommendationsInfoKeepAreaClear: Swift.String
  public static let widarRecommendationsInfoWireOnBack: Swift.String
  public static let widarRecommendationsTitle: Swift.String
  public static func widarSuccessContentMessage(_ p1: Any) -> Swift.String
  public static let widarSuccessDoneButton: Swift.String
  public static let widarSuccessTitle: Swift.String
  public static let zoneChecksMotionSensingCheckName: Swift.String
  public static let zoneChecksMotionSensingStatusDisconnected: Swift.String
  public static let zoneChecksMotionSensingStatusNotWorking: Swift.String
  public static let zoneChecksMotionSensingStatusWorkingMotionDetected: Swift.String
  public static let zoneChecksMotionSensingStatusWorkingMotionNotDetected: Swift.String
  public static let zoneChecksZoneHealthCheckName: Swift.String
  public static let zoneChecksZoneHealthHintAssessingZoneHealth: Swift.String
  public static let zoneChecksZoneHealthHintCheckNeeded: Swift.String
  public static let zoneChecksZoneHealthHintWorksWell: Swift.String
  public static let zoneChecksZoneHealthStatusDegraded: Swift.String
  public static let zoneChecksZoneHealthStatusHealthy: Swift.String
  public static let zoneChecksZoneHealthStatusUnhealthy: Swift.String
  public static let zoneChecksZoneHealthStatusUnknown: Swift.String
  public static let zoneDefaultName: Swift.String
  public static let zoneGuideGotIt: Swift.String
  public static let zoneGuideHeader: Swift.String
  public static let zoneGuideSubtitle1: Swift.String
  public static let zoneGuideSubtitle2: Swift.String
  public static let zoneGuideTitle1: Swift.String
  public static let zoneGuideTitle2: Swift.String
  public static let zoneGuideTitle3: Swift.String
  public static let zoneSelectionAddYourKitTo: Swift.String
  public static let zoneSelectionIDontKnowWhatToChoose: Swift.String
  public static let zoneSelectionNonThreadBorderRouterZoneExplain: Swift.String
  public static let zoneSelectionTitle: Swift.String
  public static let zoneSelectionZoneDeviceLimitationExplain: Swift.String
}
public enum Log {
  public static func info(_ items: Any...)
  public static func warning(_ items: Any...)
  public static func `if`(_ condition: Swift.Bool = true, run: () -> Swift.Void)
  public static func enableLogtoFile(enableLogtoFile: Swift.Bool)
  public static func getLogFile() -> Foundation.URL?
  public static func resetLogFile()
  public static var isEnabledLogFile: Swift.Bool {
    get
  }
}
public enum Tokens : Swift.String {
  case access
  case refresh
  case recovery
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum TokenStoreError : Swift.Error {
  case notFound
  case decodingError
  case systemError
  public static func == (a: NamiPairingFramework.TokenStoreError, b: NamiPairingFramework.TokenStoreError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TokenStore {
  func store<TokenType>(token: TokenType, at key: NamiPairingFramework.Tokens) where TokenType : Swift.Decodable, TokenType : Swift.Encodable
  func retrieve<TokenType>(a type: TokenType.Type, from key: NamiPairingFramework.Tokens) -> Swift.Result<TokenType, NamiPairingFramework.TokenStoreError> where TokenType : Swift.Decodable, TokenType : Swift.Encodable
  func delete(at key: NamiPairingFramework.Tokens)
}
final public class TokenSecureStorage : NamiPairingFramework.TokenStore {
  public init(server: Swift.String)
  final public func store<TokenType>(token: TokenType, at key: NamiPairingFramework.Tokens) where TokenType : Swift.Decodable, TokenType : Swift.Encodable
  final public func retrieve<TokenType>(a type: TokenType.Type, from key: NamiPairingFramework.Tokens) -> Swift.Result<TokenType, NamiPairingFramework.TokenStoreError> where TokenType : Swift.Decodable, TokenType : Swift.Encodable
  final public func delete(at key: NamiPairingFramework.Tokens)
  @objc deinit
}
public enum KeychainError : Swift.Error, Swift.Equatable {
  case notFound
  case systemError
  public static func == (a: NamiPairingFramework.KeychainError, b: NamiPairingFramework.KeychainError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SecureStorage {
  public static var accessGroup: Swift.String {
    get
  }
  public static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  public static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, NamiPairingFramework.KeychainError>
  public static func delete(at key: Swift.String, server: Swift.String)
}
extension Swift.Int32 {
  public var description: Swift.String {
    get
  }
}
public enum KeychainMigration {
  public static func migrateToAccessGroupStorage(server: Swift.String)
}
public enum ISO8601MsecDecoder {
  public static let defaultFormatter: Foundation.ISO8601DateFormatter
  public static func decodedDate(_ decoder: any Swift.Decoder) throws -> Foundation.Date
  public static func encodeDate(date: Foundation.Date, encoder: any Swift.Encoder) throws
}
extension Foundation.JSONDecoder {
  public static func ISO8601Msec() -> Foundation.JSONDecoder
}
extension Foundation.JSONEncoder {
  public static func ISO8601Msec() -> Foundation.JSONEncoder
}
public enum PacketBoatError : Swift.String, Swift.Error {
  case wrongDataFormat
  case wrongDataSize
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
final public class PacketBoat {
  public init()
  final public var doneSending: Swift.Bool {
    get
  }
  final public var doneReceiving: Swift.Bool {
    get
  }
  final public func startSending(data: Foundation.Data)
  final public func nextBitToSend(maxSize: Swift.UInt) -> Foundation.Data?
  final public func receivedData() -> Foundation.Data?
  final public func receiveNext(data: Foundation.Data) -> Swift.Result<Swift.Bool, NamiPairingFramework.PacketBoatError>
  @objc deinit
}
public enum SeanceError : Swift.Error {
  case keyDerivationError
  case wrongState(Swift.String)
  case keyAgreementError
  case verificationError
}
public class Seance {
  public init(role: NamiPairingFramework.Seance.Role)
  public enum Role {
    case prover
    case verifier
    public static func == (a: NamiPairingFramework.Seance.Role, b: NamiPairingFramework.Seance.Role) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum State {
    case initial
    case started
    case unverified
    case established
    public static func == (a: NamiPairingFramework.Seance.State, b: NamiPairingFramework.Seance.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let role: NamiPairingFramework.Seance.Role
  public var state: NamiPairingFramework.Seance.State {
    get
  }
  public static func preProcessPassword(_ password: Swift.UInt32, salt: [Swift.UInt8], iterations: Swift.UInt32 = 100000) throws -> Foundation.Data
  public func start(preProcessedPassword: Foundation.Data) throws -> Foundation.Data
  public func makeSharedKey(otherKeyData: Foundation.Data) throws -> Foundation.Data
  public func verify(otherValue: Foundation.Data) throws -> NamiPairingFramework.GhostBox
  @objc deinit
}
public struct GhostMessage {
  public let nonce: Foundation.Data
  public let ciphertext: Foundation.Data
  public let tag: Foundation.Data
}
@_hasMissingDesignatedInitializers final public class GhostBox {
  final public func encrypt(message: Foundation.Data) -> NamiPairingFramework.GhostMessage?
  final public func decrypt(nonce: Foundation.Data, ciphertext: Foundation.Data, tag: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
public protocol ThreadSecureStorageProtocol {
  associatedtype Thread_SecureStorageError : Swift.Error
  static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, Self.Thread_SecureStorageError>
  static func delete(at key: Swift.String, server: Swift.String)
}
public enum MeshCoPType : Swift.Equatable, Swift.Codable {
  case channel(Swift.UInt16)
  case panID(Swift.UInt16)
  case extendedPanID(Swift.UInt64)
  case networkName(Swift.String)
  case pskc([Swift.UInt8])
  case networkKey(Foundation.Data)
  case sequenceCounter(Swift.UInt64)
  case meshLocalPrefix(Swift.UInt64)
  case securityPolicy(Swift.UInt32)
  case activeTimestamp(Swift.UInt64)
  case pendingTimestamp(Swift.UInt64)
  case delayTimer(Swift.UInt32)
  case channelMask([[Swift.UInt8]])
  public static func == (a: NamiPairingFramework.MeshCoPType, b: NamiPairingFramework.MeshCoPType) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
final public class ThreadOperationalDatasetProvider<SecureStorage> where SecureStorage : NamiPairingFramework.ThreadSecureStorageProtocol {
  public init(secureStoreServer: Swift.String, storage: SecureStorage.Type)
  final public func newRandomDataset(networkName: Swift.String?) -> NamiPairingFramework.NamiThreadOperationalDataset
  final public func retrieve(placeId: NamiPairingFramework.PlaceID) -> NamiPairingFramework.NamiThreadOperationalDataset?
  final public func removeDataset(for placeId: NamiPairingFramework.PlaceID)
  final public func storeDataset(_ dataset: Foundation.Data, for placeId: NamiPairingFramework.PlaceID)
  final public func storeDataset(_ dataset: NamiPairingFramework.NamiThreadOperationalDataset, for placeId: NamiPairingFramework.PlaceID)
  @objc deinit
}
public typealias PanID = Foundation.Data
public struct NamiThreadOperationalDataset : Swift.Equatable, Swift.Codable {
  public init()
  public init(placeName: Swift.String)
  public init(networkName: Swift.String)
  public init(data: Foundation.Data)
  public let tlvs: [NamiPairingFramework.MeshCoPType]
  public var data: Foundation.Data {
    get
  }
  public func equalsNumericalPanID<ID>(_ panId: ID) -> Swift.Bool where ID : Swift.FixedWidthInteger
  public static func == (a: NamiPairingFramework.NamiThreadOperationalDataset, b: NamiPairingFramework.NamiThreadOperationalDataset) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiWiFiNetwork : Swift.Equatable, Swift.Hashable {
  public let ssid: Swift.String
  public let rssi: Swift.Int
  public let bssid: NamiPairingFramework.BSSID
  public let open: Swift.Bool
  public static func == (a: NamiPairingFramework.NamiWiFiNetwork, b: NamiPairingFramework.NamiWiFiNetwork) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias BSSID = Foundation.Data
public struct ScanWiFiNetworksParameters : Swift.Equatable {
  public init(sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID?, currentDeviceUid: NamiPairingFramework.DeviceUniversalID?, scanFinishedSessionId: Swift.Int? = nil, passwordReEntryRequested: Swift.Bool = false)
  public var sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID?
  public var scanFinishedSessionId: Swift.Int?
  public var currentDeviceUid: NamiPairingFramework.DeviceUniversalID?
  public var passwordReEntryRequested: Swift.Bool
  public static func == (a: NamiPairingFramework.ScanWiFiNetworksParameters, b: NamiPairingFramework.ScanWiFiNetworksParameters) -> Swift.Bool
}
public struct ScannedWiFiNetworks : Swift.Equatable {
  public init(networks: [NamiPairingFramework.PublicWiFiNetwork], canRetry: Swift.Bool)
  public var networks: [NamiPairingFramework.PublicWiFiNetwork]
  public var canRetry: Swift.Bool
  public static func == (a: NamiPairingFramework.ScannedWiFiNetworks, b: NamiPairingFramework.ScannedWiFiNetworks) -> Swift.Bool
}
public enum ErrorScreen {
  public struct State : Swift.Equatable {
    public var positioningError: NamiPairingFramework.PositioningError
    public var positioningCancelled: Swift.Bool
    public var wantToRetryPositioning: Swift.Bool
    public var buttonsDisabled: Swift.Bool {
      get
    }
    public static func == (a: NamiPairingFramework.ErrorScreen.State, b: NamiPairingFramework.ErrorScreen.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case cancelPositioning
    case retryPositioning
    public static func == (a: NamiPairingFramework.ErrorScreen.Event, b: NamiPairingFramework.ErrorScreen.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.ErrorScreen.State
    public typealias Event = NamiPairingFramework.ErrorScreen.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.ErrorScreen.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.ErrorScreen.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(_ event: NamiPairingFramework.ErrorScreen.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum HowToPosition {
  public struct State : Swift.Equatable {
    public static func == (a: NamiPairingFramework.HowToPosition.State, b: NamiPairingFramework.HowToPosition.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case never
    case wantToDismiss
    case dismissPresented
    case startPositioningTapped
    case gotDevice(NamiPairingFramework.PairingDevice)
    public static func == (a: NamiPairingFramework.HowToPosition.Event, b: NamiPairingFramework.HowToPosition.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.HowToPosition.State
    public typealias Event = NamiPairingFramework.HowToPosition.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.HowToPosition.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.HowToPosition.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(_ event: NamiPairingFramework.HowToPosition.ViewModel.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum PositioningGuidance {
  public enum PositioningQuality : Swift.Equatable {
    case unknown
    case poor
    case degraded
    case good
    public static func == (a: NamiPairingFramework.PositioningGuidance.PositioningQuality, b: NamiPairingFramework.PositioningGuidance.PositioningQuality) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PositioningState : Swift.Equatable {
    case unknown
    case started
    case stopped
    public static func == (a: NamiPairingFramework.PositioningGuidance.PositioningState, b: NamiPairingFramework.PositioningGuidance.PositioningState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct State : Swift.Equatable {
    public var deviceName: Swift.String
    public var deviceUid: NamiPairingFramework.DeviceUniversalID
    public var placeId: NamiPairingFramework.PlaceID
    public var positioningQuality: NamiPairingFramework.PositioningGuidance.PositioningQuality
    public var positioningState: NamiPairingFramework.PositioningGuidance.PositioningState
    public var error: NamiPairingFramework.PositioningError?
    public var wantToDismiss: Swift.Bool
    public var wantCancel: Swift.Bool
    public var wantFinish: Swift.Bool
    public var cancelConfirmed: Swift.Bool
    public var canNotFinish: Swift.Bool {
      get
    }
    public var canNotCancel: Swift.Bool {
      get
    }
    public var shouldRetryPositioning: Swift.Bool
    public var shouldRetryRequestingState: Swift.Bool
    public var device: NamiPairingFramework.PairingDevice?
    public var locallyAccessible: Swift.Bool
    public var deviceCloudDisconnected: Swift.Bool {
      get
    }
    public static func == (a: NamiPairingFramework.PositioningGuidance.State, b: NamiPairingFramework.PositioningGuidance.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case never
    case retryPositioning
    case retryRequestingState
    case stopRetryingRequestingState
    case gotPositioningQuality(NamiPairingFramework.PositioningGuidance.PositioningQuality)
    case gotError(NamiPairingFramework.PositioningError)
    case gotStateError(NamiPairingFramework.PositioningError)
    case wantToDismiss
    case wantFinishTapped
    case wantCancelTapped
    case cancelViewDismissed
    case confirmPositioningCancel
    case positionState(NamiPairingFramework.PositioningGuidance.PositioningState)
    case gotDevice(NamiPairingFramework.PairingDevice)
    public static func == (a: NamiPairingFramework.PositioningGuidance.Event, b: NamiPairingFramework.PositioningGuidance.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.PositioningGuidance.State
    public typealias Event = NamiPairingFramework.PositioningGuidance.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PositioningGuidance.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PositioningGuidance.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(_ event: NamiPairingFramework.PositioningGuidance.Event)
    @objc deinit
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  }
}
public enum InitialScreen {
  public struct State : Swift.Equatable {
    public static func == (a: NamiPairingFramework.InitialScreen.State, b: NamiPairingFramework.InitialScreen.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case never
    case howToPositionTapped
    case dismissPresented
    case dismissSelf
    public static func == (a: NamiPairingFramework.InitialScreen.Event, b: NamiPairingFramework.InitialScreen.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.InitialScreen.State
    public typealias Event = NamiPairingFramework.InitialScreen.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.InitialScreen.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.InitialScreen.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(_ event: NamiPairingFramework.InitialScreen.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum PositioningComplete {
  public struct State : Swift.Equatable {
    public var deviceName: Swift.String
    public var wantConfirmPositioningComplete: Swift.Bool
    public static func == (a: NamiPairingFramework.PositioningComplete.State, b: NamiPairingFramework.PositioningComplete.State) -> Swift.Bool
  }
  public enum Event {
    case confirmPositioningComplete
    public static func == (a: NamiPairingFramework.PositioningComplete.Event, b: NamiPairingFramework.PositioningComplete.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.PositioningComplete.State
    public typealias Event = NamiPairingFramework.PositioningComplete.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PositioningComplete.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PositioningComplete.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(_ event: NamiPairingFramework.PositioningComplete.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum PositioningStep {
  case finishPositioningButtonTapped
  case cancelPositioningButtonTapped
  case successIsConfirmed
  case cancelIsConfirmed
  case positioningError(NamiPairingFramework.PositioningError)
}
public enum PositioningResult {
  case finished
  case cancelled
  public static func == (a: NamiPairingFramework.PositioningResult, b: NamiPairingFramework.PositioningResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum PositioningError : Swift.Error, Swift.Equatable {
  case timeout
  case disconnected
  case wrapped(any Swift.Error)
  public static func == (lhs: NamiPairingFramework.PositioningError, rhs: NamiPairingFramework.PositioningError) -> Swift.Bool
}
public enum PositioningRoot {
  public enum Route : Swift.Equatable {
    case startScreen(Swift.String, NamiPairingFramework.DeviceUniversalID, NamiPairingFramework.PlaceID)
    case howToPosition(Swift.String, NamiPairingFramework.DeviceUniversalID, NamiPairingFramework.PlaceID)
    case positionGuidance(Swift.String, NamiPairingFramework.DeviceUniversalID, NamiPairingFramework.PlaceID)
    case successScreen(Swift.String)
    case errorScreen(NamiPairingFramework.PositioningError)
    public static func == (a: NamiPairingFramework.PositioningRoot.Route, b: NamiPairingFramework.PositioningRoot.Route) -> Swift.Bool
  }
  public struct State : NamiPairingFramework.StateWithRoute {
    public var route: NamiPairingFramework.PositioningRoot.Route?
    public static func == (a: NamiPairingFramework.PositioningRoot.State, b: NamiPairingFramework.PositioningRoot.State) -> Swift.Bool
    public typealias Route = NamiPairingFramework.PositioningRoot.Route
  }
  public enum Event : Swift.Equatable {
    case empty
    case positioningSucceed
    case positioningEnded
    case positioningCancelled
    case showHowToPosition
    case showPositionGuidance
    case gotError(NamiPairingFramework.PositioningError)
    case restart
    public static func == (a: NamiPairingFramework.PositioningRoot.Event, b: NamiPairingFramework.PositioningRoot.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel<Container> : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol where Container : NamiPairingFramework.PairingStepsContainer {
    public typealias State = NamiPairingFramework.PositioningRoot.State
    public typealias Event = NamiPairingFramework.PositioningRoot.Event
    final public func send(_ event: NamiPairingFramework.PositioningRoot.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public struct PairingDevice : NamiPairingFramework.DeviceProtocol, Swift.Codable, Swift.Equatable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias State = NamiPairingFramework.PairingDeviceCloudState
  public typealias CloudConnection = NamiPairingFramework.PairingDeviceCloudConnectionStatus
  public var isBorderRouter: Swift.Bool
  public var id: NamiPairingFramework.DeviceID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var name: Swift.String
  public var roomId: NamiPairingFramework.RoomID
  public var bleDiscriminator: Swift.Int32?
  public var codeName: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var model: any NamiPairingFramework.DeviceModelProtocol
  public var cloudConnection: NamiPairingFramework.PairingDevice.CloudConnection?
  public var deviceState: NamiPairingFramework.PairingDevice.State?
  public static func == (lhs: NamiPairingFramework.PairingDevice, rhs: NamiPairingFramework.PairingDevice) -> Swift.Bool
}
public struct PairingDeviceCloudConnectionStatus : NamiPairingFramework.DeviceCloudConnectionStatusProtocol, Swift.Equatable {
  public var isConnected: Swift.Bool
  public var updatedAt: Foundation.Date?
  public static func == (a: NamiPairingFramework.PairingDeviceCloudConnectionStatus, b: NamiPairingFramework.PairingDeviceCloudConnectionStatus) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingDeviceCloudState : NamiPairingFramework.DeviceStateProtocol, Swift.Codable, Swift.Equatable {
  public var payload: Foundation.Data
  public var seqTime: Swift.UInt64
  public var updatedAt: Foundation.Date
  public init(payload: Foundation.Data, seqTime: Swift.UInt64, updatedAt: Foundation.Date)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.PairingDeviceCloudState, b: NamiPairingFramework.PairingDeviceCloudState) -> Swift.Bool
}
public struct PairingDeviceModel : Swift.Encodable, NamiPairingFramework.DeviceModelProtocol, Swift.Equatable {
  public var codeName: Swift.String
  public var productLabel: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public static func == (a: NamiPairingFramework.PairingDeviceModel, b: NamiPairingFramework.PairingDeviceModel) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingPlace : NamiPairingFramework.RemoteTemplateUI_PlaceProtocol, Swift.Equatable {
  public var urn: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var alertMode: Swift.String?
  public var id: NamiPairingFramework.PlaceID
  public var name: Swift.String
  public var timeZone: Swift.String?
  public var propertyTypeId: NamiPairingFramework.PropertyTypeID?
  public var propertyElevationId: NamiPairingFramework.PropertyElevationID?
  public var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID?
  public var petTypeId: NamiPairingFramework.PetTypeID?
  public static func == (a: NamiPairingFramework.PairingPlace, b: NamiPairingFramework.PairingPlace) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PairingPlaceZone : NamiPairingFramework.RemoteTemplateUI_ZoneProtocol, Swift.Equatable {
  public var id: NamiPairingFramework.PlaceZoneID
  public var externalId: Swift.String?
  public var name: Swift.String
  public var urn: Swift.String
  public var alertMode: Swift.String
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.PairingPlaceZone, b: NamiPairingFramework.PairingPlaceZone) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class CodeScannerUIView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_Concurrency.MainActor @preconcurrency public struct CodeScannerView : SwiftUI.UIViewRepresentable {
  public typealias UIViewType = NamiPairingFramework.CodeScannerUIView
  @objc @_hasMissingDesignatedInitializers final public class Coordinator : ObjectiveC.NSObject {
    @objc final public func metadataOutput(_: AVFoundation.AVCaptureMetadataOutput, didOutput metadataObjects: [AVFoundation.AVMetadataObject], from _: AVFoundation.AVCaptureConnection)
    @objc deinit
  }
  @_Concurrency.MainActor @preconcurrency public func makeCoordinator() -> NamiPairingFramework.CodeScannerView.Coordinator
  @_Concurrency.MainActor @preconcurrency public func makeUIView(context: NamiPairingFramework.CodeScannerView.Context) -> NamiPairingFramework.CodeScannerUIView
  @_Concurrency.MainActor @preconcurrency public func updateUIView(_ uiView: NamiPairingFramework.CodeScannerUIView, context _: NamiPairingFramework.CodeScannerView.Context)
  public typealias Body = Swift.Never
}
public enum QRScanner {
  public enum ScanError : Swift.String, Swift.Identifiable {
    case unknownQR
    public var id: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias ID = Swift.String
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct State : Swift.Equatable {
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public var qrCode: NamiPairingFramework.NamiQRCode?
    public var outletType: NamiPairingFramework.NamiOutletType?
    public var kit: NamiPairingFramework.KitCategory?
    public var error: NamiPairingFramework.QRScanner.ScanError?
    public static func == (a: NamiPairingFramework.QRScanner.State, b: NamiPairingFramework.QRScanner.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case reset
    case shouldDismissItself
    case gotData(Swift.String?)
    case dismissScanError
    case pauseScanning
    case scanningUnauthorized
    public static func == (a: NamiPairingFramework.QRScanner.Event, b: NamiPairingFramework.QRScanner.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.QRScannerViewModelProtocol {
    public typealias State = NamiPairingFramework.QRScanner.State
    public typealias Event = NamiPairingFramework.QRScanner.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.QRScanner.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.QRScanner.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public var undecoratedScannerView: NamiPairingFramework.CodeScannerView {
      get
    }
    final public func send(event: NamiPairingFramework.QRScanner.ViewModel.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public struct NamiQRCode : Swift.Equatable {
  public init?(_ string: Swift.String)
  public var discriminator: Swift.Int32
  public static func == (a: NamiPairingFramework.NamiQRCode, b: NamiPairingFramework.NamiQRCode) -> Swift.Bool
}
public struct BluetoothCentralState : Swift.Equatable {
  public var bluetoothState: CoreBluetooth.CBManagerState
  public var authorization: CoreBluetooth.CBManagerAuthorization
  public static func == (a: NamiPairingFramework.BluetoothCentralState, b: NamiPairingFramework.BluetoothCentralState) -> Swift.Bool
}
extension NamiPairingFramework.BluetoothCentralState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
final public class Tomonari<Container> where Container : NamiPairingFramework.PairingStepsContainer {
  public init(api: any NamiPairingFramework.PairingWebAPIProtocol, wifiStorage: any NamiPairingFramework.PairingWiFiStorageProtocol, threadDatasetProvider: any NamiPairingFramework.PairingThreadOperationalDatasetProviderProtocol, deviceConnectionManager: any NamiPairingFramework.DeviceConnectionsManagerProtocol)
  public typealias DevicePairingStatePublisher = Combine.PassthroughSubject<NamiPairingFramework.Tomonari<Container>.DevicePairingState, any Swift.Error>
  public typealias DevicePositioningStatePublisher = Combine.PassthroughSubject<NamiPairingFramework.PositioningStep, any Swift.Error>
  public struct PairingParameters : Swift.Equatable {
    public init(qrCode: NamiPairingFramework.NamiQRCode? = nil, updateWiFiCredentialsSessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID? = nil, bssid: Foundation.Data? = nil)
    public init(qrCode: NamiPairingFramework.NamiQRCode? = nil, updateWiFiCredentialsSessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID? = nil, bssid: [Swift.UInt8])
    public init(qrCode: NamiPairingFramework.NamiQRCode? = nil, updateWiFiCredentialsSessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID? = nil, bssid: Swift.String)
    public static var none: NamiPairingFramework.Tomonari<Container>.PairingParameters {
      get
    }
    public let qrCode: NamiPairingFramework.NamiQRCode?
    public let updateWiFiCredentialsSessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID?
    public let bssid: Foundation.Data?
    public static func == (a: NamiPairingFramework.Tomonari<Container>.PairingParameters, b: NamiPairingFramework.Tomonari<Container>.PairingParameters) -> Swift.Bool
  }
  public enum DevicePairingState {
    case deviceCommisionedAtCloud(NamiPairingFramework.PairingDevice, in: NamiPairingFramework.PlaceID)
    case deviceOperable(NamiPairingFramework.DeviceID, NamiPairingFramework.NamiDeviceType?, ssid: Swift.String?, bssid: [Swift.UInt8]?, positionAdjustmentNeeded: Swift.Bool?)
    case deviceDecommissioned(NamiPairingFramework.DeviceID)
    case pairingCancelled(NamiPairingFramework.Pairing.PairingCancellationdReason)
  }
  final public let devicePairingState: NamiPairingFramework.Tomonari<Container>.DevicePairingStatePublisher
  final public let devicePositioningState: NamiPairingFramework.Tomonari<Container>.DevicePositioningStatePublisher
  final public func startPairing(placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID, roomId: NamiPairingFramework.RoomID, deviceType: NamiPairingFramework.NamiDeviceType = .unknown, pairingParameters: NamiPairingFramework.Tomonari<Container>.PairingParameters = .none, pairingSteps: Container) -> some SwiftUICore.View
  
  final public func startPositioning(deviceName: Swift.String, deviceUid: NamiPairingFramework.DeviceUniversalID, placeId: NamiPairingFramework.PlaceID, pairingSteps: Container, onPositioningEnded: @escaping (NamiPairingFramework.PositioningResult) -> Swift.Void) -> some SwiftUICore.View
  
  @objc deinit
}
extension NamiPairingFramework.NamiDeviceType {
  public func qrCodeImageName(outletType: NamiPairingFramework.NamiOutletType) -> Swift.String
}
extension SwiftUICore.EnvironmentValues {
  public var hideBackButton: Swift.Bool {
    get
    set
  }
}
extension Combine.Publisher {
  public func first<T>(_ keyPath: Swift.KeyPath<Self.Output, T>, toEqual value: T) -> Combine.Publishers.FirstWhere<Combine.Publishers.MapKeyPath<Self, T>> where T : Swift.Equatable
}
public enum PairingMachineState : Swift.Equatable, Swift.CustomDebugStringConvertible, Swift.Identifiable {
  case initial
  case gotAdvertisement(NamiPairingFramework.PublicPairingAdvertisement)
  case sentProverPublicKey
  case sentProverSharedKey
  case establishedSession
  case sentDeviceCertificateRequest
  case gotDeviceCertificateResponse(Swift.String)
  case sentCloudChallenge
  case gotCloudChallengeResponse(Foundation.Data)
  case sentCloudPayload
  case gotCloudChallengeOK
  case sentScanWiFiNetworks
  case gotWiFiNetworks([NamiPairingFramework.PublicWiFiNetwork])
  case sentWiFiCredentials
  case gotWiFiIPAddress(Swift.String)
  case sentScanThreadNetworks
  case gotThreadNetworks([NamiPairingFramework.ThreadScanResult])
  case sentJoinThreadNetwork
  case threadJoinFinished(Foundation.Data)
  case sentHandshakeAck
  public var id: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.PairingMachineState, b: NamiPairingFramework.PairingMachineState) -> Swift.Bool
  public typealias ID = Swift.String
}
public enum PairingMachineError : Swift.Error, Swift.Equatable {
  case unexpectedState
  case unexpectedMessage
  case seanceError(any Swift.Error)
  case pairingError(NamiPairingFramework.PublicPairingError)
  case serializationError(any Swift.Error)
  case deserializationError(any Swift.Error)
  case encryptionError
  case notSupportDeviceType(NamiPairingFramework.NamiDeviceType)
  case connectionTimeOutError
  case bluetoothDisconnectedError(NamiPairingFramework.NamiDeviceType, Swift.Bool)
  public static func == (lhs: NamiPairingFramework.PairingMachineError, rhs: NamiPairingFramework.PairingMachineError) -> Swift.Bool
}
public enum PairingErrorScreen {
  public struct State : Swift.Equatable {
    public var error: NamiPairingFramework.Pairing.Error
    public var actions: [NamiPairingFramework.Pairing.ActionOnError]
    public var chosenAction: NamiPairingFramework.Pairing.ActionOnError?
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public static func == (a: NamiPairingFramework.PairingErrorScreen.State, b: NamiPairingFramework.PairingErrorScreen.State) -> Swift.Bool
  }
  public enum Event {
    case didChooseAction(NamiPairingFramework.Pairing.ActionOnError)
    case reconfigure(NamiPairingFramework.Pairing.Error, [NamiPairingFramework.Pairing.ActionOnError])
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.PairingErrorScreen.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PairingErrorScreen.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PairingErrorScreen.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.PairingErrorScreen.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum BluetoothDeviceFound {
  public struct State : Swift.Equatable {
    public var placeId: NamiPairingFramework.PlaceID
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public var deviceModel: NamiPairingFramework.NamiDeviceModel?
    public var deviceName: Swift.String
    public var deviceNames: [Swift.String]
    public var deviceNameConfirmed: Swift.Bool
    public var renameDevice: Swift.Bool
    public var showDuplicateError: Swift.Bool {
      get
    }
    public static func == (a: NamiPairingFramework.BluetoothDeviceFound.State, b: NamiPairingFramework.BluetoothDeviceFound.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case deviceNameConfirmed
    case gotDeviceNames([Swift.String])
    public static func == (a: NamiPairingFramework.BluetoothDeviceFound.Event, b: NamiPairingFramework.BluetoothDeviceFound.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.BluetoothDeviceFound.State
    public typealias Event = NamiPairingFramework.BluetoothDeviceFound.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.BluetoothDeviceFound.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.BluetoothDeviceFound.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.BluetoothDeviceFound.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum ListWiFiNetworks {
  public struct State {
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public var networks: [NamiPairingFramework.NamiWiFiNetwork]?
    public var selectedNetwork: NamiPairingFramework.NamiWiFiNetwork?
    public var shouldShowBSSIDWarning: Swift.Bool
    public var shouldAskAboutSavedPassword: Swift.Bool
    public var deviceSupportsBSSID: Swift.Bool {
      get
    }
    public var shouldShowProgressView: Swift.Bool {
      get
    }
    public var shouldShowNoNetworksHint: Swift.Bool {
      get
    }
    public var couldShowAddOtherNetwork: Swift.Bool {
      get
    }
    public static func == (a: NamiPairingFramework.ListWiFiNetworks.State, b: NamiPairingFramework.ListWiFiNetworks.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case empty
    case dismissItself
    case tappedConfirmSelection
    case tappedRefreshNetwork
    case tappedOtherNetwork
    case selectNetwork(NamiPairingFramework.NamiWiFiNetwork)
    case selectNetworkAndConfirm(NamiPairingFramework.NamiWiFiNetwork)
    case didTapUsePassword
    case didTapForgetPassword
    case didSearchForSavedPassword(Swift.String?)
    case confirmingSelection
    case shouldAskAboutSavedPassword(Swift.Bool)
    case gotError(NamiPairingFramework.Pairing.Error)
    public static func == (a: NamiPairingFramework.ListWiFiNetworks.Event, b: NamiPairingFramework.ListWiFiNetworks.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.StoredPasswordRetrievingViewModel {
    public typealias State = NamiPairingFramework.ListWiFiNetworks.State
    public typealias Event = NamiPairingFramework.ListWiFiNetworks.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.ListWiFiNetworks.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.ListWiFiNetworks.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.ListWiFiNetworks.ViewModel.Event)
    final public func usePassword()
    final public func forgetPassword()
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum PowerOnAndScanning {
  public struct State : Swift.Equatable {
    public var showsProgressIndicator: Swift.Bool
    public let deviceType: NamiPairingFramework.NamiDeviceType
    public var outletType: NamiPairingFramework.NamiOutletType?
    public var centralState: NamiPairingFramework.BluetoothCentralState
    public static func == (a: NamiPairingFramework.PowerOnAndScanning.State, b: NamiPairingFramework.PowerOnAndScanning.State) -> Swift.Bool
  }
  public enum Event {
    case stopShowingProgress
    case centralDidUpdate(NamiPairingFramework.BluetoothCentralState)
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.PowerOnAndScanning.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PowerOnAndScanning.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PowerOnAndScanning.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.PowerOnAndScanning.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum OtherWiFiNetwork {
  public struct State {
    public var networkName: Swift.String
    public var password: Swift.String
    public var shouldAskAboutSavedPassword: Swift.Bool
    public static func == (a: NamiPairingFramework.OtherWiFiNetwork.State, b: NamiPairingFramework.OtherWiFiNetwork.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case empty
    case didConfirmName
    case lookForSavedPassword
    case shouldAskAboutSavedPassword(Swift.Bool)
    case didTapUsePassword
    case didTapForgetPassword
    case didSearchForSavedPassword(Swift.String?)
    public static func == (a: NamiPairingFramework.OtherWiFiNetwork.Event, b: NamiPairingFramework.OtherWiFiNetwork.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.StoredPasswordRetrievingViewModel {
    public typealias State = NamiPairingFramework.OtherWiFiNetwork.State
    public typealias Event = NamiPairingFramework.OtherWiFiNetwork.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.OtherWiFiNetwork.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.OtherWiFiNetwork.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.OtherWiFiNetwork.ViewModel.Event)
    final public func usePassword()
    final public func forgetPassword()
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum BluetoothUsageHint {
  public struct State : Swift.Equatable {
    public var nextTapped: Swift.Bool
    public static func == (a: NamiPairingFramework.BluetoothUsageHint.State, b: NamiPairingFramework.BluetoothUsageHint.State) -> Swift.Bool
  }
  public enum Event {
    case tapNext
    public static func == (a: NamiPairingFramework.BluetoothUsageHint.Event, b: NamiPairingFramework.BluetoothUsageHint.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.BluetoothUsageHint.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.BluetoothUsageHint.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.BluetoothUsageHint.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.BluetoothUsageHint.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum EnterWiFiPassword {
  public struct State : Swift.Equatable {
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public var password: Swift.String
    public var networkName: Swift.String {
      get
    }
    public static func == (a: NamiPairingFramework.EnterWiFiPassword.State, b: NamiPairingFramework.EnterWiFiPassword.State) -> Swift.Bool
  }
  public enum Event {
    case confirmPassword
    case goBack
    public static func == (a: NamiPairingFramework.EnterWiFiPassword.Event, b: NamiPairingFramework.EnterWiFiPassword.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.EnterWiFiPassword.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.EnterWiFiPassword.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.EnterWiFiPassword.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.EnterWiFiPassword.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum Pairing {
  public struct CloudPayload : NamiPairingFramework.WiredPlaceKeysProtocol {
    public var ciphertext: Swift.String
    public var iv: Swift.String
    public var authTag: Swift.String
    public var serverKey: Swift.String
    public static func == (a: NamiPairingFramework.Pairing.CloudPayload, b: NamiPairingFramework.Pairing.CloudPayload) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct DeviceSetupParameters : Swift.Equatable {
    public static func == (a: NamiPairingFramework.Pairing.DeviceSetupParameters, b: NamiPairingFramework.Pairing.DeviceSetupParameters) -> Swift.Bool
  }
  public enum ConnectTo : Swift.Equatable {
    case thread
    case wifi
    public static func == (a: NamiPairingFramework.Pairing.ConnectTo, b: NamiPairingFramework.Pairing.ConnectTo) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error, Swift.Identifiable, Swift.Equatable {
    case underlying(any Swift.Error)
    public var id: Swift.String {
      get
    }
    public static func == (lhs: NamiPairingFramework.Pairing.Error, rhs: NamiPairingFramework.Pairing.Error) -> Swift.Bool
    public typealias ID = Swift.String
  }
  public enum ThreadError : Swift.Error, Swift.Equatable {
    case threadOperationalDatasetMissing
    case threadNetworkNotFound(zoneName: Swift.String, deviceType: NamiPairingFramework.NamiDeviceType)
    case wifiIsDisconnected
    case noBorderRouter
    case allBorderRoutersOffline
    public static func == (a: NamiPairingFramework.Pairing.ThreadError, b: NamiPairingFramework.Pairing.ThreadError) -> Swift.Bool
  }
  public enum ActionOnError : Swift.Equatable {
    case restart
    case tryAgain
    case ignore
    case exit
    public static func == (a: NamiPairingFramework.Pairing.ActionOnError, b: NamiPairingFramework.Pairing.ActionOnError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PairingCancellationdReason {
    case backButtonCancelled
    case exitPairing
    case restartPairing
    case unknown
    public static func == (a: NamiPairingFramework.Pairing.PairingCancellationdReason, b: NamiPairingFramework.Pairing.PairingCancellationdReason) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Routes : Swift.Equatable {
    case qrCodeScanner(NamiPairingFramework.NamiDeviceType, NamiPairingFramework.NamiOutletType?, NamiPairingFramework.NamiQRCode?)
    case cameraEnableInSettings(NamiPairingFramework.NamiDeviceType)
    case powerOnAndScanning(NamiPairingFramework.NamiDeviceType, NamiPairingFramework.NamiOutletType?)
    case deviceFound(placeId: NamiPairingFramework.PlaceID, deviceType: NamiPairingFramework.NamiDeviceType, deviceModel: NamiPairingFramework.NamiDeviceModel, updateWiFiCredentialsSessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID?, deviceName: Swift.String?)
    case listWiFiNetworks(zoneId: NamiPairingFramework.PlaceZoneID, deviceType: NamiPairingFramework.NamiDeviceType, wifiNetworks: [NamiPairingFramework.NamiWiFiNetwork]?, bssidLookupComplete: Swift.Bool)
    case finishingSetup(NamiPairingFramework.NamiDeviceType)
    public static func == (a: NamiPairingFramework.Pairing.Routes, b: NamiPairingFramework.Pairing.Routes) -> Swift.Bool
  }
  public struct State : Swift.Equatable {
    public var placeId: NamiPairingFramework.PlaceID
    public var zoneId: NamiPairingFramework.PlaceZoneID
    public var roomId: NamiPairingFramework.RoomID
    public var updateWiFiCredentialsSessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID?
    public var deviceName: Swift.String
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public var zoneName: Swift.String? {
      get
    }
    public static func == (a: NamiPairingFramework.Pairing.State, b: NamiPairingFramework.Pairing.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case empty
    case centralDidUpdate(NamiPairingFramework.BluetoothCentralState)
    case pairingMachineDidUpdate(NamiPairingFramework.PairingMachineState)
    case startScanning
    case didStartScanning
    case didResetPairingState
    case stopPresenting
    case gotQRCode(NamiPairingFramework.NamiQRCode)
    case bluetoothHintAcknowledged
    case didInitBluetooth
    case gotDeviceProductId(NamiPairingFramework.DeviceProductID)
    case identifiedModelByProductId(NamiPairingFramework.NamiDeviceModel)
    case setRoute(NamiPairingFramework.Pairing.Routes)
    case shouldContinuePairing
    case didContinuePairing
    case setDeviceName(Swift.String)
    case renameDevice(Swift.String)
    case gotDeviceCertificate(Swift.String)
    case gotPairingChallenge(challenge: Swift.String, model: NamiPairingFramework.NamiDeviceModel)
    case gotDeviceChallengeResponse(Foundation.Data)
    case gotPairDeviceResponseFromCloud(NamiPairingFramework.Pairing.CloudPayload, NamiPairingFramework.PairingDevice)
    case shouldStartScanningWiFi
    case doneSearchingForWiFiUpdateSessionDevices([NamiPairingFramework.DeviceUniversalID])
    case retryScanningWiFi
    case didStartScanningWiFi
    case gotWiFiCredentials(NamiPairingFramework.NamiWiFiNetwork, Swift.String?)
    case didFoundSavedBSSID(Foundation.Data?)
    case bssidNotFound
    case otherNetwork
    case enterPassword(NamiPairingFramework.NamiWiFiNetwork)
    case didSendWiFiCredentials
    case shouldStartScanForThreadNetwork
    case didStartScanForThreadNetwork
    case shouldSendThreadOperationalDataset(Foundation.Data)
    case shouldStartThreadCredentialsRetrieval([NamiPairingFramework.DeviceUniversalID])
    case shouldStartCheckThreadCommissioningConditions
    case didStartCheckThreadCommissioningConditions
    case didIssueThreadCredentialsRetrievalRequest
    case gotThreadCredentials(NamiPairingFramework.ThreadCredentialsMessage)
    case failedToRetreiveThreadCredentials(NamiPairingFramework.DeviceUniversalID)
    case didSentThreadOperationalDataset
    case shouldDismissItself
    case dismissalApproved(NamiPairingFramework.DeviceID?)
    case dismissalWithDeleteApproved(NamiPairingFramework.DeviceID)
    case dismissStackablePresented
    case dismissFullscreenPresented
    case shouldPairAnother
    case gotAPIError(NamiPairingFramework.Pairing.Error)
    case gotPairingMachineError(NamiPairingFramework.PairingMachineError)
    case gotErrorAction(NamiPairingFramework.Pairing.Error, NamiPairingFramework.Pairing.ActionOnError)
    case askTryRescanThreadNetworks
    case notSupportedDeviceTypeError(NamiPairingFramework.NamiDeviceType)
    case pairingCancelled(NamiPairingFramework.Pairing.PairingCancellationdReason)
    case gotPlace(NamiPairingFramework.PairingPlace)
    case gotZones([NamiPairingFramework.PairingPlaceZone])
    case refreshPairingChallange
    case gotTimeZones([NamiPairingFramework.NamiTimeZone])
    case startTimerForConnectionTimeOut
    case stopTimerForConnectionTimeOut
    case connectionTimeOutError
    case bluetoothDisconnected(Swift.Bool)
    case doneRenamingDevice
    case doneDeletingDevice
    case exitPairing
    case updatedWifiReachability(Network.NWPath)
    case noBorderRouterError
    case allBorderRoutersOfflineError
    public static func == (a: NamiPairingFramework.Pairing.Event, b: NamiPairingFramework.Pairing.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel<Container> where Container : NamiPairingFramework.PairingStepsContainer {
    public typealias State = NamiPairingFramework.Pairing.State
    public typealias Event = NamiPairingFramework.Pairing.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.Pairing.ViewModel<Container>.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.Pairing.ViewModel<Container>.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.Pairing.ViewModel<Container>.Event)
    @objc deinit
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  }
}
public protocol PairingStepViewModelProtocol : Combine.ObservableObject {
  associatedtype State : Swift.Equatable
}
public protocol PairingStepEventSendableViewModelProtocol : NamiPairingFramework.PairingStepViewModelProtocol {
  associatedtype Event : Swift.Equatable
  func send(event: Self.Event)
}
public protocol StoredPasswordRetrievingViewModel {
  func usePassword()
  func forgetPassword()
}
public protocol QRScannerViewModelProtocol : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {
  var undecoratedScannerView: NamiPairingFramework.CodeScannerView { get }
}
public protocol PairingStepsContainer {
  associatedtype ViewForPowerOnAndScanning : SwiftUICore.View
  associatedtype ViewForEnableCameraInSettings : SwiftUICore.View
  associatedtype ViewForBluetoothDeviceFound : SwiftUICore.View
  associatedtype ViewForQRCodeScanner : SwiftUICore.View
  associatedtype ViewForListWiFiNetworks : SwiftUICore.View
  associatedtype ViewForOtherWiFiNetwork : SwiftUICore.View
  associatedtype ViewForEnterWiFiPassword : SwiftUICore.View
  associatedtype ViewForFinishingSetup : SwiftUICore.View
  associatedtype ViewForPairingError : SwiftUICore.View
  associatedtype BackButtonView : SwiftUICore.View
  associatedtype ViewForPositioningErrorScreen : SwiftUICore.View
  associatedtype ViewForHowToPosition : SwiftUICore.View
  associatedtype ViewForInitialPositioningScreen : SwiftUICore.View
  associatedtype ViewForPositioningGuidance : SwiftUICore.View
  associatedtype ViewForPositioningComplete : SwiftUICore.View
  var powerOnAndScanning: (NamiPairingFramework.PowerOnAndScanning.ViewModel) -> Self.ViewForPowerOnAndScanning { get }
  var enableCameraInSettings: (_ deviceType: Swift.String) -> Self.ViewForEnableCameraInSettings { get }
  var bluetoothDeviceFound: (NamiPairingFramework.BluetoothDeviceFound.ViewModel) -> Self.ViewForBluetoothDeviceFound { get }
  var qrCodeScanner: (NamiPairingFramework.QRScanner.ViewModel) -> Self.ViewForQRCodeScanner { get }
  var listWiFiNetworks: (NamiPairingFramework.ListWiFiNetworks.ViewModel) -> Self.ViewForListWiFiNetworks { get }
  var otherWiFiNetwork: (NamiPairingFramework.OtherWiFiNetwork.ViewModel) -> Self.ViewForOtherWiFiNetwork { get }
  var enterWiFiPassword: (NamiPairingFramework.EnterWiFiPassword.ViewModel) -> Self.ViewForEnterWiFiPassword { get }
  var finishingSetup: (_ title: Swift.String) -> Self.ViewForFinishingSetup { get }
  var howToPosition: (NamiPairingFramework.HowToPosition.ViewModel) -> Self.ViewForHowToPosition { get }
  var initialPositioningScreen: (NamiPairingFramework.InitialScreen.ViewModel) -> Self.ViewForInitialPositioningScreen { get }
  var positioningGuidance: (NamiPairingFramework.PositioningGuidance.ViewModel) -> Self.ViewForPositioningGuidance { get }
  var positioningComplete: (NamiPairingFramework.PositioningComplete.ViewModel) -> Self.ViewForPositioningComplete { get }
  var pairingError: (NamiPairingFramework.PairingErrorScreen.ViewModel) -> Self.ViewForPairingError { get }
  var positionError: (NamiPairingFramework.ErrorScreen.ViewModel) -> Self.ViewForPositioningErrorScreen { get }
  var backButton: () -> Self.BackButtonView? { get }
}
extension NamiPairingFramework.PairingStepsContainer {
  public var backButton: () -> NamiPairingFramework.NoView? {
    get
  }
}
@_Concurrency.MainActor @preconcurrency public struct NoView : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework6NoViewV4bodyQrvp", 0) __
}
public protocol PairingThreadOperationalDatasetProviderProtocol {
  associatedtype Pairing_NamiThreadOperationalDataset : NamiPairingFramework.PairingNamiThreadOperationalDatasetProtocol
  func newRandomDataset(networkName: Swift.String?) -> Self.Pairing_NamiThreadOperationalDataset
  func retrieve(placeId: NamiPairingFramework.PlaceID) -> Self.Pairing_NamiThreadOperationalDataset?
  func removeDataset(for placeId: NamiPairingFramework.PlaceID)
  func storeDataset(_ dataset: Foundation.Data, for placeId: NamiPairingFramework.PlaceID)
  func storeDataset(_ dataset: Self.Pairing_NamiThreadOperationalDataset, for placeId: NamiPairingFramework.PlaceID)
}
public protocol PairingNamiThreadOperationalDatasetProtocol : Swift.Decodable, Swift.Encodable {
  var data: Foundation.Data { get }
  func equalsNumericalPanID<ID>(_ panId: ID) -> Swift.Bool where ID : Swift.FixedWidthInteger
}
public protocol StateWithRoute : Swift.Equatable {
  associatedtype Route : Swift.Equatable
  var route: Self.Route? { get set }
}
public protocol WiDarPositioningViewModelProtocol : Combine.ObservableObject {
  associatedtype State : Swift.Equatable
}
public protocol WiDarPositioningEventSendableViewModelProtocol : NamiPairingFramework.WiDarPositioningViewModelProtocol {
  associatedtype Event : Swift.Equatable
  func send(_ event: Self.Event)
}
public protocol WiDarPositioningRoutBindableViewModelProtocol : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol where Self.State : NamiPairingFramework.StateWithRoute {
  func onRouteChange(_ event: Self.Event) -> SwiftUICore.Binding<Self.State.Route?>
}
extension NamiPairingFramework.WiDarPositioningRoutBindableViewModelProtocol {
  public func binding(route: Self.State.Route?, event: Self.Event) -> SwiftUICore.Binding<Self.State.Route?>
}
public protocol PairingNetworkError : Swift.Error {
  var localizedDescription: Swift.String { get }
}
public protocol PairingWiFiStorageProtocol {
  func save(password: Swift.String?, for networkSSID: Swift.String)
  func password(for networkSSID: Swift.String) -> Swift.String?
  func removeAll()
}
public typealias PortableTypedCache = NamiPairingFramework.TypedCache
final public class TypedCache {
  public init()
  final public func retrieve<Element>(_ type: Element.Type, toInit: (inout Swift.Set<Combine.AnyCancellable>) -> Element) -> Element where Element : AnyObject
  final public func replace<Element>(_ type: Element.Type, toInit: (inout Swift.Set<Combine.AnyCancellable>) -> Element) -> Element where Element : AnyObject
  final public func delete<Element>(_ type: Element.Type) where Element : AnyObject
  @objc deinit
}
public class TemplatesVariablesBridge : Swift.AnyObject {
  public init(initial: [Swift.String : Swift.AnyHashable], onUpsert: @escaping (_ name: Swift.String, _ newValue: Swift.AnyHashable) -> Swift.Void)
  public func setNewValueInTemplate(_ name: Swift.String, _ newValue: Swift.AnyHashable)
  public func setNewVariablesDictionaryInTemplate(_ newValues: [Swift.String : Swift.AnyHashable])
  public func getValue<T>(name: Swift.String) -> T?
  @objc deinit
}




public struct PresentedScreen : Swift.Sendable {
  public init(url: Foundation.URL, title: Swift.String? = nil, backButtonEnabled: Swift.Bool = true)
}


public enum SDUIPresenterError : Swift.Error {
  case alreadyPresented([NamiPairingFramework.PresentedScreen])
}
final public class NamiSDUIPresenter : Foundation.ObservableObject {
  @usableFromInline
  internal static func defaultOnLoadError(_ error: any Swift.Error)
  @usableFromInline
  internal static func mapUrl(_ url: Foundation.URL) -> NamiPairingFramework.PresentedScreen
  public enum PresentationUpdate {
    case replaceByUrl(NamiPairingFramework.PresentedScreen)
    case replaceByIndex(Swift.Int, NamiPairingFramework.PresentedScreen)
    case replaceTopmost(NamiPairingFramework.PresentedScreen)
    case replaceStack([NamiPairingFramework.PresentedScreen])
    case pushOnStack(NamiPairingFramework.PresentedScreen)
  }
  public init(variablesBridge: NamiPairingFramework.TemplatesVariablesBridge, onLoadError: @escaping (any Swift.Error) -> Swift.Void = NamiSDUIPresenter.defaultOnLoadError, mapUrl: @escaping (Foundation.URL) -> NamiPairingFramework.PresentedScreen? = NamiSDUIPresenter.mapUrl)
  @_Concurrency.MainActor final public func present(_ screens: NamiPairingFramework.PresentedScreen..., onDismiss: @escaping () -> Swift.Void = {}) throws -> some SwiftUICore.View
  
  @_Concurrency.MainActor final public func updatePresentedScreens(with mutation: NamiPairingFramework.NamiSDUIPresenter.PresentationUpdate)
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
extension UIKit.UINavigationController : @retroactive UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func gestureRecognizerShouldBegin(_: UIKit.UIGestureRecognizer) -> Swift.Bool
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func allowSwipeBackNavigation(_ isAllowed: Swift.Bool) -> some SwiftUICore.View
  
}
extension SwiftUICore.Text {
  public init(_ content: any Swift.StringProtocol, font: NamiPairingFramework.NamiTextStyle)
  public init(_ content: any Swift.StringProtocol, font: SwiftUICore.Font)
  public func fillWidth(_ width: CoreFoundation.CGFloat = .infinity, alignment: SwiftUICore.Alignment = .leading) -> some SwiftUICore.View
  
}
public var statusbarAndNavbarShift: CoreFoundation.CGFloat {
  get
}
public var statusbarShift: CoreFoundation.CGFloat {
  get
}
public var navbarBackgroundViewHeight: CoreFoundation.CGFloat {
  get
}
public var navbarContentViewHeight: CoreFoundation.CGFloat {
  get
}
public var screenWidth: CoreFoundation.CGFloat {
  get
}
public var firstKeyWindow: UIKit.UIWindow?
public var defaultNavbarHeight: CoreFoundation.CGFloat
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func navigationPopGestureDisabled(_ disabled: Swift.Bool) -> some SwiftUICore.View
  
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func onHeightUpdate(_ action: @escaping (CoreFoundation.CGFloat) -> Swift.Void) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func readSize(onChange: @escaping (CoreFoundation.CGSize) -> Swift.Void) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func readSafeAreaInsets(onChange: @escaping (SwiftUICore.EdgeInsets) -> Swift.Void) -> some SwiftUICore.View
  
}
extension SwiftUICore.Color {
  public init(hex: Swift.UInt, alpha: Swift.Double = 1.0)
  public static var namiColors: NamiPairingFramework.Colors
  public static var systemBackground: SwiftUICore.Color {
    get
  }
  public static var textLabel: SwiftUICore.Color {
    get
  }
  public static var invertedTextLabel: SwiftUICore.Color {
    get
  }
  public static var tint: SwiftUICore.Color {
    get
  }
}
extension UIKit.UIFont {
  public class func preferredFont(from font: SwiftUICore.Font) -> UIKit.UIFont
  public class func convertToUIFontCustom(_ font: SwiftUICore.Font) -> UIKit.UIFont
}
public struct ColorsKey : SwiftUICore.EnvironmentKey {
  public static let defaultValue: NamiPairingFramework.Colors
  public typealias Value = NamiPairingFramework.Colors
}
extension SwiftUICore.EnvironmentValues {
  public var colors: NamiPairingFramework.Colors {
    get
    set
  }
}
@_Concurrency.MainActor @preconcurrency public struct RoundedRectContainerView<Subviews> : SwiftUICore.View where Subviews : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(spacing: CoreFoundation.CGFloat? = nil, cornerRadius: CoreFoundation.CGFloat = 16.0, excludingCorners: UIKit.UIRectCorner = [], shadowRadius: CoreFoundation.CGFloat? = nil, strokeWidth: CoreFoundation.CGFloat? = nil, strokeColor: SwiftUICore.Color = Color.primary, backgroundColor: SwiftUICore.Color = Color(UIColor.systemBackground), alignment: SwiftUICore.Alignment? = .center, @SwiftUICore.ViewBuilder subviews: () -> Subviews)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework24RoundedRectContainerViewV4bodyQrvp", 0) __<Subviews>
}
@_Concurrency.MainActor @preconcurrency public struct NamiXMarkButton : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(appearance: NamiPairingFramework.NamiXMarkButton.Appearance = .regular, diameter: CoreFoundation.CGFloat = 60, onTap: @escaping () -> Swift.Void)
  public enum Appearance {
    case regular
    case inverted
    public static func == (a: NamiPairingFramework.NamiXMarkButton.Appearance, b: NamiPairingFramework.NamiXMarkButton.Appearance) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A11XMarkButtonV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiNavBackButton : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public var action: () -> Swift.Void
  @_Concurrency.MainActor @preconcurrency public init()
  @_Concurrency.MainActor @preconcurrency public init(action: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A13NavBackButtonV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiCircularXMarkButton : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(appearance: NamiPairingFramework.NamiCircularXMarkButton.Appearance = .regular, diameter: CoreFoundation.CGFloat = 60, onTap: @escaping () -> Swift.Void)
  public enum Appearance {
    case regular
    case inverted
    public static func == (a: NamiPairingFramework.NamiCircularXMarkButton.Appearance, b: NamiPairingFramework.NamiCircularXMarkButton.Appearance) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A19CircularXMarkButtonV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiPageIndexIndicatorView : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(numberOfPages: Swift.Int, currentIndex: Swift.Int, activeColor: SwiftUICore.Color = Color.gray, inactiveColor: SwiftUICore.Color = Color.gray.opacity(0.5), heightOfIndicator: CoreFoundation.CGFloat = 16, spacingOfIndicator: CoreFoundation.CGFloat = 12)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A22PageIndexIndicatorViewV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct TextFieldView : SwiftUI.UIViewRepresentable {
  @_Concurrency.MainActor @preconcurrency public init(placeholder: Swift.String, text: SwiftUICore.Binding<Swift.String>, isEditing: SwiftUICore.Binding<Swift.Bool>, returnKeyType: UIKit.UIReturnKeyType = .default, textColor: UIKit.UIColor? = nil, font: UIKit.UIFont? = nil)
  @objc final public class Coordinator : ObjectiveC.NSObject {
    public init(text: SwiftUICore.Binding<Swift.String>, isEditing: SwiftUICore.Binding<Swift.Bool>, showsPassword: SwiftUICore.Binding<Swift.Bool>, showImageName: Swift.String, hideImageName: Swift.String)
    @objc deinit
  }
  @_Concurrency.MainActor @preconcurrency public static func dismantleUIView(_ uiView: UIKit.UITextField, coordinator: NamiPairingFramework.TextFieldView.Coordinator)
  @_Concurrency.MainActor @preconcurrency public func makeCoordinator() -> NamiPairingFramework.TextFieldView.Coordinator
  @_Concurrency.MainActor @preconcurrency public func makeUIView(context: NamiPairingFramework.TextFieldView.Context) -> UIKit.UITextField
  @_Concurrency.MainActor @preconcurrency public func updateUIView(_ textField: UIKit.UITextField, context: NamiPairingFramework.TextFieldView.Context)
  public typealias Body = Swift.Never
  public typealias UIViewType = UIKit.UITextField
}
extension NamiPairingFramework.TextFieldView.Coordinator : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldDidBeginEditing(_: UIKit.UITextField)
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldDidEndEditing(_: UIKit.UITextField)
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
}
public enum NamiTextFieldStyle {
  case neutral
  case positive
  case negative
  public static func == (a: NamiPairingFramework.NamiTextFieldStyle, b: NamiPairingFramework.NamiTextFieldStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_Concurrency.MainActor @preconcurrency public struct NamiTextField : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(placeholder: Swift.String, text: SwiftUICore.Binding<Swift.String>, isEditing: SwiftUICore.Binding<Swift.Bool>? = nil, returnKeyType: UIKit.UIReturnKeyType = .default, textFieldFont: SwiftUICore.Font? = nil, subTextFont: SwiftUICore.Font? = nil, textColor: SwiftUICore.Color? = nil, maxLength: Swift.Int? = nil)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A9TextFieldV4bodyQrvp", 0) __
}
extension NamiPairingFramework.NamiTextField {
  @_Concurrency.MainActor @preconcurrency public func style(_ style: NamiPairingFramework.NamiTextFieldStyle) -> NamiPairingFramework.NamiTextField
  @_Concurrency.MainActor @preconcurrency public func subText(_ subText: Swift.String?) -> NamiPairingFramework.NamiTextField
  @_Concurrency.MainActor @preconcurrency public func secureTextEntry(_ secure: Swift.Bool) -> NamiPairingFramework.NamiTextField
}
@_Concurrency.MainActor @preconcurrency public struct NamiErrorChatBubble : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(_ text: Swift.String)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A15ErrorChatBubbleV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiChatBubble : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(_ text: Swift.String)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A10ChatBubbleV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiTopNavigationScreen<LeadingGroup, TrailingGroup, BottomGroup, NotificationArea, Subviews, MainContent> : SwiftUICore.View where LeadingGroup : SwiftUICore.View, TrailingGroup : SwiftUICore.View, BottomGroup : SwiftUICore.View, NotificationArea : SwiftUICore.View, Subviews : SwiftUICore.View, MainContent : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(title: Swift.String? = nil, largeTitle: Swift.String? = nil, themeId: NamiPairingFramework.ThemeID = 0, colorOverride: SwiftUICore.Color? = nil, statusbarColorOverride: SwiftUICore.Color? = nil, backgroundOverride: SwiftUICore.Color? = nil, navbarBackgroundBleed: CoreFoundation.CGFloat = 0, contentBehavior: SwiftUICore.Binding<NamiPairingFramework.ContentBehavior>? = nil, @SwiftUICore.ViewBuilder mainContent: @escaping () -> MainContent = { EmptyView() }, @SwiftUICore.ViewBuilder leadingButtonsGroup: @escaping () -> LeadingGroup = { EmptyView() }, @SwiftUICore.ViewBuilder trailingButtonsGroup: @escaping () -> TrailingGroup = { EmptyView() }, @SwiftUICore.ViewBuilder notificationAreaView: @escaping () -> NotificationArea = { EmptyView() }, @SwiftUICore.ViewBuilder additionalViews: @escaping () -> Subviews = { EmptyView() }, @SwiftUICore.ViewBuilder bottomButtonsGroup: @escaping () -> BottomGroup = { EmptyView() })
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A19TopNavigationScreenV4bodyQrvp", 0) __<LeadingGroup, TrailingGroup, BottomGroup, NotificationArea, Subviews, MainContent>
}
public enum ContentBehavior {
  case scrollable(onScroll: (CoreFoundation.CGFloat) -> Swift.Void, scrollDisabled: SwiftUICore.Binding<Swift.Bool>? = nil, scrollHeight: SwiftUICore.Binding<CoreFoundation.CGFloat>? = nil)
  case fixed
  public static var scrollable: NamiPairingFramework.ContentBehavior {
    get
  }
}
extension NamiPairingFramework.ContentBehavior : Swift.Equatable {
  public static func == (lhs: NamiPairingFramework.ContentBehavior, rhs: NamiPairingFramework.ContentBehavior) -> Swift.Bool
}
@_Concurrency.MainActor @preconcurrency public struct LottieAnimationView : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(animation: Swift.KeyPath<NamiPairingFramework.Animations, Lottie.LottieAnimation>, loopMode: Lottie.LottieLoopMode = .loop)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework19LottieAnimationViewV4bodyQrvp", 0) __
}
public typealias LottieAnimations = NamiPairingFramework.Animations
public struct LottieAnimationsKey : SwiftUICore.EnvironmentKey {
  public static let defaultValue: NamiPairingFramework.LottieAnimations
  public typealias Value = NamiPairingFramework.LottieAnimations
}
@_Concurrency.MainActor @preconcurrency public struct CircleButton : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init()
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework12CircleButtonV4bodyQrvp", 0) __
}
public struct NamiTextStyle : Swift.Identifiable {
  public enum Leading {
    case loose
    case tight
    case standard
    public init?(rawValue: SwiftUICore.Font.Leading)
    public static func == (a: NamiPairingFramework.NamiTextStyle.Leading, b: NamiPairingFramework.NamiTextStyle.Leading) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let headline: NamiPairingFramework.NamiTextStyle
  public static let headline2: NamiPairingFramework.NamiTextStyle
  public static let headline3: NamiPairingFramework.NamiTextStyle
  public static let headline4: NamiPairingFramework.NamiTextStyle
  public static let headline5: NamiPairingFramework.NamiTextStyle
  public static let headline6: NamiPairingFramework.NamiTextStyle
  public static let paragraph1: NamiPairingFramework.NamiTextStyle
  public static let paragraph2: NamiPairingFramework.NamiTextStyle
  public static let small: NamiPairingFramework.NamiTextStyle
  public static let small2: NamiPairingFramework.NamiTextStyle
  public let id: Swift.String
  public var font: SwiftUICore.Font {
    get
  }
  public var uiFont: UIKit.UIFont {
    get
  }
  public typealias ID = Swift.String
}
@available(iOS 15, *)
@_Concurrency.MainActor @preconcurrency public struct NamiTextHyperLink : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(content: Foundation.AttributedString)
  @_Concurrency.MainActor @preconcurrency public init(text: Swift.String, link: Swift.String, linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil)
  @_Concurrency.MainActor @preconcurrency public init(markdownString: Swift.String, linkTexts: Swift.String..., linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil)
  @_Concurrency.MainActor @preconcurrency public init(markdownString: Swift.String, linkTexts: [Swift.String], linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil)
  @_Concurrency.MainActor @preconcurrency public init(content: Swift.String, textsAndLinks: [(Swift.String, Swift.String)], linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @available(iOS 15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A13TextHyperLinkV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiTextHyperLinkLegacy : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(text: Swift.String, link: Swift.String, linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A19TextHyperLinkLegacyV4bodyQrvp", 0) __
}
public enum NamiTextHyperLinkHelpers {
  public static func hyperLink(text: Swift.String, link: Swift.String, linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil) -> some SwiftUICore.View
  
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func dynamicBottomSheet<SheetContent>(isPresented: SwiftUICore.Binding<Swift.Bool>, dragIndicatorVisible: Swift.Bool = false, onDismiss: SwiftUICore.Binding<(() -> Swift.Void)?>, backgroundColor: SwiftUICore.Binding<SwiftUICore.Color> = .constant(.white), @SwiftUICore.ViewBuilder content: @escaping () -> SheetContent) -> some SwiftUICore.View where SheetContent : SwiftUICore.View
  
}
@_Concurrency.MainActor @preconcurrency public struct NotificationButtonStyle : SwiftUI.ButtonStyle {
  @_Concurrency.MainActor @preconcurrency public init(color: SwiftUICore.Color = Color(hex: 0xEAEAEA))
  @_Concurrency.MainActor @preconcurrency public struct NotificationButton : SwiftUICore.View {
    @_Concurrency.MainActor @preconcurrency public init(configuration: NamiPairingFramework.NotificationButtonStyle.Configuration, color: SwiftUICore.Color)
    @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
      get
    }
    public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework23NotificationButtonStyleV0dE0V4bodyQrvp", 0) __
  }
  @_Concurrency.MainActor @preconcurrency public func makeBody(configuration: NamiPairingFramework.NotificationButtonStyle.Configuration) -> some SwiftUICore.View
  
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework23NotificationButtonStyleV8makeBody13configurationQr7SwiftUI0eF13ConfigurationV_tF", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiAuthButtonStyle : SwiftUI.ButtonStyle {
  @_Concurrency.MainActor @preconcurrency public init(mode: NamiPairingFramework.NamiAuthButtonStyle.AppearanceColorMode = .light)
  @_Concurrency.MainActor @preconcurrency public struct NamiAuthButton : SwiftUICore.View {
    @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
      get
    }
    public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A15AuthButtonStyleV0adE0V4bodyQrvp", 0) __
  }
  public enum AppearanceColorMode {
    case light
    case dark
    public static func == (a: NamiPairingFramework.NamiAuthButtonStyle.AppearanceColorMode, b: NamiPairingFramework.NamiAuthButtonStyle.AppearanceColorMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public func makeBody(configuration: NamiPairingFramework.NamiAuthButtonStyle.Configuration) -> some SwiftUICore.View
  
  public struct ConstraintLayout {
    public static let LeadingToSuperView: CoreFoundation.CGFloat
    public static let TrailingToSuperView: CoreFoundation.CGFloat
    public static let BottomToSuperView: CoreFoundation.CGFloat
    public static let BottomToNextButton: CoreFoundation.CGFloat
    public static let BottomTokeyboard: CoreFoundation.CGFloat
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A15AuthButtonStyleV8makeBody13configurationQr7SwiftUI0eF13ConfigurationV_tF", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiActionButtonStyle : SwiftUI.ButtonStyle {
  @_Concurrency.MainActor @preconcurrency public init(rank: NamiPairingFramework.NamiActionButtonStyle.AppearanceHierarchyRank = .primary, sharpCorner: UIKit.UIRectCorner = .topRight)
  @_Concurrency.MainActor @preconcurrency public struct NamiActionButton : SwiftUICore.View {
    @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
      get
    }
    public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A17ActionButtonStyleV0adE0V4bodyQrvp", 0) __
  }
  public enum AppearanceHierarchyRank {
    case primary
    case secondary
    case tertiary
    case destructive
    public static func == (a: NamiPairingFramework.NamiActionButtonStyle.AppearanceHierarchyRank, b: NamiPairingFramework.NamiActionButtonStyle.AppearanceHierarchyRank) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public func makeBody(configuration: NamiPairingFramework.NamiActionButtonStyle.Configuration) -> some SwiftUICore.View
  
  public struct ConstraintLayout {
    public static let LeadingToSuperView: CoreFoundation.CGFloat
    public static let TrailingToSuperView: CoreFoundation.CGFloat
    public static let BottomToSuperView: CoreFoundation.CGFloat
    public static let BottomToNextButton: CoreFoundation.CGFloat
    public static let BottomTokeyboard: CoreFoundation.CGFloat
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A17ActionButtonStyleV8makeBody13configurationQr7SwiftUI0eF13ConfigurationV_tF", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct ScrollViewWithOnScrollAction<Subviews> : SwiftUICore.View where Subviews : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(onScroll action: @escaping (CoreFoundation.CGFloat) -> Swift.Void = { _ in }, scrollDisabled: SwiftUICore.Binding<Swift.Bool>? = nil, @SwiftUICore.ViewBuilder subviews: () -> Subviews)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework016ScrollViewWithOnD6ActionV4bodyQrvp", 0) __<Subviews>
}
public struct RemoteTemplateEntrypointHelper {
  public init(config: any NamiPairingFramework.RemoteTemplateUIConfigProtocol)
}
extension NamiPairingFramework.NamiDeviceType : @unchecked @retroactive Swift.Sendable {
}
extension NamiPairingFramework.StateMessage : @retroactive Swift.Equatable, @retroactive Swift.Hashable, @retroactive Swift.Encodable {
  public static func == (lhs: NamiPairingFramework.StateMessage, rhs: NamiPairingFramework.StateMessage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension NamiPairingFramework.SecureStorage : NamiPairingFramework.SecureStorageProtocol, @retroactive NamiPairingFramework.ThreadSecureStorageProtocol {
  public typealias SecureStorageError = NamiPairingFramework.KeychainError
  public typealias Thread_SecureStorageError = NamiPairingFramework.KeychainError
}
@_hasMissingDesignatedInitializers public class SetupGuideInputs : Swift.Encodable, @unchecked Swift.Sendable {
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public struct SetupGuideState : Swift.Encodable, @unchecked Swift.Sendable, Swift.Equatable {
  public static func == (lhs: NamiPairingFramework.SetupGuideState, rhs: NamiPairingFramework.SetupGuideState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum SetupGuideError : Swift.Error, NamiPairingFramework.RemoteTemplatesUIControllerError {
  case api(any Swift.Error)
  case storage(any Swift.Error)
  case deviceConnections(any Swift.Error)
  case divKit(any Swift.Error)
  case invalidState((any Swift.Error)?)
}
public typealias OnPairingFinishedCallback = (NamiPairingFramework.PairingResultStatus) -> Swift.Void
public enum SetupGuideEvent : NamiPairingFramework.RemoteTemplatesUIControllerEvent {
  case gotUrl(Foundation.URL)
  case variableUpdated(Swift.String, Swift.AnyHashable)
  case viewDismissed
  case pairingRequested(NamiPairingFramework.PlaceID, NamiPairingFramework.PlaceZoneID, NamiPairingFramework.RoomID, NamiPairingFramework.NamiDeviceType, NamiPairingFramework.OnPairingFinishedCallback)
}
public enum PairingResultStatus {
  case succeeded(NamiPairingFramework.DeviceID)
  case cancelled(NamiPairingFramework.DeviceID?)
}
final public class RemoteTemplateUIController<Storage> : @preconcurrency NamiPairingFramework.RemoteTemplatesUIControllerProtocol, @unchecked Swift.Sendable where Storage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol, Storage : NamiPairingFramework.RemoteTemplateStateRepositoryProtocol {
  @_Concurrency.MainActor public init(store: Storage, deviceConnectionsManager: any NamiPairingFramework.DeviceConnectionsManagerProtocol)
  final public let eventsPublisher: Combine.PassthroughSubject<NamiPairingFramework.SetupGuideEvent, NamiPairingFramework.SetupGuideError>
  @_Concurrency.MainActor final public func present(entrypoint: some RemoteTemplateEntrypointProtocol, placeId: NamiPairingFramework.PlaceID, config: any NamiPairingFramework.RemoteTemplateUIConfigProtocol) -> SwiftUICore.AnyView
  public typealias Error = NamiPairingFramework.SetupGuideError
  public typealias Event = NamiPairingFramework.SetupGuideEvent
  public typealias TemplatesView = SwiftUICore.AnyView
  @objc deinit
}
public class Animations {
  public init()
  public var lookout24Logo: Lottie.LottieAnimation! {
    get
  }
  public var emptyPlaceState: Lottie.LottieAnimation! {
    get
  }
  public var widarPositioningRec: Lottie.LottieAnimation! {
    get
  }
  public var widarPositioningExample: Lottie.LottieAnimation! {
    get
  }
  public var widarPositioningOptimised: Lottie.LottieAnimation! {
    get
  }
  public var widarPositioningDone: Lottie.LottieAnimation! {
    get
  }
  public var alarmPodPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var sensePlugDEPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var sensePlugFRPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var sensePlugUKPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var sensePlugUSPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var widarPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var wifiSensorDEPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var wifiSensorFRPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var wifiSensorJPPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var wifiSensorUKPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var wifiSensorUSPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var contactSensorPulsingDarkBlue: Lottie.LottieAnimation! {
    get
  }
  public var doorSensorPulseWhite: Lottie.LottieAnimation! {
    get
  }
  public var keypadPulseWhite: Lottie.LottieAnimation! {
    get
  }
  public var motionSensorPulseWhite: Lottie.LottieAnimation! {
    get
  }
  public var zoneGuide1ExpandZone: Lottie.LottieAnimation! {
    get
  }
  public var zoneGuide2CreateNewZone: Lottie.LottieAnimation! {
    get
  }
  public var zoneGuide3Secure2ndFloor: Lottie.LottieAnimation! {
    get
  }
  public var bssFirstKitZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  public var bssNonFirstKitOneFloorZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  public var bssNonFirstKitMultiFloorZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  public var hmsFirstKitZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  public var hmsNonFirstKitOneFloorZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  public var hmsNonFirstKitMultiFloorZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  public var planDevicePlacementNonFirstHasBRMetric: Lottie.LottieAnimation! {
    get
  }
  public var planDevicePlacementNonFirstHasBRImperial: Lottie.LottieAnimation! {
    get
  }
  public var bssFirstKitSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  public var bssNonFirstKitNoBRSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  public var bssNonFirstKitHasBRSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  public var hmsFirstKitSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  public var hmsNonFirstKitNoBRSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  public var hmsNonFirstKitHasBRSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  @objc deinit
}
extension UIKit.UIImage {
  public enum AnimatableImageFormat : Swift.String {
    case gif
    case webP
    public init?(rawValue: Swift.String)
    @available(iOS 2.0, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public enum DeviceImages {
  public static func image(for codeName: Swift.String) -> NamiPairingFramework.AnimatableImageView
  public static func image(for model: NamiPairingFramework.NamiDeviceModel) -> NamiPairingFramework.AnimatableImageView
}
public enum DeviceQRCodeLocationImages {
  public static func qrCodeLocationImage(for name: Swift.String) -> NamiPairingFramework.AnimatableImageView
}
extension SwiftUICore.Image {
  public static func webp(_ name: Swift.String) -> SwiftUICore.Image
  public static func webp(_ name: Swift.String, in bundle: Foundation.Bundle) -> SwiftUICore.Image
}
@_Concurrency.MainActor @preconcurrency public struct AnimatableImageView : SwiftUI.UIViewRepresentable {
  @_Concurrency.MainActor @preconcurrency public init?(webP: Swift.String, in bundle: Foundation.Bundle)
  @_Concurrency.MainActor @preconcurrency public init(uiImage: UIKit.UIImage)
  @_Concurrency.MainActor @preconcurrency public func makeUIView(context: NamiPairingFramework.AnimatableImageView.Context) -> UIKit.UIImageView
  @_Concurrency.MainActor @preconcurrency public func updateUIView(_ uiView: UIKit.UIImageView, context: NamiPairingFramework.AnimatableImageView.Context)
  @_Concurrency.MainActor @preconcurrency public func resizable() -> some SwiftUICore.View
  
  public typealias Body = Swift.Never
  public typealias Coordinator = Swift.Void
  public typealias UIViewType = UIKit.UIImageView
}
public class Colors {
  public init()
  public enum ColorSaturation : Swift.String {
    case lite
    case normal
    case saturated
    case striking
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ColorSaturationNumber : Swift.Int {
    case saturation30
    case saturation40
    case saturation50
    case saturation60
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public struct Neutral {
    public let primaryBlack: SwiftUICore.Color
    public let primaryBlackDisabled: SwiftUICore.Color
    public let secondaryBlack: SwiftUICore.Color
    public let tertiaryBlack: SwiftUICore.Color
    public let gradientGray: SwiftUICore.Color
    public let white: SwiftUICore.Color
    public let whiteDisabled: SwiftUICore.Color
    public let background: SwiftUICore.Color
    public let line: SwiftUICore.Color
    public let shadow: SwiftUICore.Color
  }
  public struct Text {
    public let disabledText: SwiftUICore.Color
    public let dangerPrimary: SwiftUICore.Color
    public let dangerContrast: SwiftUICore.Color
  }
  public struct Graph {
    public let noData: SwiftUICore.Color
    public let movement: SwiftUICore.Color
    public let noMovement: SwiftUICore.Color
    public let occupied: SwiftUICore.Color
    public let notOccupied: SwiftUICore.Color
    public let notHealthy: SwiftUICore.Color
    public let healthy: SwiftUICore.Color
    public let rest: SwiftUICore.Color
    public let notRest: SwiftUICore.Color
  }
  public struct DataRepresentations {
    public static func maroon(_ intensity: NamiPairingFramework.Colors.ColorSaturationNumber) -> SwiftUICore.Color
    public static func maroon(_ intensity: NamiPairingFramework.Colors.ColorSaturation) -> SwiftUICore.Color
    public static func arctic(_ intensity: NamiPairingFramework.Colors.ColorSaturationNumber) -> SwiftUICore.Color
    public static func arctic(_ intensity: NamiPairingFramework.Colors.ColorSaturation) -> SwiftUICore.Color
  }
  public static let allThemes: [NamiPairingFramework.ThemeID]
  final public let accent: SwiftUICore.Color
  final public let headline: SwiftUICore.Color
  final public let linkText: SwiftUICore.Color
  final public let negative: SwiftUICore.Color
  final public let warning: SwiftUICore.Color
  final public let warningLight: SwiftUICore.Color
  final public let positive: SwiftUICore.Color
  final public let allGood: SwiftUICore.Color
  final public let placeholder: SwiftUICore.Color
  final public let authButtonStroke: SwiftUICore.Color
  final public let buttonedFieldBackground: SwiftUICore.Color
  final public let buttonedFieldStroke: SwiftUICore.Color
  final public let progressSelected: SwiftUICore.Color
  final public let lowAttentionAlert: SwiftUICore.Color
  final public let lowAttentionAlertLight: SwiftUICore.Color
  final public let alert1: SwiftUICore.Color
  final public let alert2: SwiftUICore.Color
  final public let redAlert3: SwiftUICore.Color
  final public let redAlert4: SwiftUICore.Color
  final public let success3: SwiftUICore.Color
  final public let success4: SwiftUICore.Color
  final public let snackbarBackground: SwiftUICore.Color
  final public let neutral: NamiPairingFramework.Colors.Neutral
  final public let text: NamiPairingFramework.Colors.Text
  final public let graph: NamiPairingFramework.Colors.Graph
  public var globalBlue: SwiftUICore.Color {
    get
  }
  final public let warningAlert: SwiftUICore.Color
  public var alert0: SwiftUICore.Color {
    get
  }
  public var alert3: SwiftUICore.Color {
    get
  }
  public var bodyText: SwiftUICore.Color {
    get
  }
  public var darkText: SwiftUICore.Color {
    get
  }
  public var primary: SwiftUICore.Color {
    get
  }
  public var lowerBackground: SwiftUICore.Color {
    get
  }
  public var borderStroke: SwiftUICore.Color {
    get
  }
  public var graphLines: SwiftUICore.Color {
    get
  }
  public var profileTileBackground: SwiftUICore.Color {
    get
  }
  public func forTheme(_ base: NamiPairingFramework.ThemeID, saturation: NamiPairingFramework.Colors.ColorSaturation = .normal) -> SwiftUICore.Color
  @objc deinit
}
public struct URLLinks {
  public static let FAQNotPulsingBlue: Swift.String
  public static let FAQNamiThreadTopology: Swift.String
  public static let FAQNotConnectToThread: Swift.String
}
extension Lottie.LottieAnimation {
  final public func animationView(looping: Lottie.LottieLoopMode = .loop) -> some SwiftUICore.View
  
}
public struct NamiDevicesEndpoint : Swift.Hashable {
  public init(uid: NamiPairingFramework.DeviceUniversalID, endpoint: Network.NWEndpoint, isAccessible: Swift.Bool = true)
  public init?(browserResult: Network.NWBrowser.Result, isAccessible: Swift.Bool = true)
  public let uid: NamiPairingFramework.DeviceUniversalID
  public let endpoint: Network.NWEndpoint
  public let isAccessible: Swift.Bool
  public static func == (a: NamiPairingFramework.NamiDevicesEndpoint, b: NamiPairingFramework.NamiDevicesEndpoint) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol BonjourServiceDiscoveryProtocol : AnyObject {
  static func subscribeOnResults(for service: Swift.String) -> NamiPairingFramework.BonjourPublisher
}
@_hasMissingDesignatedInitializers final public class BonjourServiceDiscovery : NamiPairingFramework.BonjourServiceDiscoveryProtocol {
  public static func subscribeOnResults(for service: Swift.String) -> NamiPairingFramework.BonjourPublisher
  @objc deinit
}
public typealias BonjourPublisher = Combine.AnyPublisher<Swift.Set<NamiPairingFramework.NamiDevicesEndpoint>, any Swift.Error>
extension Combine.AnyPublisher where Output == Swift.Set<NamiPairingFramework.NamiDevicesEndpoint>, Failure == any Swift.Error {
  public func endpoint(for uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevicesEndpoint?, any Swift.Error>
}
extension Combine.AnyCancellable {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  final public func store(in set: inout NamiPairingFramework.SyncSet<Combine.AnyCancellable>)
}
extension Combine.PassthroughSubject where Output == NamiPairingFramework.NamiDeviceObservation, Failure == Swift.Never {
  final public func deviceObservations(for deviceUid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<Output, Failure>
  final public func deviceObservations(for deviceUids: [NamiPairingFramework.DeviceUniversalID]) -> Combine.AnyPublisher<Output, Failure>
}
public class DeviceConnectionsManager<Storage, API> : NamiPairingFramework.DeviceConnectionsManagerProtocol where Storage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol, API : NamiPairingFramework.DeviceConnectionsManagerWebAPIProtocol {
  required convenience public init(storage: Storage, api: API)
  public init(storage: Storage, api: API, bonjourPublisher: NamiPairingFramework.BonjourPublisher, coapInitializer: @escaping ([any NamiPairingFramework.PlaceKeyProtocol]) -> any NamiPairingFramework.CoAPConnectionsProtocol)
  convenience public init(storage: Storage, bonjourPublisher: NamiPairingFramework.BonjourPublisher, api: API, coapInitializer: @escaping ([any NamiPairingFramework.PlaceKeyProtocol]) -> any NamiPairingFramework.CoAPConnectionsProtocol = CoAPConnections.init)
  @objc deinit
  public static var logging: Swift.Bool {
    get
  }
  final public let publisher: Combine.PassthroughSubject<NamiPairingFramework.NamiDeviceObservation, Swift.Never>
  public func deviceStateRequest(to device: NamiPairingFramework.DeviceUniversalID, connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Foundation.Data, any Swift.Error>
  public func devicesStateRequest(connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Foundation.Data], any Swift.Error>
  public func threadCredentialsRequest(to deviceUid: NamiPairingFramework.DeviceUniversalID, connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<any NamiPairingFramework.ThreadCredentialsMessageProtocol, any Swift.Error>
  public func threadCredentialsRequest(connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[any NamiPairingFramework.ThreadCredentialsMessageProtocol], any Swift.Error>
  public func sendControlMessage(_ controlMessage: any NamiPairingFramework.DeviceControlMessageProtocol, for capability: NamiPairingFramework.NamiDeviceCapability, uid: NamiPairingFramework.DeviceUniversalID, in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<any NamiPairingFramework.DevicesCommandResponseProtocol, any Swift.Error>
  public func addToCloudObserved(placeId: NamiPairingFramework.PlaceID)
  public func removeFromCloudObserved(placeId: NamiPairingFramework.PlaceID)
}
public enum DeviceConnectionsManagerCommunicationError : Swift.RawRepresentable {
  case emptyPayload(NamiPairingFramework.SCMessage)
  case missingEndpoint
  case missingObservationManager
  case coapInitFailed
  case localControlSendTimeout
  case localStateRequestTimeout
  case localObservationTimeout
  case cloudStatePayloadMalformed
  case cloudMessageSendFailed(any Swift.Error)
  case cloudControlResponseMissing(NamiPairingFramework.DeviceUniversalID)
  public init?(rawValue _: Foundation.NSError)
  public typealias RawValue = Foundation.NSError
  public var rawValue: NamiPairingFramework.DeviceConnectionsManagerCommunicationError.RawValue {
    get
  }
  public static func errorThrowingPublisher<Output>(for error: NamiPairingFramework.DeviceConnectionsManagerCommunicationError) -> Combine.AnyPublisher<Output, any Swift.Error>
}
public typealias DoorSensorState = NamiPairingFramework.StateMessage.EndpointState.DoorSensorState
public typealias PowerSupplyInfo = NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo
public struct DeviceConnectionsManagerDevicesQuery : NamiPairingFramework.DevicesQueryProtocol {
  public var placeIds: [NamiPairingFramework.PlaceID]
  public var zoneIds: [NamiPairingFramework.PlaceZoneID]
  public var roomIds: [NamiPairingFramework.RoomID]
  public var uids: [NamiPairingFramework.DeviceUniversalID]
  public var cursor: Swift.String?
  public init(placeIds: [NamiPairingFramework.PlaceID] = [], zoneIds: [NamiPairingFramework.PlaceZoneID] = [], roomIds: [NamiPairingFramework.RoomID] = [], uids: [NamiPairingFramework.DeviceUniversalID] = [], cursor: Swift.String? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension NamiPairingFramework.DeviceConnectionsManagerDevicesQuery {
  public static func forPlace(_ placeId: NamiPairingFramework.PlaceID, deviceUIDs: [NamiPairingFramework.DeviceUniversalID] = []) -> NamiPairingFramework.DeviceConnectionsManagerDevicesQuery
  public static func forDevices(_ deviceUIDs: [NamiPairingFramework.DeviceUniversalID]) -> NamiPairingFramework.DeviceConnectionsManagerDevicesQuery
}
public struct NamiDeviceObservation {
  public init(uid: NamiPairingFramework.DeviceUniversalID, seqTime: Swift.UInt64, activity: [Swift.Int32]? = nil, state: NamiPairingFramework.StateMessage? = nil, error: (any Swift.Error)? = nil)
  public let uid: NamiPairingFramework.DeviceUniversalID
  public let seqTime: Swift.UInt64
  public let activity: [Swift.Int32]?
  public let state: NamiPairingFramework.StateMessage?
  public let error: (any Swift.Error)?
  public let data: Foundation.Data
  public let receivedAt: Foundation.Date
}
extension NamiPairingFramework.NamiDeviceModel {
  public func controlMessageType(for capability: NamiPairingFramework.NamiDeviceCapability) throws -> any NamiPairingFramework.DeviceControlMessageProtocol.Type
}
extension NamiPairingFramework.NamiDeviceCapability {
  public func controlMessageType() throws -> any NamiPairingFramework.DeviceControlMessageProtocol.Type
  public enum ControlMessgeError : Swift.Error {
    case noMessageType
    public static func == (a: NamiPairingFramework.NamiDeviceCapability.ControlMessgeError, b: NamiPairingFramework.NamiDeviceCapability.ControlMessgeError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct RelayOnOffMessage : NamiPairingFramework.DeviceControlMessageProtocol {
  public init(isOn: Swift.Bool)
  public var messageType: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public func encode() throws -> Foundation.Data
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SirenOnOffMessage : NamiPairingFramework.DeviceControlMessageProtocol {
  public init(isOn: Swift.Bool)
  public var messageType: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public func encode() throws -> Foundation.Data
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DevkitLEDControlMessage : NamiPairingFramework.DeviceControlMessageProtocol {
  public init(isOn: Swift.Bool? = nil, lightingLevel: Swift.UInt8? = nil, onLevel: Swift.UInt8? = nil, levelTransitionTime: Swift.UInt16? = nil, colorTemperature: Swift.UInt16? = nil, colorTransitionTime: Swift.UInt16? = nil)
  public var messageType: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public func encode() throws -> Foundation.Data
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WiDarControlMessage : NamiPairingFramework.DeviceControlMessageProtocol {
  public init(isPositioning: Swift.Bool)
  public var messageType: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public func encode() throws -> Foundation.Data
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ThreadCredentialsMessage : Swift.Codable, Swift.Equatable, NamiPairingFramework.ThreadCredentialsMessageProtocol {
  public var panId: Swift.UInt16
  public var extendedPanId: Foundation.Data
  public var networkName: Swift.String
  public var channel: Swift.UInt8
  public var borderAgentID: Foundation.Data
  public var operationalDataset: Foundation.Data
  public var pskc: Foundation.Data
  public var masterKey: Foundation.Data
  public var meshLocalPrefix: Foundation.Data
  public var panID: Swift.UInt32 {
    get
  }
  public var extendedPanID: Swift.UInt64 {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
  public init(anyMessage: any NamiPairingFramework.ThreadCredentialsMessageProtocol)
  public static func == (a: NamiPairingFramework.ThreadCredentialsMessage, b: NamiPairingFramework.ThreadCredentialsMessage) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct StateMessage {
  public struct EndpointState {
    public enum OnOff {
      case unknown
      case on
      case off
      public static func == (a: NamiPairingFramework.StateMessage.EndpointState.OnOff, b: NamiPairingFramework.StateMessage.EndpointState.OnOff) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Warning {
      case unknown
      case inactive
      case intrusion
      public static func == (a: NamiPairingFramework.StateMessage.EndpointState.Warning, b: NamiPairingFramework.StateMessage.EndpointState.Warning) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct ColorControl {
      public var colorTemperatureMireds: Swift.UInt32
    }
    public struct LightingLevel {
      public var current: Swift.UInt32
      public var on: Swift.UInt32
    }
    public struct DeviceInfo {
      public var appVersion: Swift.String
    }
    public struct WiFiInfo {
      public var ssid: Foundation.Data
      public var bssid: Foundation.Data
      public var rssi: Swift.Int32
      public var channel: Swift.UInt32
    }
    public struct ThreadInfo {
      public var panId: Swift.UInt32
    }
    public struct WiDarInfo {
      public enum PositioningQuality {
        case unknown
        case good
        case degraded
        case poor
        public static func == (a: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningQuality, b: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningQuality) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      public enum PositioningProcessState {
        case unknown
        case started
        case stopped
        public static func == (a: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningProcessState, b: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningProcessState) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      public var positioningQuality: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningQuality
      public var positioningProcess: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningProcessState
    }
    public enum DoorSensorState {
      case open
      case closed
      public static func == (a: NamiPairingFramework.StateMessage.EndpointState.DoorSensorState, b: NamiPairingFramework.StateMessage.EndpointState.DoorSensorState) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct PowerSupplyInfo {
      public enum BatteryState {
        case unspecified
        case normal
        case low
        public static func == (a: NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo.BatteryState, b: NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo.BatteryState) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      public var batteryState: NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo.BatteryState
      public var batteryValue: Swift.UInt32
    }
    public var onOff: NamiPairingFramework.StateMessage.EndpointState.OnOff
    public var warning: NamiPairingFramework.StateMessage.EndpointState.Warning
    public var colorControl: NamiPairingFramework.StateMessage.EndpointState.ColorControl?
    public var lightingLevel: NamiPairingFramework.StateMessage.EndpointState.LightingLevel?
    public var deviceInfo: NamiPairingFramework.StateMessage.EndpointState.DeviceInfo?
    public var wiFiInfo: NamiPairingFramework.StateMessage.EndpointState.WiFiInfo?
    public var threadInfo: NamiPairingFramework.StateMessage.EndpointState.ThreadInfo?
    public var widarInfo: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo?
    public var doorSensorState: NamiPairingFramework.StateMessage.EndpointState.DoorSensorState?
    public var doorSensorTemprered: Swift.Bool?
    public var powerSupplyInfo: NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo?
  }
  public init?(serializedData: Foundation.Data)
  public func stateForModel(_ deviceModel: NamiPairingFramework.NamiDeviceModel) -> [NamiPairingFramework.StateMessage.EndpointState]
  public func stateForEndpoints(_ modelEndpoints: [NamiPairingFramework.NamiDeviceEndpoint]) -> [NamiPairingFramework.StateMessage.EndpointState]
  public func diagnosticsState() -> [NamiPairingFramework.StateMessage.EndpointState]
  public var connectedWithThread: Swift.Bool {
    get
  }
  public var connectedWithWiFi: Swift.Bool {
    get
  }
  public var isBorderRouter: Swift.Bool {
    get
  }
  public var requiresPositioning: Swift.Bool {
    get
  }
  public func jsonData() throws -> Foundation.Data
}
public struct DeviceStateAnalyzer : NamiPairingFramework.DeviceStateAnalyzerProtocol {
  public init()
  public func isBorderRouter(from stateData: Foundation.Data) -> Swift.Bool
}
public struct ControlResponseContent : Swift.Codable, NamiPairingFramework.DeviceCommandResponseContentProtocol {
  public typealias DeviceConnections_DeviceCommandResponseError = NamiPairingFramework.ControlResponseError
  public var success: Swift.Bool
  public var error: NamiPairingFramework.ControlResponseError?
  public var seqTime: Swift.UInt64
  public var state: Foundation.Data
  public init(success: Swift.Bool, error: NamiPairingFramework.ControlResponseError? = nil, seqTime: Swift.UInt64, state: Foundation.Data)
  public init(seqTime: Swift.UInt64, state: Foundation.Data)
  public init(error: NamiPairingFramework.ControlResponseError)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ControlResponseError : Swift.Codable, NamiPairingFramework.DeviceCommandResponseErrorProtocol, Swift.Error {
  public var error: Swift.String
  public var errorCode: Swift.String
  public var code: Swift.String {
    get
  }
  public var message: Swift.String {
    get
  }
  public init(error: Swift.String, errorCode: Swift.String)
  public init(code: Swift.String, message: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ControlResponseResult : Swift.Codable, NamiPairingFramework.DevicesCommandResponseResultProtocol {
  public var devices: [NamiPairingFramework.DeviceUniversalID : NamiPairingFramework.ControlResponseContent]
  public var isCloudResponse: Swift.Bool
  public typealias DeviceConnections_DeviceCommandResponseContent = NamiPairingFramework.ControlResponseContent
  public init(devices: [NamiPairingFramework.DeviceUniversalID : NamiPairingFramework.ControlResponseContent], isCloudResponse: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDeviceControlResponse : NamiPairingFramework.DevicesCommandResponseProtocol {
  public typealias Result = NamiPairingFramework.ControlResponseResult
  public var results: [NamiPairingFramework.ControlResponseResult]
  public var seqTime: Swift.UInt64
  public init(results: [NamiPairingFramework.ControlResponseResult], seqTime: Swift.UInt64)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
final public class SyncSet<E> : NamiPairingFramework.SyncSetProtocol where E : Swift.Hashable {
  required public init()
  public init(_ wrappedValue: Swift.Set<E>)
  required public init<S>(_ elements: S) where E == S.Element, S : Swift.Sequence
  public init(minimumCapacity: Swift.Int)
  public typealias Element = E
  public typealias Index = Swift.Set<E>.Index
  final public var startIndex: NamiPairingFramework.SyncSet<E>.Index {
    get
  }
  final public var endIndex: NamiPairingFramework.SyncSet<E>.Index {
    get
  }
  final public var count: Swift.Int {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
  final public var capacity: Swift.Int {
    get
  }
  final public var customMirror: Swift.Mirror {
    get
  }
  final public var underestimatedCount: Swift.Int {
    get
  }
  final public var lazy: Swift.LazySequence<Swift.Set<E>> {
    get
  }
  public static func == (lhs: NamiPairingFramework.SyncSet<E>, rhs: NamiPairingFramework.SyncSet<E>) -> Swift.Bool
  final public func index(after i: NamiPairingFramework.SyncSet<E>.Index) -> NamiPairingFramework.SyncSet<E>.Index
  final public func index(_ i: NamiPairingFramework.SyncSet<E>.Index, offsetBy distance: Swift.Int) -> NamiPairingFramework.SyncSet<E>.Index
  final public func index(_ i: NamiPairingFramework.SyncSet<E>.Index, offsetBy distance: Swift.Int, limitedBy limit: NamiPairingFramework.SyncSet<E>.Index) -> NamiPairingFramework.SyncSet<E>.Index?
  final public func formIndex(_ i: inout NamiPairingFramework.SyncSet<E>.Index, offsetBy distance: Swift.Int)
  final public func formIndex(_ i: inout NamiPairingFramework.SyncSet<E>.Index, offsetBy distance: Swift.Int, limitedBy limit: NamiPairingFramework.SyncSet<E>.Index) -> Swift.Bool
  final public func distance(from start: NamiPairingFramework.SyncSet<E>.Index, to end: NamiPairingFramework.SyncSet<E>.Index) -> Swift.Int
  @available(swift 4.0)
  final public func filter(_ isIncluded: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> Swift.Set<NamiPairingFramework.SyncSet<E>.Element>
  final public func subtract(_ other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>)
  final public func isSubset(of other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Bool
  final public func isSuperset(of other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Bool
  final public func isDisjoint(with other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Bool
  final public func subtracting(_ other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Set<NamiPairingFramework.SyncSet<E>.Element>
  final public func isStrictSuperset(of other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Bool
  final public func isStrictSubset(of other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Bool
  final public func intersection(_ other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Set<NamiPairingFramework.SyncSet<E>.Element>
  final public func formSymmetricDifference(_ other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>)
  final public func popFirst() -> NamiPairingFramework.SyncSet<E>.Element?
  final public func reserveCapacity(_ minimumCapacity: Swift.Int)
  final public func map<T>(_ transform: (NamiPairingFramework.SyncSet<E>.Element) throws -> T) rethrows -> [T]
  final public func dropFirst(_ k: Swift.Int = 1) -> Swift.Slice<Swift.Set<NamiPairingFramework.SyncSet<E>.Element>>
  final public func split(maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true, whereSeparator isSeparator: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> [Swift.Slice<Swift.Set<NamiPairingFramework.SyncSet<E>.Element>>]
  final public func split(separator: NamiPairingFramework.SyncSet<E>.Element, maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true) -> [Swift.Slice<Swift.Set<NamiPairingFramework.SyncSet<E>.Element>>]
  final public subscript(position: NamiPairingFramework.SyncSet<E>.Index) -> E {
    get
  }
  final public func formIndex(after i: inout NamiPairingFramework.SyncSet<E>.Index)
  final public func union(_ other: NamiPairingFramework.SyncSet<E>) -> NamiPairingFramework.SyncSet<E>
  final public func hash(into hasher: inout Swift.Hasher)
  final public func intersection(_ other: NamiPairingFramework.SyncSet<E>) -> Self
  final public func symmetricDifference(_ other: __owned NamiPairingFramework.SyncSet<E>) -> Self
  final public func insert(_ newMember: __owned E) -> (inserted: Swift.Bool, memberAfterInsert: E)
  final public func remove(_ member: E) -> E?
  final public func update(with newMember: __owned E) -> E?
  final public func formUnion(_ other: __owned NamiPairingFramework.SyncSet<E>)
  final public func formIntersection(_ other: NamiPairingFramework.SyncSet<E>)
  final public func formSymmetricDifference(_ other: __owned NamiPairingFramework.SyncSet<E>)
  final public func removeAll()
  final public func makeIterator() -> Swift.Set<E>.Iterator
  final public func withContiguousStorageIfAvailable<R>(_ body: (_ buffer: Swift.UnsafeBufferPointer<NamiPairingFramework.SyncSet<E>.Element>) throws -> R) rethrows -> R?
  final public func shuffled(using generator: inout some RandomNumberGenerator) -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func shuffled() -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func filter(_ isIncluded: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func forEach(_ body: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Void) rethrows
  final public func first(where predicate: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> NamiPairingFramework.SyncSet<E>.Element?
  final public func split(maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true, whereSeparator isSeparator: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> [Swift.ArraySlice<NamiPairingFramework.SyncSet<E>.Element>]
  final public func suffix(_ maxLength: Swift.Int) -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func dropLast(_ k: Swift.Int = 1) -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func drop(while predicate: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> Swift.DropWhileSequence<Swift.Set<E>>
  final public func prefix(_ maxLength: Swift.Int) -> Swift.PrefixSequence<Swift.Set<E>>
  final public func prefix(while predicate: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func enumerated() -> Swift.EnumeratedSequence<Swift.Set<E>>
  final public func min(by areInIncreasingOrder: (NamiPairingFramework.SyncSet<E>.Element, NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> NamiPairingFramework.SyncSet<E>.Element?
  final public func max(by areInIncreasingOrder: (NamiPairingFramework.SyncSet<E>.Element, NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> NamiPairingFramework.SyncSet<E>.Element?
  final public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (NamiPairingFramework.SyncSet<E>.Element, PossiblePrefix.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where PossiblePrefix : Swift.Sequence
  final public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (NamiPairingFramework.SyncSet<E>.Element, OtherSequence.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where OtherSequence : Swift.Sequence
  final public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (NamiPairingFramework.SyncSet<E>.Element, NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where E == OtherSequence.Element, OtherSequence : Swift.Sequence
  final public func contains(where predicate: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> Swift.Bool
  final public func allSatisfy(_ predicate: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> Swift.Bool
  final public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, NamiPairingFramework.SyncSet<E>.Element) throws -> Result) rethrows -> Result
  final public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (_ partialResult: inout Result, NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Void) rethrows -> Result
  final public func reversed() -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func flatMap(_: (NamiPairingFramework.SyncSet<E>.Element) throws -> E) rethrows -> [E] where E : Swift.Sequence
  final public func compactMap(_ transform: (NamiPairingFramework.SyncSet<E>.Element) throws -> E?) rethrows -> [E]
  final public func sorted(by areInIncreasingOrder: (NamiPairingFramework.SyncSet<E>.Element, NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> [NamiPairingFramework.SyncSet<E>.Element]
  public typealias ArrayLiteralElement = NamiPairingFramework.SyncSet<E>.Element
  public typealias Indices = Swift.DefaultIndices<NamiPairingFramework.SyncSet<E>>
  public typealias Iterator = Swift.Set<E>.Iterator
  public typealias SubSequence = Swift.Slice<NamiPairingFramework.SyncSet<E>>
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
extension NamiPairingFramework.SyncSet where E : Swift.Sequence {
  final public func joined() -> Swift.FlattenSequence<Swift.Set<NamiPairingFramework.SyncSet<E>.Element>>
  final public func joined(separator: some Sequence<Element.Element>) -> Swift.JoinedSequence<Swift.Set<NamiPairingFramework.SyncSet<E>.Element>>
}
extension NamiPairingFramework.SyncSet {
  final public func split(separator: NamiPairingFramework.SyncSet<E>.Element, maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true) -> [Swift.ArraySlice<NamiPairingFramework.SyncSet<E>.Element>]
  final public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Swift.Bool where E == PossiblePrefix.Element, PossiblePrefix : Swift.Sequence
  final public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Swift.Bool where E == OtherSequence.Element, OtherSequence : Swift.Sequence
  final public func contains(_ element: NamiPairingFramework.SyncSet<E>.Element) -> Swift.Bool
}
extension NamiPairingFramework.SyncSet where E : Swift.Comparable {
  @warn_unqualified_access
  final public func min() -> NamiPairingFramework.SyncSet<E>.Element?
  @warn_unqualified_access
  final public func max() -> NamiPairingFramework.SyncSet<E>.Element?
  final public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Swift.Bool where E == OtherSequence.Element, OtherSequence : Swift.Sequence
  final public func sorted() -> [NamiPairingFramework.SyncSet<E>.Element]
}
extension NamiPairingFramework.SyncSet where E : Swift.StringProtocol {
  final public func joined(separator: Swift.String = "") -> Swift.String
}
public protocol SyncSetProtocol : Swift.Collection, Swift.CustomDebugStringConvertible, Swift.CustomReflectable, Swift.CustomStringConvertible, Swift.Hashable, Swift.SetAlgebra where Self.Element : Swift.Hashable {
}
extension Swift.Set : NamiPairingFramework.SyncSetProtocol {
}
public protocol CoAPConnectionsProtocol : AnyObject {
  init()
  init(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol])
  init(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol], date: Foundation.Date)
  func areSamePresahedKeys(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol]) -> Swift.Bool
  func getRequest(to endpoint: Network.NWEndpoint, path: Swift.String?) -> NamiPairingFramework.CoAPMessagePublisher
  func postMessage(_ message: Foundation.Data, to endpoint: Network.NWEndpoint, path: Swift.String?) -> NamiPairingFramework.CoAPMessagePublisher
  func subscribeObserver(at endpoint: Network.NWEndpoint, path: Swift.String?, timeout: Swift.Int?) -> NamiPairingFramework.CoAPMessagePublisher
  func unsubscribeFromAll()
  static func endpoint(forHost host: Swift.String, port: Swift.UInt16) -> Network.NWEndpoint
}
extension NamiPairingFramework.CoAPConnectionsProtocol {
  public static func endpoint(forHost host: Swift.String, port: Swift.UInt16) -> Network.NWEndpoint
}
public enum CoAPConnectionsErrors {
  public static let timeoutError: Foundation.NSError
}
public typealias CoAPMessagePublisher = Combine.AnyPublisher<NamiPairingFramework.SCMessage, any Swift.Error>
final public class CoAPConnections : NamiPairingFramework.CoAPConnectionsProtocol {
  public init()
  convenience public init(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol])
  public init(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol], date: Foundation.Date)
  final public func areSamePresahedKeys(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol]) -> Swift.Bool
  final public func getRequest(to endpoint: Network.NWEndpoint, path: Swift.String? = nil) -> NamiPairingFramework.CoAPMessagePublisher
  final public func postMessage(_ message: Foundation.Data, to endpoint: Network.NWEndpoint, path: Swift.String? = nil) -> NamiPairingFramework.CoAPMessagePublisher
  final public func subscribeObserver(at endpoint: Network.NWEndpoint, path: Swift.String? = nil, timeout: Swift.Int?) -> NamiPairingFramework.CoAPMessagePublisher
  final public func unsubscribeFromAll()
  @objc deinit
}
extension NamiPairingFramework.CoAPConnections {
  public enum MessageSubscriptionType {
    case observing
    case oneoffGet
    case oneoffPost(message: Foundation.Data)
  }
  @_hasMissingDesignatedInitializers public class MessageSubscription<S> : NamiPairingFramework.SCClientDelegate, Combine.Subscription where S : Combine.Subscriber, S.Failure == any Swift.Error, S.Input == NamiPairingFramework.SCMessage {
    public func swiftCoapClient(_ client: NamiPairingFramework.SCClient, didReceiveMessage message: NamiPairingFramework.SCMessage)
    public func swiftCoapClient(_ client: NamiPairingFramework.SCClient, didFailWithError error: Foundation.NSError)
    public func swiftCoapClient(_: NamiPairingFramework.SCClient, didSendMessage _: NamiPairingFramework.SCMessage, number _: Swift.Int)
    public func request(_: Combine.Subscribers.Demand)
    public func cancel()
    @objc deinit
  }
  public struct MessagePublisher : Combine.Publisher {
    public init(withTransport transport: any NamiPairingFramework.SCCoAPTransportLayerProtocol, endpoint: Network.NWEndpoint, path: Swift.String? = nil, type: NamiPairingFramework.CoAPConnections.MessageSubscriptionType = .observing)
    public typealias Output = NamiPairingFramework.SCMessage
    public typealias Failure = Swift.Error
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == any Swift.Error, S.Input == NamiPairingFramework.SCMessage
  }
}
public struct StorablePlaceKey : Swift.Codable, Swift.Equatable {
  public init(id: Swift.String, key: Swift.String)
  public var id: Swift.String
  public var key: Swift.String
  public static func == (a: NamiPairingFramework.StorablePlaceKey, b: NamiPairingFramework.StorablePlaceKey) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias StoredPlaceKeys = [NamiPairingFramework.PlaceID : [NamiPairingFramework.StorablePlaceKey]]
final public class PlaceKeysStorage {
  public init()
  final public var publisher: Combine.AnyPublisher<NamiPairingFramework.StoredPlaceKeys, Swift.Never> {
    get
  }
  final public func storeKeys(_ keys: NamiPairingFramework.StoredPlaceKeys)
  final public func storeKeys(_ keys: [NamiPairingFramework.StorablePlaceKey], forPlace placeId: NamiPairingFramework.PlaceID)
  final public func getKeys() -> NamiPairingFramework.StoredPlaceKeys
  final public func getKeys(forPlace placeId: NamiPairingFramework.PlaceID) -> [NamiPairingFramework.StorablePlaceKey]
  final public func removeAll()
  @objc deinit
}
public enum SCCoAPTransportLayerError : Swift.Error {
  case setupError(errorDescription: Swift.String), sendError(errorDescription: Swift.String), encodeError, pingTimeoutError
}
public protocol SCCoAPTransportLayerDelegate {
  func transportLayerObject(_ transportLayerObject: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didReceiveData data: Foundation.Data, fromHost host: Swift.String, port: Swift.UInt16)
  func transportLayerObject(_ transportLayerObject: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didReceiveData data: Foundation.Data, fromEndpoint endpoint: Network.NWEndpoint)
  func transportLayerObject(_ transportLayerObject: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didFailWithError error: Foundation.NSError)
}
extension NamiPairingFramework.SCCoAPTransportLayerDelegate {
  public func transportLayerObject(_ transportLayerObject: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didReceiveData data: Foundation.Data, fromHost host: Swift.String, port: Swift.UInt16)
}
public protocol SCCoAPTransportLayerProtocol {
  func sendCoAPMessage(_ message: NamiPairingFramework.SCMessage, toEndpoint endpoint: Network.NWEndpoint, token: Swift.UInt64?, delegate: (any NamiPairingFramework.SCCoAPTransportLayerDelegate)?) throws
  func getMessageId(for endpoint: Network.NWEndpoint) -> Swift.UInt16
  func cancelMessageTransmission(to endpoint: Network.NWEndpoint, withToken: Swift.UInt64)
  func cancelConnection(to endpoint: Network.NWEndpoint)
  func closeAllTransmissions()
}
public struct MessageTransportIdentifier : Swift.Equatable, Swift.Hashable {
  public static func == (a: NamiPairingFramework.MessageTransportIdentifier, b: NamiPairingFramework.MessageTransportIdentifier) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct MessageTransportDelegate {
}
public struct CoAPConnection {
}
final public class SCCoAPUDPTransportLayer {
  required public init()
  @objc deinit
}
extension NamiPairingFramework.SCCoAPUDPTransportLayer : NamiPairingFramework.SCCoAPTransportLayerProtocol {
  convenience public init?(psk: Swift.String, suite: Security.SSLCipherSuite = TLS_PSK_WITH_AES_128_GCM_SHA256)
  convenience public init(psk: Foundation.Data, suite: Security.SSLCipherSuite = TLS_PSK_WITH_AES_128_GCM_SHA256)
  convenience public init(networkParameters: Network.NWParameters)
  final public func getMessageId(for endpoint: Network.NWEndpoint) -> Swift.UInt16
  final public func sendCoAPMessage(_ message: NamiPairingFramework.SCMessage, toEndpoint endpoint: Network.NWEndpoint, token: Swift.UInt64?, delegate: (any NamiPairingFramework.SCCoAPTransportLayerDelegate)?) throws
  final public func cancelMessageTransmission(to endpoint: Network.NWEndpoint, withToken token: Swift.UInt64)
  final public func closeAllTransmissions()
  final public func cancelConnection(to endpoint: Network.NWEndpoint)
}
public enum SCType : Swift.Int {
  case confirmable, nonConfirmable, acknowledgement, reset
  public func shortString() -> Swift.String
  public func longString() -> Swift.String
  public static func fromShortString(_ string: Swift.String) -> NamiPairingFramework.SCType?
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum SCOption : Swift.Int {
  case ifMatch
  case uriHost
  case etag
  case ifNoneMatch
  case observe
  case uriPort
  case locationPath
  case uriPath
  case contentFormat
  case maxAge
  case uriQuery
  case accept
  case locationQuery
  case block2
  case block1
  case size2
  case proxyUri
  case proxyScheme
  case size1
  public enum Format : Swift.Int {
    case empty, opaque, uInt, string
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func toString() -> Swift.String
  public static func isNumberCritical(_ optionNo: Swift.Int) -> Swift.Bool
  public func isCritical() -> Swift.Bool
  public static func isNumberUnsafe(_ optionNo: Swift.Int) -> Swift.Bool
  public func isUnsafe() -> Swift.Bool
  public static func isNumberNoCacheKey(_ optionNo: Swift.Int) -> Swift.Bool
  public func isNoCacheKey() -> Swift.Bool
  public static func isNumberRepeatable(_ optionNo: Swift.Int) -> Swift.Bool
  public func isRepeatable() -> Swift.Bool
  public func format() -> NamiPairingFramework.SCOption.Format
  public func dataForValueString(_ valueString: Swift.String) -> Foundation.Data?
  public static func dataForOptionValueString(_ valueString: Swift.String, format: NamiPairingFramework.SCOption.Format) -> Foundation.Data?
  public func displayStringForData(_ data: Foundation.Data?) -> Swift.String
  public static func displayStringForFormat(_ format: NamiPairingFramework.SCOption.Format, data: Foundation.Data?) -> Swift.String
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum SCCodeSample : Swift.Int {
  case empty
  case get
  case post
  case put
  case delete
  case created
  case deleted
  case valid
  case changed
  case content
  case `continue`
  case badRequest
  case unauthorized
  case badOption
  case forbidden
  case notFound
  case methodNotAllowed
  case notAcceptable
  case requestEntityIncomplete
  case preconditionFailed
  case requestEntityTooLarge
  case unsupportedContentFormat
  case internalServerError
  case notImplemented
  case badGateway
  case serviceUnavailable
  case gatewayTimeout
  case proxyingNotSupported
  public func codeValue() -> NamiPairingFramework.SCCodeValue!
  public func toString() -> Swift.String
  public static func stringFromCodeValue(_ codeValue: NamiPairingFramework.SCCodeValue) -> Swift.String?
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum SCContentFormat : Swift.UInt {
  case plain
  case linkFormat
  case xml
  case octetStream
  case exi
  case json
  case cbor
  public func needsStringUTF8Conversion() -> Swift.Bool
  public func toString() -> Swift.String
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public struct SCCodeValue : Swift.Equatable {
  public init(rawValue: Swift.UInt8)
  public init?(classValue: Swift.UInt8, detailValue: Swift.UInt8)
  public func toRawValue() -> Swift.UInt8
  public func toCodeSample() -> NamiPairingFramework.SCCodeSample?
  public static func fromCodeSample(_ code: NamiPairingFramework.SCCodeSample) -> NamiPairingFramework.SCCodeValue
  public func toString() -> Swift.String
  public func requestString() -> Swift.String?
}
public func == (lhs: NamiPairingFramework.SCCodeValue, rhs: NamiPairingFramework.SCCodeValue) -> Swift.Bool
extension Swift.UInt {
  public func toByteArray() -> [Swift.UInt8]
  public static func fromData(_ data: Foundation.Data) -> Swift.UInt
}
public enum SCAllowedRoute : Swift.UInt {
  case get
  case post
  case put
  case delete
  public init?(codeValue: NamiPairingFramework.SCCodeValue)
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
@objc open class SCResourceModel : ObjectiveC.NSObject {
  final public let name: Swift.String
  final public let allowedRoutes: Swift.UInt
  public var maxAgeValue: Swift.UInt!
  public var dataRepresentation: Foundation.Data! {
    get
    set
  }
  public var observable: Swift.Bool
  public init(name: Swift.String, allowedRoutes: Swift.UInt)
  open func willHandleDataAsynchronouslyForRoute(_: NamiPairingFramework.SCAllowedRoute, queryDictionary _: [Swift.String : Swift.String], options _: [Swift.Int : [Foundation.Data]], originalMessage _: NamiPairingFramework.SCMessage) -> Swift.Bool
  open func dataForGet(queryDictionary _: [Swift.String : Swift.String], options _: [Swift.Int : [Foundation.Data]]) -> (statusCode: NamiPairingFramework.SCCodeValue, payloadData: Foundation.Data?, contentFormat: NamiPairingFramework.SCContentFormat?)?
  open func dataForPost(queryDictionary _: [Swift.String : Swift.String], options _: [Swift.Int : [Foundation.Data]], requestData _: Foundation.Data?) -> (statusCode: NamiPairingFramework.SCCodeValue, payloadData: Foundation.Data?, contentFormat: NamiPairingFramework.SCContentFormat?, locationUri: Swift.String?)?
  open func dataForPut(queryDictionary _: [Swift.String : Swift.String], options _: [Swift.Int : [Foundation.Data]], requestData _: Foundation.Data?) -> (statusCode: NamiPairingFramework.SCCodeValue, payloadData: Foundation.Data?, contentFormat: NamiPairingFramework.SCContentFormat?, locationUri: Swift.String?)?
  open func dataForDelete(queryDictionary _: [Swift.String : Swift.String], options _: [Swift.Int : [Foundation.Data]]) -> (statusCode: NamiPairingFramework.SCCodeValue, payloadData: Foundation.Data?, contentFormat: NamiPairingFramework.SCContentFormat?)?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class SCMessage : ObjectiveC.NSObject {
  public static let kCoapErrorDomain: Swift.String
  public var code: NamiPairingFramework.SCCodeValue
  public var type: NamiPairingFramework.SCType
  public var payload: Foundation.Data?
  public var options: [Swift.Int : [Foundation.Data]] {
    get
    set
  }
  public var blockBody: Foundation.Data? {
    get
  }
  public var endpoint: Network.NWEndpoint? {
    get
  }
  public var resourceForConfirmableResponse: NamiPairingFramework.SCResourceModel? {
    get
  }
  public var messageId: Swift.UInt16! {
    get
  }
  public var token: Swift.UInt64 {
    get
  }
  convenience public init(code: NamiPairingFramework.SCCodeValue, type: NamiPairingFramework.SCType, payload: Foundation.Data?)
  public func equalForCachingWithMessage(_ message: NamiPairingFramework.SCMessage) -> Swift.Bool
  public static func compareOptionValueArrays(_ first: [Foundation.Data], second: [Foundation.Data]) -> Swift.Bool
  public static func copyFromMessage(_ message: NamiPairingFramework.SCMessage) -> NamiPairingFramework.SCMessage
  public func isFresh() -> Swift.Bool
  public func addOption(_ option: Swift.Int, data: Foundation.Data)
  public func toData() -> Foundation.Data?
  public static func fromData(_ data: Foundation.Data) -> NamiPairingFramework.SCMessage?
  public func toHttpUrlRequestWithUrl() -> Foundation.NSMutableURLRequest
  public static func fromHttpUrlResponse(_ urlResponse: Foundation.HTTPURLResponse, data: Foundation.Data!) -> NamiPairingFramework.SCMessage
  public func completeUriPath() -> Swift.String
  public func uriQueryDictionary() -> [Swift.String : Swift.String]
  public static func getPathAndQueryDataArrayFromUriString(_ uriString: Swift.String) -> (pathDataArray: [Foundation.Data], queryDataArray: [Foundation.Data])?
  public func inferredContentFormat() -> NamiPairingFramework.SCContentFormat
  public func payloadRepresentationString() -> Swift.String
  public static func payloadRepresentationStringForData(_ data: Foundation.Data, contentFormat: NamiPairingFramework.SCContentFormat) -> Swift.String
  public func isObservation() -> Swift.Bool
  public func toString() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public protocol SCClientDelegate {
  func swiftCoapClient(_ client: NamiPairingFramework.SCClient, didReceiveMessage message: NamiPairingFramework.SCMessage)
  func swiftCoapClient(_ client: NamiPairingFramework.SCClient, didFailWithError error: Foundation.NSError)
  func swiftCoapClient(_ client: NamiPairingFramework.SCClient, didSendMessage message: NamiPairingFramework.SCMessage, number: Swift.Int)
}
public enum SCClientErrorCode : Swift.Int {
  case transportLayerSendError, messageInvalidForSendingError, receivedInvalidMessageError, noResponseExpectedError, proxyingError
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public class SCClient {
  public var delegate: (any NamiPairingFramework.SCClientDelegate)?
  public var autoBlock1SZX: Swift.UInt? {
    get
    set
  }
  public var httpProxyingData: (hostName: Swift.String, port: Swift.UInt16)?
  public var cachingActive: Swift.Bool
  public var disableRetransmissions: Swift.Bool
  public init(delegate: (any NamiPairingFramework.SCClientDelegate)?, transportLayerObject: any NamiPairingFramework.SCCoAPTransportLayerProtocol)
  public func sendCoAPMessage(_ message: NamiPairingFramework.SCMessage, endpoint: Network.NWEndpoint)
  public func cancelObserve()
  public func closeTransmission()
  @objc deinit
}
extension NamiPairingFramework.SCClient : NamiPairingFramework.SCCoAPTransportLayerDelegate {
  public func transportLayerObject(_: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didReceiveData data: Foundation.Data, fromEndpoint endpoint: Network.NWEndpoint)
  public func transportLayerObject(_: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didFailWithError error: Foundation.NSError)
}
extension NamiPairingFramework.AuthenticationError : Swift.Equatable {}
extension NamiPairingFramework.AuthenticationError : Swift.Hashable {}
extension NamiPairingFramework.NamiDeviceState.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceState.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.NamiDeviceState.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiAutomation.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.NamiAutomation.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.NamiAutomation.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiPlaceUser.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.NamiPlaceUser.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.NamiPlaceUser.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiWiFiCredentialsUpdateStatus : Swift.Hashable {}
extension NamiPairingFramework.NamiWiFiCredentialsUpdateStatus : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiAlertMode : Swift.Hashable {}
extension NamiPairingFramework.NamiAlertMode : Swift.RawRepresentable {}
extension NamiPairingFramework.AlertMode : Swift.Equatable {}
extension NamiPairingFramework.AlertMode : Swift.Hashable {}
extension NamiPairingFramework.AlertMode : Swift.RawRepresentable {}
extension NamiPairingFramework.WiFiCredentialsUpdateStatus : Swift.Equatable {}
extension NamiPairingFramework.WiFiCredentialsUpdateStatus : Swift.Hashable {}
extension NamiPairingFramework.WiFiCredentialsUpdateStatus : Swift.RawRepresentable {}
extension NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError : Swift.Equatable {}
extension NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError : Swift.Hashable {}
extension NamiPairingFramework.RemoteTemplateEntrypoint : Swift.Equatable {}
extension NamiPairingFramework.RemoteTemplateEntrypoint : Swift.Hashable {}
extension NamiPairingFramework.NamiPermission : Swift.Equatable {}
extension NamiPairingFramework.NamiPermission : Swift.Hashable {}
extension NamiPairingFramework.NamiPermission : Swift.RawRepresentable {}
extension NamiPairingFramework.StorageError : Swift.Equatable {}
extension NamiPairingFramework.StorageError : Swift.Hashable {}
extension NamiPairingFramework.NamiDeviceCapability : Swift.Hashable {}
extension NamiPairingFramework.NamiDeviceEndpoint.EndpointType.ReadableCluster : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceEndpoint.EndpointType.ReadableCluster : Swift.Hashable {}
extension NamiPairingFramework.NamiDeviceEndpoint.EndpointType.WritableCluster : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceEndpoint.EndpointType.WritableCluster : Swift.Hashable {}
extension NamiPairingFramework.MeasurementSystem : Swift.Equatable {}
extension NamiPairingFramework.MeasurementSystem : Swift.Hashable {}
extension NamiPairingFramework.NamiAlertReason : Swift.Hashable {}
extension NamiPairingFramework.NamiAlertReason : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiMeasurementSystem : Swift.Equatable {}
extension NamiPairingFramework.NamiMeasurementSystem : Swift.Hashable {}
extension NamiPairingFramework.NamiMeasurementSystem : Swift.RawRepresentable {}
extension NamiPairingFramework.KitCategory : Swift.Equatable {}
extension NamiPairingFramework.KitCategory : Swift.Hashable {}
extension NamiPairingFramework.KitCategory : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiDeviceConnectivity : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceConnectivity : Swift.Hashable {}
extension NamiPairingFramework.TimeZoneLoadingError : Swift.Equatable {}
extension NamiPairingFramework.TimeZoneLoadingError : Swift.Hashable {}
extension NamiPairingFramework.NamiAppearance : Swift.Hashable {}
extension NamiPairingFramework.NamiAppearance : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiDeviceType : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceType : Swift.Hashable {}
extension NamiPairingFramework.NamiOutletType : Swift.Equatable {}
extension NamiPairingFramework.NamiOutletType : Swift.Hashable {}
extension NamiPairingFramework.Tokens : Swift.Equatable {}
extension NamiPairingFramework.Tokens : Swift.Hashable {}
extension NamiPairingFramework.Tokens : Swift.RawRepresentable {}
extension NamiPairingFramework.TokenStoreError : Swift.Equatable {}
extension NamiPairingFramework.TokenStoreError : Swift.Hashable {}
extension NamiPairingFramework.KeychainError : Swift.Hashable {}
extension NamiPairingFramework.PacketBoatError : Swift.Equatable {}
extension NamiPairingFramework.PacketBoatError : Swift.Hashable {}
extension NamiPairingFramework.PacketBoatError : Swift.RawRepresentable {}
extension NamiPairingFramework.Seance.Role : Swift.Equatable {}
extension NamiPairingFramework.Seance.Role : Swift.Hashable {}
extension NamiPairingFramework.Seance.State : Swift.Equatable {}
extension NamiPairingFramework.Seance.State : Swift.Hashable {}
extension NamiPairingFramework.ErrorScreen.Event : Swift.Hashable {}
extension NamiPairingFramework.PositioningGuidance.PositioningQuality : Swift.Hashable {}
extension NamiPairingFramework.PositioningGuidance.PositioningState : Swift.Hashable {}
extension NamiPairingFramework.InitialScreen.Event : Swift.Hashable {}
extension NamiPairingFramework.PositioningComplete.Event : Swift.Equatable {}
extension NamiPairingFramework.PositioningComplete.Event : Swift.Hashable {}
extension NamiPairingFramework.PositioningResult : Swift.Equatable {}
extension NamiPairingFramework.PositioningResult : Swift.Hashable {}
extension NamiPairingFramework.CodeScannerView : Swift.Sendable {}
extension NamiPairingFramework.CodeScannerView.Coordinator : AVFoundation.AVCaptureMetadataOutputObjectsDelegate {}
extension NamiPairingFramework.QRScanner.ScanError : Swift.Equatable {}
extension NamiPairingFramework.QRScanner.ScanError : Swift.Hashable {}
extension NamiPairingFramework.QRScanner.ScanError : Swift.RawRepresentable {}
extension NamiPairingFramework.ListWiFiNetworks.State : Swift.Equatable {}
extension NamiPairingFramework.ListWiFiNetworks.ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {}
extension NamiPairingFramework.OtherWiFiNetwork.State : Swift.Equatable {}
extension NamiPairingFramework.OtherWiFiNetwork.ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {}
extension NamiPairingFramework.BluetoothUsageHint.Event : Swift.Equatable {}
extension NamiPairingFramework.BluetoothUsageHint.Event : Swift.Hashable {}
extension NamiPairingFramework.EnterWiFiPassword.Event : Swift.Equatable {}
extension NamiPairingFramework.EnterWiFiPassword.Event : Swift.Hashable {}
extension NamiPairingFramework.Pairing.ConnectTo : Swift.Hashable {}
extension NamiPairingFramework.Pairing.ActionOnError : Swift.Hashable {}
extension NamiPairingFramework.Pairing.PairingCancellationdReason : Swift.Equatable {}
extension NamiPairingFramework.Pairing.PairingCancellationdReason : Swift.Hashable {}
extension NamiPairingFramework.Pairing.ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {}
extension NamiPairingFramework.NoView : Swift.Sendable {}
extension NamiPairingFramework.RoundedRectContainerView : Swift.Sendable {}
extension NamiPairingFramework.NamiXMarkButton : Swift.Sendable {}
extension NamiPairingFramework.NamiXMarkButton.Appearance : Swift.Equatable {}
extension NamiPairingFramework.NamiXMarkButton.Appearance : Swift.Hashable {}
extension NamiPairingFramework.NamiNavBackButton : Swift.Sendable {}
extension NamiPairingFramework.NamiCircularXMarkButton : Swift.Sendable {}
extension NamiPairingFramework.NamiCircularXMarkButton.Appearance : Swift.Equatable {}
extension NamiPairingFramework.NamiCircularXMarkButton.Appearance : Swift.Hashable {}
extension NamiPairingFramework.NamiPageIndexIndicatorView : Swift.Sendable {}
extension NamiPairingFramework.TextFieldView : Swift.Sendable {}
extension NamiPairingFramework.NamiTextFieldStyle : Swift.Equatable {}
extension NamiPairingFramework.NamiTextFieldStyle : Swift.Hashable {}
extension NamiPairingFramework.NamiTextField : Swift.Sendable {}
extension NamiPairingFramework.NamiErrorChatBubble : Swift.Sendable {}
extension NamiPairingFramework.NamiChatBubble : Swift.Sendable {}
extension NamiPairingFramework.NamiTopNavigationScreen : Swift.Sendable {}
extension NamiPairingFramework.LottieAnimationView : Swift.Sendable {}
extension NamiPairingFramework.CircleButton : Swift.Sendable {}
extension NamiPairingFramework.NamiTextStyle.Leading : Swift.Equatable {}
extension NamiPairingFramework.NamiTextStyle.Leading : Swift.Hashable {}
@available(iOS 15, *)
extension NamiPairingFramework.NamiTextHyperLink : Swift.Sendable {}
extension NamiPairingFramework.NamiTextHyperLinkLegacy : Swift.Sendable {}
extension NamiPairingFramework.NotificationButtonStyle : Swift.Sendable {}
extension NamiPairingFramework.NotificationButtonStyle.NotificationButton : Swift.Sendable {}
extension NamiPairingFramework.NamiAuthButtonStyle : Swift.Sendable {}
extension NamiPairingFramework.NamiAuthButtonStyle.NamiAuthButton : Swift.Sendable {}
extension NamiPairingFramework.NamiAuthButtonStyle.AppearanceColorMode : Swift.Equatable {}
extension NamiPairingFramework.NamiAuthButtonStyle.AppearanceColorMode : Swift.Hashable {}
extension NamiPairingFramework.NamiActionButtonStyle : Swift.Sendable {}
extension NamiPairingFramework.NamiActionButtonStyle.NamiActionButton : Swift.Sendable {}
extension NamiPairingFramework.NamiActionButtonStyle.AppearanceHierarchyRank : Swift.Equatable {}
extension NamiPairingFramework.NamiActionButtonStyle.AppearanceHierarchyRank : Swift.Hashable {}
extension NamiPairingFramework.ScrollViewWithOnScrollAction : Swift.Sendable {}
extension UIKit.UIImage.AnimatableImageFormat : Swift.Equatable {}
extension UIKit.UIImage.AnimatableImageFormat : Swift.Hashable {}
extension UIKit.UIImage.AnimatableImageFormat : Swift.RawRepresentable {}
extension NamiPairingFramework.AnimatableImageView : Swift.Sendable {}
extension NamiPairingFramework.Colors.ColorSaturation : Swift.Equatable {}
extension NamiPairingFramework.Colors.ColorSaturation : Swift.Hashable {}
extension NamiPairingFramework.Colors.ColorSaturation : Swift.RawRepresentable {}
extension NamiPairingFramework.Colors.ColorSaturationNumber : Swift.Equatable {}
extension NamiPairingFramework.Colors.ColorSaturationNumber : Swift.Hashable {}
extension NamiPairingFramework.Colors.ColorSaturationNumber : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiDeviceCapability.ControlMessgeError : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceCapability.ControlMessgeError : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.OnOff : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.OnOff : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.Warning : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.Warning : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningQuality : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningQuality : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningProcessState : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningProcessState : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.DoorSensorState : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.DoorSensorState : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo.BatteryState : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo.BatteryState : Swift.Hashable {}
extension NamiPairingFramework.SCType : Swift.Equatable {}
extension NamiPairingFramework.SCType : Swift.Hashable {}
extension NamiPairingFramework.SCType : Swift.RawRepresentable {}
extension NamiPairingFramework.SCOption : Swift.Equatable {}
extension NamiPairingFramework.SCOption : Swift.Hashable {}
extension NamiPairingFramework.SCOption : Swift.RawRepresentable {}
extension NamiPairingFramework.SCOption.Format : Swift.Equatable {}
extension NamiPairingFramework.SCOption.Format : Swift.Hashable {}
extension NamiPairingFramework.SCOption.Format : Swift.RawRepresentable {}
extension NamiPairingFramework.SCCodeSample : Swift.Equatable {}
extension NamiPairingFramework.SCCodeSample : Swift.Hashable {}
extension NamiPairingFramework.SCCodeSample : Swift.RawRepresentable {}
extension NamiPairingFramework.SCContentFormat : Swift.Equatable {}
extension NamiPairingFramework.SCContentFormat : Swift.Hashable {}
extension NamiPairingFramework.SCContentFormat : Swift.RawRepresentable {}
extension NamiPairingFramework.SCAllowedRoute : Swift.Equatable {}
extension NamiPairingFramework.SCAllowedRoute : Swift.Hashable {}
extension NamiPairingFramework.SCAllowedRoute : Swift.RawRepresentable {}
extension NamiPairingFramework.SCClientErrorCode : Swift.Equatable {}
extension NamiPairingFramework.SCClientErrorCode : Swift.Hashable {}
extension NamiPairingFramework.SCClientErrorCode : Swift.RawRepresentable {}
