// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.19.9 clang-1700.3.19.1)
// swift-module-flags: -target arm64-apple-ios16 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name NamiPairingFramework
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
import AVFoundation
import ActivityKit
import AuthenticationServices
import Combine
import CommonCrypto
import CoreBluetooth
import CoreGraphics
import CryptoKit
import DeveloperToolsSupport
import Dispatch
import Foundation
import Lottie
@_exported import NamiPairingFramework
import Network
import SafariServices
import Security
import Swift
import SwiftUI
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import _WebKit_SwiftUI
import os.log
import os
extension NamiPairingFramework.NamiDeviceModel {
  public init(from model: any NamiPairingFramework.DeviceModelProtocol)
}
extension NamiPairingFramework.NamiDeviceModel : Swift.Codable, Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension NamiPairingFramework.InMemoryStorage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol {
  final public func placeIds() -> Combine.AnyPublisher<[NamiPairingFramework.PlaceID], Swift.Never>
  final public func deviceUids(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.DeviceUniversalID], Swift.Never>
  final public func updateDeviceState(uid: NamiPairingFramework.DeviceUniversalID, state: Foundation.Data, seqTime: Swift.UInt64) throws
  public typealias DeviceConnectionsManager_PlaceKey = NamiPairingFramework.NamiPlaceKey
}
public struct PlaceKey : Swift.Codable, Swift.Equatable, Swift.Identifiable, NamiPairingFramework.PlaceKeyProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ from: NamiPairingFramework.CloudPlaceKey)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ from: NamiPairingFramework.StorablePlaceKey)
  #endif
  public let id: Swift.String
  public let placeId: NamiPairingFramework.PlaceID
  public let valid: Foundation.DateInterval
  public let key: Foundation.Data
  #if compiler(>=5.3) && $NonescapableTypes
  public static func decodeId(_ id: Swift.String) -> (placeId: NamiPairingFramework.PlaceID, valid: Foundation.DateInterval)?
  #endif
  public static func == (a: NamiPairingFramework.PlaceKey, b: NamiPairingFramework.PlaceKey) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension NamiPairingFramework.InMemoryStorage : NamiPairingFramework.RemoteTemplateStateRepositoryProtocol {
  final public func place(id placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Place, Swift.Never>
  final public func zones(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Zone], Swift.Never>
  final public func rooms(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Room], Swift.Never>
  final public func rooms(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Room], Swift.Never>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func device(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func device(urn: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func device(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  #endif
  final public func devices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  final public func devices(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  final public func devices(roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  final public func devicesPerZone(in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZoneID : [NamiPairingFramework.RemoteTemplateUI_Device]], Swift.Never>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func deviceState(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_DeviceState?, Swift.Never>
  #endif
  final public func deviceStates(uids: [NamiPairingFramework.DeviceUniversalID]) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_DeviceState], Swift.Never>
  final public func deleteRoom(_ roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Place, any Swift.Error>
  final public func updateEntryExitDelay(_ placeId: NamiPairingFramework.PlaceID, entryDelay: NamiPairingFramework.EntryDelay, exitDelay: NamiPairingFramework.ExitDelay) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Place, any Swift.Error>
  final public func updateSensitivity(_ placeId: NamiPairingFramework.PlaceID, sensitivity: Swift.Int) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func verifyPin(for place: NamiPairingFramework.PlaceID, pinNamed name: Swift.String, pinValue: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_PinVerificationResult, any Swift.Error>
  final public func listPins(in place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_PinCredentialRecord], any Swift.Error>
  final public func createPin(for place: NamiPairingFramework.PlaceID, pinNamed name: Swift.String, pinValue: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_PinCredentialRecord, any Swift.Error>
  final public func deletePin(from place: NamiPairingFramework.PlaceID, pinId: NamiPairingFramework.PinCredentialID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_PinCredentialRecord, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func updatePin(in place: NamiPairingFramework.PlaceID, pinId: NamiPairingFramework.PinCredentialID, newName: Swift.String?, newValue: Swift.String?) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_PinCredentialRecord, any Swift.Error>
  #endif
}
public struct NamiPlace : Swift.Codable, Swift.Equatable, Swift.Identifiable, NamiPairingFramework.StorablePlaceProtocol {
  public init(id: NamiPairingFramework.PlaceID, urn: Swift.String, name: Swift.String, themeId: NamiPairingFramework.ThemeID, iconId: NamiPairingFramework.IconID, createdAt: Foundation.Date = Date(), updatedAt: Foundation.Date = Date(), alertMode: Swift.String, entryDelay: NamiPairingFramework.EntryDelay, exitDelay: NamiPairingFramework.ExitDelay)
  public init(_ place: NamiPairingFramework.Place)
  public var id: NamiPairingFramework.PlaceID
  public var urn: Swift.String
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var propertyTypeId: NamiPairingFramework.PropertyTypeID?
  public var propertyElevationId: NamiPairingFramework.PropertyElevationID?
  public var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID?
  public var petTypeId: NamiPairingFramework.PetTypeID?
  public var timeZone: Swift.String?
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var alertMode: Swift.String?
  public var entryDelay: NamiPairingFramework.EntryDelay
  public var exitDelay: NamiPairingFramework.ExitDelay
  public static func == (a: NamiPairingFramework.NamiPlace, b: NamiPairingFramework.NamiPlace) -> Swift.Bool
  public typealias ID = NamiPairingFramework.PlaceID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiPlaceUsageLimits : Swift.Codable, Swift.Equatable, Swift.Identifiable, NamiPairingFramework.StorablePlaceUsageLimitsProtocol {
  public init(urn: Swift.String, limits: NamiPairingFramework.PlaceUsageLimits)
  public var urn: Swift.String
  public var membership: Swift.UInt
  public var id: NamiPairingFramework.URN {
    get
  }
  public static func == (a: NamiPairingFramework.NamiPlaceUsageLimits, b: NamiPairingFramework.NamiPlaceUsageLimits) -> Swift.Bool
  public typealias ID = NamiPairingFramework.URN
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiZone : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Hashable, NamiPairingFramework.StorableZoneProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: NamiPairingFramework.PlaceZoneID, externalId: Swift.String?, urn: Swift.String, name: Swift.String, placeId: NamiPairingFramework.PlaceID, alertMode: Swift.String, createdAt: Foundation.Date = Date(), updatedAt: Foundation.Date = Date(), engineConfig: NamiPairingFramework.NamiEngineConfig)
  #endif
  public init(_ zone: NamiPairingFramework.PlaceZone)
  public var id: NamiPairingFramework.PlaceZoneID
  public var externalId: Swift.String?
  public var urn: Swift.String
  public var name: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var namiAlertMode: NamiPairingFramework.NamiAlertMode
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var alertMode: Swift.String
  public var engineConfig: NamiPairingFramework.NamiEngineConfig
  public static func == (a: NamiPairingFramework.NamiZone, b: NamiPairingFramework.NamiZone) -> Swift.Bool
  public typealias EngineConfig = NamiPairingFramework.NamiEngineConfig
  public typealias ID = NamiPairingFramework.PlaceZoneID
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiRoom : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Hashable, NamiPairingFramework.StorableRoomProtocol {
  public init(id: NamiPairingFramework.RoomID, urn: Swift.String, name: Swift.String, placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID, iconId: NamiPairingFramework.IconID, createdAt: Foundation.Date = Date(), updatedAt: Foundation.Date = Date())
  public init(_ room: NamiPairingFramework.Room)
  public var id: NamiPairingFramework.RoomID
  public var urn: Swift.String
  public var name: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var iconId: NamiPairingFramework.IconID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.NamiRoom, b: NamiPairingFramework.NamiRoom) -> Swift.Bool
  public typealias ID = NamiPairingFramework.RoomID
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDevice : Swift.Codable, Swift.Equatable, Swift.Identifiable, Swift.Hashable, NamiPairingFramework.StorableDeviceProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: NamiPairingFramework.DeviceID, uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, placeId: NamiPairingFramework.PlaceID, roomId: NamiPairingFramework.RoomID, bleDiscriminator: Swift.Int32?, name: Swift.String, codeName: Swift.String, productId: NamiPairingFramework.DeviceProductID, createdAt: Foundation.Date = Date(), updatedAt: Foundation.Date = Date())
  #endif
  public init(_ device: NamiPairingFramework.Device, in placeId: NamiPairingFramework.PlaceID)
  public var id: NamiPairingFramework.DeviceID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var roomId: NamiPairingFramework.RoomID
  public var bleDiscriminator: Swift.Int32?
  public var name: Swift.String
  public var codeName: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var model: NamiPairingFramework.NamiDeviceModel
  public var isBorderRouter: Swift.Bool
  public static func == (a: NamiPairingFramework.NamiDevice, b: NamiPairingFramework.NamiDevice) -> Swift.Bool
  public typealias ID = NamiPairingFramework.DeviceID
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDeviceState : Swift.Codable, Swift.Equatable, Swift.Identifiable, NamiPairingFramework.StorableDeviceStateProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ device: NamiPairingFramework.Device)
  #endif
  public init(from decoder: any Swift.Decoder) throws
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: NamiPairingFramework.DeviceID, uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, cloudAccessible: Swift.Bool?, lastCloudAccess: Foundation.Date?, seqTime: Swift.UInt64, state: Foundation.Data, stateUpdatedAt: Foundation.Date)
  #endif
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id
    case uid
    case urn
    case cloudAccessible
    case lastCloudAccess
    case seqTime
    case state
    case stateUpdatedAt
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(stringValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(intValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public var intValue: Swift.Int? {
      get
    }
    #endif
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var id: NamiPairingFramework.DeviceID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var cloudAccessible: Swift.Bool?
  public var lastCloudAccess: Foundation.Date?
  public var seqTime: Swift.UInt64
  public var state: Foundation.Data
  public var stateUpdatedAt: Foundation.Date
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.NamiDeviceState, b: NamiPairingFramework.NamiDeviceState) -> Swift.Bool
  public typealias ID = NamiPairingFramework.DeviceID
}
public struct NamiAutomation : Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Identifiable, NamiPairingFramework.StorableAutomationProtocol {
  public init(_ placeId: NamiPairingFramework.PlaceID, _ automation: NamiPairingFramework.Automation)
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id
    case placeId
    case trigger
    case reactions
    case active
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(stringValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(intValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public var intValue: Swift.Int? {
      get
    }
    #endif
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var id: NamiPairingFramework.AutomationID
  public var placeId: NamiPairingFramework.PlaceID
  public var trigger: NamiPairingFramework.NamiAutomationTrigger
  public var reactions: [NamiPairingFramework.NamiAutomationReaction]
  public var active: Swift.Bool
  public static func == (a: NamiPairingFramework.NamiAutomation, b: NamiPairingFramework.NamiAutomation) -> Swift.Bool
  public typealias ID = NamiPairingFramework.AutomationID
  public typealias Reaction = NamiPairingFramework.NamiAutomationReaction
  public typealias Trigger = NamiPairingFramework.NamiAutomationTrigger
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiAutomationTrigger : Swift.Codable, Swift.Equatable, Swift.Hashable, NamiPairingFramework.StorableAutomationTriggerProtocol {
  public init(_ type: Swift.String, hour: Swift.Int, minute: Swift.Int, daysOfWeek: [Swift.String])
  public init(_ trigger: NamiPairingFramework.AutomationTrigger)
  public var type: Swift.String
  public var hour: Swift.Int
  public var minute: Swift.Int
  public var daysOfWeek: [Swift.String]
  public static func == (a: NamiPairingFramework.NamiAutomationTrigger, b: NamiPairingFramework.NamiAutomationTrigger) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiAutomationReaction : Swift.Codable, Swift.Equatable, Swift.Hashable, NamiPairingFramework.StorableAutomationReactionProtocol {
  public init(_ uuid: Swift.String, targetType: Swift.String, targetIds: [NamiPairingFramework.PlaceZoneID], action: NamiPairingFramework.NamiAutomationAction)
  public init(_ reaction: NamiPairingFramework.AutomationReaction)
  public var uuid: Swift.String
  public var targetType: Swift.String
  public var targetIds: [NamiPairingFramework.PlaceZoneID]
  public var action: NamiPairingFramework.NamiAutomationAction
  public static func == (a: NamiPairingFramework.NamiAutomationReaction, b: NamiPairingFramework.NamiAutomationReaction) -> Swift.Bool
  public typealias Action = NamiPairingFramework.NamiAutomationAction
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiAutomationAction : Swift.Codable, Swift.Equatable, Swift.Hashable, NamiPairingFramework.StorableAutomationActionProtocol {
  public init(_ type: Swift.String, _ mode: NamiPairingFramework.AlertMode)
  public init(_ action: NamiPairingFramework.AutomationAction)
  public var type: Swift.String
  public var mode: NamiPairingFramework.NamiAlertMode
  public static func == (a: NamiPairingFramework.NamiAutomationAction, b: NamiPairingFramework.NamiAutomationAction) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiPlaceKey : Swift.Codable, Swift.Equatable, Swift.Identifiable, NamiPairingFramework.PlaceKeyProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ from: NamiPairingFramework.CloudPlaceKey)
  #endif
  public let id: Swift.String
  public let placeId: NamiPairingFramework.PlaceID
  public let valid: Foundation.DateInterval
  public let key: Foundation.Data
  #if compiler(>=5.3) && $NonescapableTypes
  public static func decodeId(_ id: Swift.String) -> (placeId: NamiPairingFramework.PlaceID, valid: Foundation.DateInterval)?
  #endif
  public static func == (a: NamiPairingFramework.NamiPlaceKey, b: NamiPairingFramework.NamiPlaceKey) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiPlaceUser : Swift.Codable, Swift.Equatable, Swift.Identifiable, NamiPairingFramework.StorablePlaceUserProtocol {
  public init(id: NamiPairingFramework.PlaceUserID, userId: NamiPairingFramework.UserID, urn: Swift.String, name: Swift.String, role: NamiPairingFramework.PlaceUserRole, placeId: NamiPairingFramework.PlaceID, iconId: NamiPairingFramework.UserIconID, themeId: NamiPairingFramework.IconID)
  public init(id: NamiPairingFramework.PlaceUserID, userId: NamiPairingFramework.UserID, urn: Swift.String, name: Swift.String, role: NamiPairingFramework.NamiPlaceUserRole, placeId: NamiPairingFramework.PlaceID, iconId: NamiPairingFramework.UserIconID, themeId: NamiPairingFramework.IconID)
  public init(_ user: NamiPairingFramework.PlaceUser)
  public init(from decoder: any Swift.Decoder) throws
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id
    case userId
    case name
    case urn
    case role
    case placeId
    case iconId
    case themeId
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(stringValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(intValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public var intValue: Swift.Int? {
      get
    }
    #endif
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var id: NamiPairingFramework.PlaceUserID
  public var userId: NamiPairingFramework.UserID
  public var name: Swift.String
  public var urn: Swift.String
  public var role: NamiPairingFramework.NamiPlaceUserRole
  public var placeId: NamiPairingFramework.PlaceID
  public var iconId: NamiPairingFramework.UserIconID
  public var themeId: NamiPairingFramework.ThemeID
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.NamiPlaceUser, b: NamiPairingFramework.NamiPlaceUser) -> Swift.Bool
  public typealias ID = NamiPairingFramework.PlaceUserID
  public typealias Role = NamiPairingFramework.NamiPlaceUserRole
}
public struct NamiPlaceUserRole : Swift.Codable, Swift.Equatable, Swift.Hashable, NamiPairingFramework.StorablePlaceUserRoleProtocol {
  public init(id: Swift.String, name: Swift.String)
  public init(_ role: NamiPairingFramework.PlaceUserRole)
  public init(from decoder: any Swift.Decoder) throws
  public static var unknown: NamiPairingFramework.NamiPlaceUserRole
  public var id: Swift.String
  public var name: Swift.String
  public static func == (a: NamiPairingFramework.NamiPlaceUserRole, b: NamiPairingFramework.NamiPlaceUserRole) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NamiWiFiCredentialsUpdateStatus : Swift.String, Swift.Equatable, Swift.Codable {
  case inProgress
  case completed
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public init(_ type: NamiPairingFramework.WiFiCredentialsUpdateStatus)
  public var status: NamiPairingFramework.WiFiCredentialsUpdateStatus {
    get
  }
  public static func == (lhs: NamiPairingFramework.NamiWiFiCredentialsUpdateStatus, rhs: NamiPairingFramework.NamiWiFiCredentialsUpdateStatus) -> Swift.Bool
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct NamiUpdatedDevice : Swift.Codable, Swift.Equatable, Swift.Identifiable, NamiPairingFramework.StorableUpdatedDeviceProtocol {
  public init(_ updatedDevice: NamiPairingFramework.UpdatedDevice, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID)
  public init(from decoder: any Swift.Decoder) throws
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID
  public var id: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.NamiUpdatedDevice, b: NamiPairingFramework.NamiUpdatedDevice) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct NamiUpdatedDeviceUser : Swift.Codable, Swift.Equatable, NamiPairingFramework.StorableUpdatedDeviceUserProtocol {
  public init(_ updatedDeviceUser: NamiPairingFramework.UpdatedDeviceUser, uid: NamiPairingFramework.DeviceUniversalID, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID)
  public init(from decoder: any Swift.Decoder) throws
  public var urn: Swift.String?
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID
  public static func == (a: NamiPairingFramework.NamiUpdatedDeviceUser, b: NamiPairingFramework.NamiUpdatedDeviceUser) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
extension NamiPairingFramework.NamiAlertMode {
  public init(_ mode: NamiPairingFramework.AlertMode)
  public var alertMode: NamiPairingFramework.AlertMode {
    get
  }
}
public struct NamiEngineConfig : Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Identifiable, NamiPairingFramework.StorableEngineConfigProtocol {
  public var id: NamiPairingFramework.PlaceZoneID
  public var sensitivityLevel: Swift.Int
  public var engineType: Swift.String {
    get
    set
  }
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case zoneId
    case engineType
    case sensitivityLevel
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(stringValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(intValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public var intValue: Swift.Int? {
      get
    }
    #endif
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(zoneId: NamiPairingFramework.PlaceZoneID, engineType: NamiPairingFramework.NamiEngineType, sensitivityLevel: Swift.Int)
  public init(from decoder: any Swift.Decoder) throws
  public init(_ zoneId: NamiPairingFramework.PlaceZoneID, engineConfig: NamiPairingFramework.EngineConfig)
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.NamiEngineConfig, b: NamiPairingFramework.NamiEngineConfig) -> Swift.Bool
  public typealias ID = NamiPairingFramework.PlaceZoneID
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NamiZoneMotionStatus : Swift.Codable, Swift.Equatable, Swift.Identifiable, NamiPairingFramework.StorableZoneMotionStatusProtocol {
  public init(zoneId: NamiPairingFramework.PlaceZoneID, motionStatus: NamiPairingFramework.ZoneMotionStatus)
  public var id: NamiPairingFramework.PlaceZoneID
  public var detection: Swift.Bool?
  public var startedAt: Foundation.Date?
  public var health: Swift.String
  public var namiZoneHealth: NamiPairingFramework.NamiZoneHealth
  public static func == (a: NamiPairingFramework.NamiZoneMotionStatus, b: NamiPairingFramework.NamiZoneMotionStatus) -> Swift.Bool
  public typealias ID = NamiPairingFramework.PlaceZoneID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiMotionAggregate : Swift.Codable {
  public init(metric: Swift.String, resolution: NamiPairingFramework.MotionDataResolution, intervalLength: Foundation.TimeInterval, intervals: [NamiPairingFramework.MotionInterval])
  public var metric: Swift.String
  public var resolution: Swift.String
  public var intervalLength: Foundation.TimeInterval
  public var intervals: [NamiPairingFramework.NamiMotionInterval]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiMotionInterval : Swift.Codable {
  public init(start: Foundation.Date, value: Swift.UInt8)
  public init(motionInterval: NamiPairingFramework.MotionInterval)
  public var start: Foundation.Date
  public var value: Swift.UInt8
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum NamiEngineType : Swift.String, Swift.Equatable, Swift.Codable, Swift.CaseIterable, Swift.Identifiable {
  case motion
  case security
  case aerialMotionV1
  public var id: NamiPairingFramework.NamiEngineType {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public init(_ type: NamiPairingFramework.EngineType)
  public var engineType: NamiPairingFramework.EngineType {
    get
  }
  public static func == (lhs: NamiPairingFramework.NamiEngineType, rhs: NamiPairingFramework.NamiEngineType) -> Swift.Bool
  public typealias AllCases = [NamiPairingFramework.NamiEngineType]
  public typealias ID = NamiPairingFramework.NamiEngineType
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [NamiPairingFramework.NamiEngineType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum NamiZoneHealth : Swift.String, Swift.Equatable, Swift.Codable {
  case healthy
  case degraded
  case unhealthy
  case unknown
  public init(rawValue: Swift.String)
  public init(zoneHealth: NamiPairingFramework.ZoneHealth)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
final public class InMemoryStorage {
  @Combine.Published @_projectedValueProperty($placesStore) final public var placesStore: [NamiPairingFramework.NamiPlace] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $placesStore: Combine.Published<[NamiPairingFramework.NamiPlace]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($zonesStore) final public var zonesStore: [NamiPairingFramework.NamiZone] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $zonesStore: Combine.Published<[NamiPairingFramework.NamiZone]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($roomsStore) final public var roomsStore: [NamiPairingFramework.NamiRoom] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $roomsStore: Combine.Published<[NamiPairingFramework.NamiRoom]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($devicesStore) final public var devicesStore: [NamiPairingFramework.NamiDevice] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $devicesStore: Combine.Published<[NamiPairingFramework.NamiDevice]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($deviceStatesStore) final public var deviceStatesStore: [NamiPairingFramework.NamiDeviceState] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $deviceStatesStore: Combine.Published<[NamiPairingFramework.NamiDeviceState]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($automationsStore) final public var automationsStore: [NamiPairingFramework.NamiAutomation] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $automationsStore: Combine.Published<[NamiPairingFramework.NamiAutomation]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($deviceModelsStore) final public var deviceModelsStore: [NamiPairingFramework.NamiDeviceModel] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $deviceModelsStore: Combine.Published<[NamiPairingFramework.NamiDeviceModel]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($engineConfigsStore) final public var engineConfigsStore: [NamiPairingFramework.NamiEngineConfig] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $engineConfigsStore: Combine.Published<[NamiPairingFramework.NamiEngineConfig]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($placeIntegrationsStore) final public var placeIntegrationsStore: [NamiPairingFramework.NamiPlaceIntegrations] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $placeIntegrationsStore: Combine.Published<[NamiPairingFramework.NamiPlaceIntegrations]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($placeUsageLimitsStore) final public var placeUsageLimitsStore: [NamiPairingFramework.NamiPlaceUsageLimits] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $placeUsageLimitsStore: Combine.Published<[NamiPairingFramework.NamiPlaceUsageLimits]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($zoneMotionStatusesStore) final public var zoneMotionStatusesStore: [NamiPairingFramework.NamiZoneMotionStatus] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $zoneMotionStatusesStore: Combine.Published<[NamiPairingFramework.NamiZoneMotionStatus]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($placeUsersStore) final public var placeUsersStore: [NamiPairingFramework.NamiPlaceUser] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $placeUsersStore: Combine.Published<[NamiPairingFramework.NamiPlaceUser]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($updatedDevicesStore) final public var updatedDevicesStore: [NamiPairingFramework.NamiUpdatedDevice] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $updatedDevicesStore: Combine.Published<[NamiPairingFramework.NamiUpdatedDevice]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  @Combine.Published @_projectedValueProperty($placeKeysStore) final public var placeKeysStore: [NamiPairingFramework.PlaceID : [NamiPairingFramework.StorablePlaceKey]] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  final public var $placeKeysStore: Combine.Published<[NamiPairingFramework.PlaceID : [NamiPairingFramework.StorablePlaceKey]]>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  public init(api: NamiPairingFramework.WebAPI)
  public enum InMemoryError : Swift.Error {
    case missingData(description: Swift.String)
  }
  final public func place(id placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.NamiPlace, Swift.Never>
  final public func places() -> Combine.AnyPublisher<[NamiPairingFramework.NamiPlace], Swift.Never>
  final public func placesRemovedSinceLastUpdate() -> Combine.AnyPublisher<[NamiPairingFramework.NamiPlace], Swift.Never>
  final public func zones(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiZone], Swift.Never>
  final public func zonesWithDevices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiZone], Swift.Never>
  final public func rooms(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiRoom], Swift.Never>
  final public func rooms(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiRoom], Swift.Never>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func device(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevice?, Swift.Never>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func device(urn: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevice?, Swift.Never>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func device(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevice?, Swift.Never>
  #endif
  final public func devices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiDevice], Swift.Never>
  final public func devices(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiDevice], Swift.Never>
  final public func devices(roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiDevice], Swift.Never>
  final public func devicesPerZone(in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZoneID : [NamiPairingFramework.NamiDevice]], Swift.Never>
  final public func automations(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiAutomation], Swift.Never>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func automation(id: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<NamiPairingFramework.NamiAutomation?, Swift.Never>
  #endif
  final public func deviceModel(productId: NamiPairingFramework.DeviceProductID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDeviceModel, Swift.Never>
  final public func deviceModel(codeName: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.NamiDeviceModel, Swift.Never>
  final public func deviceModels(for deviceIds: [NamiPairingFramework.DeviceID]) -> Combine.AnyPublisher<[NamiPairingFramework.DeviceID : NamiPairingFramework.NamiDeviceModel], Swift.Never>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func deviceState(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDeviceState?, Swift.Never>
  #endif
  final public func deviceStates(for uids: [NamiPairingFramework.DeviceUniversalID]) -> Combine.AnyPublisher<[NamiPairingFramework.NamiDeviceState], Swift.Never>
  final public func deleteDeviceStates(devices: [NamiPairingFramework.NamiDevice]) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func engineConfigs(for zoneIds: [NamiPairingFramework.PlaceZoneID]) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZoneID : NamiPairingFramework.NamiEngineConfig], Swift.Never>
  final public func usageLimits(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.NamiPlaceUsageLimits, Swift.Never>
  final public func placeMotionStatuses(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiZoneMotionStatus], Swift.Never>
  final public func motionStatus(for zoneIds: [NamiPairingFramework.PlaceZoneID]) -> Combine.AnyPublisher<[NamiPairingFramework.NamiZoneMotionStatus], Swift.Never>
  final public func placeKeys() -> Combine.AnyPublisher<[NamiPairingFramework.NamiPlaceKey], Swift.Never>
  final public func placeKeys(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.NamiPlaceKey], Swift.Never>
  final public func allPlaceUsers() -> Combine.AnyPublisher<[NamiPairingFramework.NamiPlaceUser], Swift.Never>
  final public func placeIntegrations(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.NamiPlaceIntegrations, Swift.Never>
  @discardableResult
  final public func refreshPlaces() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  @discardableResult
  final public func refreshPlace(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  @discardableResult
  final public func refreshAllPlaceUsers() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshPlaceUsers(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshAllDevices() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshDevices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshDevices(ofType: NamiPairingFramework.NamiDeviceType) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshDevices(uids: [NamiPairingFramework.DeviceUniversalID]) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func refreshPlaceKeys() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func createZone(placeId: NamiPairingFramework.PlaceID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZoneID, any Swift.Error>
  final public func createRoom(placeZoneId: NamiPairingFramework.PlaceZoneID, name: Swift.String, iconId: NamiPairingFramework.IconID) -> Combine.AnyPublisher<NamiPairingFramework.RoomID, any Swift.Error>
  final public func deleteAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func editPlace(updated place: NamiPairingFramework.NamiPlace) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func editZone(updated zone: NamiPairingFramework.NamiZone) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func editRoom(updated room: NamiPairingFramework.NamiRoom) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deletePlace(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func changeEngineConfig(for placeId: NamiPairingFramework.PlaceID, type: NamiPairingFramework.EngineType, level: Swift.Int) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func setSensitivity(for place: NamiPairingFramework.NamiPlace, sensitivityLevel: Swift.Int) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func createOrUpdateDeviceState(uid: NamiPairingFramework.DeviceUniversalID, state: Foundation.Data, seqTime: Swift.UInt64)
  final public func updateDevice(_ device: NamiPairingFramework.Device, placeId: NamiPairingFramework.PlaceID)
  final public func updatePlace(_ place: NamiPairingFramework.Place)
  final public func updateRoom(_ room: NamiPairingFramework.Room)
  final public func updateZone(_ zone: NamiPairingFramework.PlaceZone)
  final public func deleteDevice(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deleteDeviceSkippingAPICall(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deleteZone(_ zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deleteRoom(_ roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.NamiPlace, any Swift.Error>
  final public func deletePlaceUser(_ userId: NamiPairingFramework.UserID, placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func performPinVerification(for place: NamiPairingFramework.PlaceID, pinNamed name: Swift.String, pinValue: Swift.String) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func createPin(for place: NamiPairingFramework.PlaceID, pinNamed name: Swift.String, pinValue: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PinCredentialRecord, any Swift.Error>
  final public func listPins(in place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PinCredentialRecord], any Swift.Error>
  final public func deletePin(from place: NamiPairingFramework.PlaceID, pinId: NamiPairingFramework.PinCredentialID) -> Combine.AnyPublisher<NamiPairingFramework.PinCredentialRecord, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func updatePin(in place: NamiPairingFramework.PlaceID, pinId: NamiPairingFramework.PinCredentialID, newName: Swift.String?, newValue: Swift.String?) -> Combine.AnyPublisher<NamiPairingFramework.PinCredentialRecord, any Swift.Error>
  #endif
  final public func createWiFiCredentialsUpdateSession(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, any Swift.Error>
  final public func getAllWiFiCredentialsUpdateSessions() -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsSessionsResponse, any Swift.Error>
  final public func getWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, any Swift.Error>
  final public func deleteDeviceFromSession(uid: NamiPairingFramework.DeviceUniversalID, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, any Swift.Error>
  final public func createOrResetWiFiCredentialsUpdateSession(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, any Swift.Error>
  final public func resetWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, any Swift.Error>
  final public func clearAll()
  @objc deinit
}
public enum SDKError : Swift.Error, Foundation.LocalizedError {
  case missingPlaceId
  case sessionNotActivated
  case placeIdDoesntMatchSession
  case sessionActivateNoData
  case sessionActivateMalformedResponse(Foundation.Data)
  case roomUuidNotInTopology
  case incorrectDeviceUID
  case authenticationError(NamiPairingFramework.AuthenticationError)
  case storageError(NamiPairingFramework.StorageError)
  case incorrectTemplatesBaseUrl
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
public struct NamiPlaceIntegrations : Swift.Equatable {
  public init(placeId: NamiPairingFramework.PlaceID)
  public let placeId: NamiPairingFramework.PlaceID
  public let availableIntegrations: [NamiPairingFramework.IntegrationState]
  public static func == (a: NamiPairingFramework.NamiPlaceIntegrations, b: NamiPairingFramework.NamiPlaceIntegrations) -> Swift.Bool
}
public struct IntegrationState : Swift.Equatable, Swift.Hashable {
  public var id: Swift.Int64
  public var urn: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var integrationId: Swift.Int64
  public var isEnabled: Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public var provider: NamiPairingFramework.IntegrationProvider? {
    get
  }
  #endif
  public static func == (a: NamiPairingFramework.IntegrationState, b: NamiPairingFramework.IntegrationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct IntegrationProvider : Swift.Equatable, Swift.Hashable {
  public var id: Swift.Int64
  public var urn: Swift.String
  public var icon: Foundation.URL
  public var badge: Foundation.URL?
  public var name: Swift.String
  public var description: Swift.String?
  public var howToEnable: Swift.String?
  public static func == (a: NamiPairingFramework.IntegrationProvider, b: NamiPairingFramework.IntegrationProvider) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class InMemoryThreadDatasetStorage : NamiPairingFramework.ThreadSecureStorageProtocol {
  public static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  public static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, NamiPairingFramework.InMemoryThreadDatasetStorage.Thread_SecureStorageError>
  #endif
  public static func delete(at key: Swift.String, server: Swift.String)
  public typealias Thread_SecureStorageError = NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError
  public enum StorageError : Swift.Error {
    case cantRetrieve
    public static func == (a: NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError, b: NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
public struct PublicWiFiNetwork : Swift.Equatable {
  public var ssid: Swift.String
  public var rssi: Swift.Int32
  public var open: Swift.Bool
  public var bssid: Foundation.Data
  public init()
  public static func == (a: NamiPairingFramework.PublicWiFiNetwork, b: NamiPairingFramework.PublicWiFiNetwork) -> Swift.Bool
}
public struct PublicPairingAdvertisement : Swift.Equatable {
  public var version: Swift.Int32
  public var productID: Swift.Int32
  public var discriminator: Swift.Int32
  public init()
  public static func == (a: NamiPairingFramework.PublicPairingAdvertisement, b: NamiPairingFramework.PublicPairingAdvertisement) -> Swift.Bool
}
public struct ThreadScanResult : Swift.Equatable {
  public var panID: Swift.UInt32
  public var extendedPanID: Swift.UInt64
  public var networkName: Swift.String
  public var channel: Swift.UInt32
  public var version: Swift.UInt32
  public var extendedAddress: Swift.UInt64
  public var rssi: Swift.Int32
  public var lqi: Swift.UInt32
  public init()
  public static func == (a: NamiPairingFramework.ThreadScanResult, b: NamiPairingFramework.ThreadScanResult) -> Swift.Bool
}
public struct PublicPairingError : Swift.Equatable {
  public enum ErrorType : Swift.Equatable {
    public typealias RawValue = Swift.Int
    case unknownError
    case secureSessionError
    case cloudChallengeError
    case wifiScanError
    case wifiJoinError
    case wifiJoinPasswordError
    case wifiJoinIpError
    case threadScanError
    case threadJoinError
    case UNRECOGNIZED(Swift.Int)
    public init()
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    public var rawValue: Swift.Int {
      get
    }
    public static func == (a: NamiPairingFramework.PublicPairingError.ErrorType, b: NamiPairingFramework.PublicPairingError.ErrorType) -> Swift.Bool
  }
  public var error: NamiPairingFramework.PublicPairingError.ErrorType
  public static func == (a: NamiPairingFramework.PublicPairingError, b: NamiPairingFramework.PublicPairingError) -> Swift.Bool
}
public enum RemoteTemplateEntrypoint : Swift.String, NamiPairingFramework.RemoteTemplateEntrypointProtocol {
  case setupKitGuide
  case setupDeviceGuide
  case settings
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension NamiPairingFramework.ThreadOperationalDatasetProvider : NamiPairingFramework.PairingThreadOperationalDatasetProviderProtocol {
  public typealias Pairing_NamiThreadOperationalDataset = NamiPairingFramework.NamiThreadOperationalDataset
}
extension NamiPairingFramework.NamiThreadOperationalDataset : NamiPairingFramework.PairingNamiThreadOperationalDatasetProtocol {
}
public struct PairingHelper {
}
public struct NamiSdkConfig : NamiPairingFramework.RemoteTemplateUIConfigProtocol {
  public init(baseURL: Foundation.URL, countryCode: Swift.String, measurementSystem: NamiPairingFramework.NamiMeasurementSystem, clientId: Swift.String, language: Swift.String, appearance: NamiPairingFramework.NamiAppearance)
  public var baseURL: Foundation.URL
  public var countryCode: Swift.String
  public var measurementSystem: NamiPairingFramework.NamiMeasurementSystem
  public var clientId: Swift.String
  public var language: Swift.String
  public var appearance: NamiPairingFramework.NamiAppearance
  public var topologyRoomsSupported: Swift.Bool
}
public typealias PairingLocalStorage = NamiPairingFramework.DeviceConnectionsManagerStorageProtocol & NamiPairingFramework.RemoteTemplateStateRepositoryProtocol
public class NamiPairing<Container> where Container : NamiPairingFramework.PairingStepsContainer {
  public typealias PairingParameters = NamiPairingFramework.Tomonari<Container>.PairingParameters
  public var api: NamiPairingFramework.WebAPI
  public var wifiStorage: any NamiPairingFramework.PairingWiFiStorageProtocol
  public var threadDatasetProvider: any NamiPairingFramework.PairingThreadOperationalDatasetProviderProtocol
  public var devicePairingState: Combine.PassthroughSubject<NamiPairingFramework.Tomonari<Container>.DevicePairingState, any Swift.Error> {
    get
  }
  final public let setupGuideState: Combine.PassthroughSubject<NamiPairingFramework.SetupGuideEvent, any Swift.Error>
  @available(*, deprecated, renamed: "sessionPlaceId", message: "Not safe to use as new initializers are allowing to start SDK without session. In this case the value will be `nil`. Please switch to using `sessionPlaceId: PlaceID?` instead.")
  public var placeId: NamiPairingFramework.PlaceID {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var sessionPlaceId: NamiPairingFramework.PlaceID? {
    get
  }
  #endif
  public init<WiFiStorage, SecureStorage>(sessionCode: Swift.String, wifiStorage: WiFiStorage = InMemoryWiFiStorage(), threadDatasetStore: SecureStorage.Type = KeychainThreadDatasetStorage.self) throws where WiFiStorage : NamiPairingFramework.PairingWiFiStorageProtocol, SecureStorage : NamiPairingFramework.ThreadSecureStorageProtocol
  public init<Storage, SecureStorage>(api: NamiPairingFramework.WebAPI, localStorage: Storage, wifiStorage: any NamiPairingFramework.PairingWiFiStorageProtocol, threadDatasetProvider: any NamiPairingFramework.PairingThreadOperationalDatasetProviderProtocol, deviceConnectionsManager: any NamiPairingFramework.DeviceConnectionsManagerProtocol, threadSecureStorage: SecureStorage.Type = KeychainThreadDatasetStorage.self) where Storage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol, Storage : NamiPairingFramework.RemoteTemplateStateRepositoryProtocol, SecureStorage : NamiPairingFramework.ThreadSecureStorageProtocol
  convenience public init(tokenStore: any NamiPairingFramework.TokenStore, wifiStorage: any NamiPairingFramework.PairingWiFiStorageProtocol = InMemoryWiFiStorage())
  public func startPairing(roomId: Swift.String, deviceType: NamiPairingFramework.NamiDeviceType = .unknown, pairingSteps: Container, pairingParameters: NamiPairingFramework.NamiPairing<Container>.PairingParameters = .none) throws -> some SwiftUICore.View
  
  public func startPairing(placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID, roomId: NamiPairingFramework.RoomID, deviceType: NamiPairingFramework.NamiDeviceType = .unknown, pairingSteps: Container, pairingParameters: NamiPairingFramework.NamiPairing<Container>.PairingParameters = .none) -> some SwiftUICore.View
  
  @available(*, deprecated, renamed: "presentEntryPoint(_:placeId:config:pairingSteps:)", message: "This method is replaced with `presentEntryPoint(_:placeId:config:pairingSteps:)` which allows passing optional `PlaceID` and throwing on mismatch/missing when session is not active.")
  @_Concurrency.MainActor public func presentEntryPoint(entrypoint: any NamiPairingFramework.RemoteTemplateEntrypointProtocol, config: NamiPairingFramework.NamiSdkConfig, pairingSteps: Container) -> some SwiftUICore.View
  
  @available(*, deprecated, message: "This method is deprecated and will be removed in a future version. Not to be replaced by any other method as the system is not supporting this functionality anymore.")
  public func startPositioning(deviceName: Swift.String, deviceUid: Swift.String, pairingSteps: Container, onPositioningEnded: @escaping (NamiPairingFramework.PositioningResult) -> Swift.Void) throws -> some SwiftUICore.View
  
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func presentEntryPoint(_ entrypoint: any NamiPairingFramework.RemoteTemplateEntrypointProtocol, placeId: NamiPairingFramework.PlaceID? = nil, config: NamiPairingFramework.NamiSdkConfig, pairingSteps: Container) throws -> some SwiftUICore.View
  
  #endif
  @objc deinit
}
extension NamiPairingFramework.RemoteTemplateUI_Zone {
  public init(zone: NamiPairingFramework.NamiZone, rooms: [NamiPairingFramework.NamiRoom], devices: [NamiPairingFramework.NamiDevice], devicesState: [NamiPairingFramework.NamiDeviceState])
}
extension NamiPairingFramework.RemoteTemplateUI_Room {
  public init(room: NamiPairingFramework.NamiRoom, devices: [NamiPairingFramework.NamiDevice], devicesState: [NamiPairingFramework.NamiDeviceState])
}
extension NamiPairingFramework.RemoteTemplateUI_DeviceState {
  public init(deviceState: NamiPairingFramework.NamiDeviceState)
}
extension NamiPairingFramework.RemoteTemplateUI_Device {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(device: NamiPairingFramework.NamiDevice, deviceState: NamiPairingFramework.NamiDeviceState?)
  #endif
}
public enum NamiPermission : Swift.String, Swift.CaseIterable, Swift.Codable {
  case pairDevice
  case view
  case update
  case destroy
  case destroyDependants
  case controlAlerting
  case linkClients
  case createSessionCodes
  case communicateWithDevices
  case updateMembership
  case updateWiFiCredential
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias AllCases = [NamiPairingFramework.NamiPermission]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [NamiPairingFramework.NamiPermission] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension Swift.Array where Element == Swift.String {
  public var knownPermissions: [NamiPairingFramework.NamiPermission] {
    get
  }
}
public typealias NamiPermissionsSet = [NamiPairingFramework.NamiPermission]
final public class InMemoryWiFiStorage : NamiPairingFramework.PairingWiFiStorageProtocol {
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  final public func save(password: Swift.String?, for networkSSID: Swift.String)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func password(for networkSSID: Swift.String) -> Swift.String?
  #endif
  final public func removeAll()
  @objc deinit
}
extension NamiPairingFramework.WebAPI : NamiPairingFramework.PairingWebAPIProtocol {
  public typealias Pairing_DevicesQueryProtocol = NamiPairingFramework.DevicesQuery
  public typealias Pairing_DeviceResponse = NamiPairingFramework.Device
  public typealias Pairing_DevicesResponse = NamiPairingFramework.DevicesResponse
  public typealias Pairing_PairDeviceResponse = NamiPairingFramework.PairDeviceResponse
  public typealias Pairing_Place = NamiPairingFramework.Place
  public typealias Pairing_PlaceZone = NamiPairingFramework.PlaceZone
  public typealias Pairing_PairingChallengeResponse = NamiPairingFramework.PairingChallengeResponse
  public typealias Pairing_WiFiCredentialsUpdateSession = NamiPairingFramework.WiFiCredentialsUpdateSession
  final public func placeDetails(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  final public func listDevices(query: any NamiPairingFramework.DevicesQueryProtocol) -> Combine.AnyPublisher<NamiPairingFramework.DevicesResponse, any Swift.Error>
  final public func listPlaceZones(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZone], any Swift.Error>
}
extension NamiPairingFramework.WebAPI : NamiPairingFramework.RemoteTemplateUI_WebAPIProtocol {
  public typealias RepresentablePlace = NamiPairingFramework.Place
  public typealias RepresentableZone = NamiPairingFramework.PlaceZone
  public typealias RepresentableRoom = NamiPairingFramework.Room
  public typealias RepresentableMembershipResponse = NamiPairingFramework.MembershipResponse
  public typealias RepresentableInvitePeek = NamiPairingFramework.InvitePeek
  public typealias RepresentableDevice = NamiPairingFramework.Device
  public typealias RepresentableDevicesQuery = NamiPairingFramework.DevicesQuery
  public typealias RepresentableDevicesResponse = NamiPairingFramework.DevicesResponse
  public typealias RepresentableDevicesCommandResponse = NamiPairingFramework.DevicesCommandResponse
  public typealias RepresentablePlaceAutomation = NamiPairingFramework.Automation
  public typealias RepresentableZoneMotionEvent = NamiPairingFramework.ZoneMotionEvents
  public typealias RepresentablePlaceMotionHistory = NamiPairingFramework.PlaceMotionHistory
  public typealias RepresentablePlaceMotionAggregates = NamiPairingFramework.PlaceMotionAggregates
  public typealias RepresentableZoneMotionAggregates = NamiPairingFramework.ZoneMotionAggregates
  public typealias RepresentableInviteLink = NamiPairingFramework.InviteLink
  public typealias RepresentableRestEventsResponse = NamiPairingFramework.RestEventsResponse
  public typealias RepresentableRestInsightsResponse = NamiPairingFramework.RestInsightsResponse
  public typealias RepresentableDeviceAttributeStateResponse = NamiPairingFramework.DeviceAttributeStateResponse
  public typealias RepresentablePlacesResponse = NamiPairingFramework.PlacesResponse
  public typealias RepresentableAlertMode = NamiPairingFramework.AlertMode
  public typealias RepresentableWiFiCredentialsUpdateSession = NamiPairingFramework.WiFiCredentialsUpdateSession
  public typealias RepresentableWiFiCredentialsUpdateSessionResponse = NamiPairingFramework.WiFiCredentialsSessionsResponse
  final public func moveDevices(deviceUIDs: [NamiPairingFramework.DeviceUniversalID], roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<[NamiPairingFramework.Device], any Swift.Error>
  final public func updatePlaceUser(for placeId: NamiPairingFramework.PlaceID, userId: NamiPairingFramework.UserID, roleId: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func generateInvite(to place: NamiPairingFramework.PlaceID, invitee name: Swift.String, roleId: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.InviteLink, any Swift.Error>
  final public func getPlaceMotionDataAggregates(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.PlaceMotionAggregates, any Swift.Error>
  final public func getZoneMotionDataAggregates(for zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.ZoneMotionAggregates, any Swift.Error>
  final public func getZoneMotionHistory(for zoneIds: [NamiPairingFramework.PlaceZoneID], from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<[NamiPairingFramework.ZoneMotionEvents], any Swift.Error>
  final public func listAutomation(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.Automation], any Swift.Error>
  final public func createAutomation(placeId: NamiPairingFramework.PlaceID, alertMode: NamiPairingFramework.AlertMode, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.Automation, any Swift.Error>
  final public func updateAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, alertMode: NamiPairingFramework.AlertMode, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.Automation, any Swift.Error>
  final public func changeAutomationActive(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, active: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.Automation, any Swift.Error>
  final public func removeAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<NamiPairingFramework.Automation, any Swift.Error>
}
extension NamiPairingFramework.WebAPI : NamiPairingFramework.DeviceConnectionsManagerWebAPIProtocol {
  public typealias DCM_DevicesQuery = NamiPairingFramework.DevicesQuery
  public typealias DCM_DevicesResponse = NamiPairingFramework.DevicesResponse
  public typealias DCM_DevicesCommandResponse = NamiPairingFramework.DevicesCommandResponse
  public typealias DCM_CloudPlaceKey = NamiPairingFramework.CloudPlaceKey
}
@_hasMissingDesignatedInitializers final public class KeychainThreadDatasetStorage : NamiPairingFramework.ThreadSecureStorageProtocol {
  public enum StorageError : Swift.Error {
    case itemNotFound
    case unexpectedData
    case keychainStatus(Darwin.OSStatus)
  }
  public typealias Thread_SecureStorageError = NamiPairingFramework.KeychainThreadDatasetStorage.StorageError
  public static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  public static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, NamiPairingFramework.KeychainThreadDatasetStorage.StorageError>
  #endif
  public static func delete(at key: Swift.String, server: Swift.String)
  @objc deinit
}
public enum StorageError : Swift.Error {
  case wifiCredentialsStorage
  case threadDatasetStorage
  case deviceConnectionsStorage
  public var localizedDescription: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.StorageError, b: NamiPairingFramework.StorageError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NamiDeviceCapability : Swift.Equatable {
  case deviceInformation
  case diagnostics
  case wifiSensing
  case relay
  case sentinelAlarm
  case devkitLed
  case devkitAlarm
  case widar
  case doorSensorOpenClosed
  case doorSensorTempered
  case powerSupply
  case warning
  public var endpoint: NamiPairingFramework.NamiDeviceEndpoint {
    get
  }
  public static var `default`: [NamiPairingFramework.NamiDeviceCapability]
  public static var plug: [NamiPairingFramework.NamiDeviceCapability]
  public static var devkit: [NamiPairingFramework.NamiDeviceCapability]
  public static var pod: [NamiPairingFramework.NamiDeviceCapability]
  public static var alarmPod: [NamiPairingFramework.NamiDeviceCapability]
  public static var sensePod: [NamiPairingFramework.NamiDeviceCapability]
  public static var contactSensor: [NamiPairingFramework.NamiDeviceCapability]
  public static var motionSensor: [NamiPairingFramework.NamiDeviceCapability]
  public static var keypad: [NamiPairingFramework.NamiDeviceCapability]
  public static var widarSensor: [NamiPairingFramework.NamiDeviceCapability]
  public static func == (a: NamiPairingFramework.NamiDeviceCapability, b: NamiPairingFramework.NamiDeviceCapability) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NamiDeviceEndpoint : Swift.Equatable {
  public enum EndpointType : Swift.Equatable {
    public enum ReadableCluster {
      case stateOnOff
      case stateColorControl
      case stateLevelControlForLighting
      case stateDeviceInfo
      case stateWarning
      case stateWifiInfo
      case stateThreadNetworkInfo
      case stateWiDar
      case stateSensingConfig
      case stateDoorSensorOpenClosed
      case stateDoorSensorTempered
      case statePowerSupplyInfo
      public static func == (a: NamiPairingFramework.NamiDeviceEndpoint.EndpointType.ReadableCluster, b: NamiPairingFramework.NamiDeviceEndpoint.EndpointType.ReadableCluster) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum WritableCluster {
      case changeOnOff
      case changeColorControl
      case changeLevelControlForLighting
      case changeWiDar
      case changeWarning
      case changeMotionSensingConfig
      public static func == (a: NamiPairingFramework.NamiDeviceEndpoint.EndpointType.WritableCluster, b: NamiPairingFramework.NamiDeviceEndpoint.EndpointType.WritableCluster) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static func == (a: NamiPairingFramework.NamiDeviceEndpoint.EndpointType, b: NamiPairingFramework.NamiDeviceEndpoint.EndpointType) -> Swift.Bool
  }
  public var endpoint: Swift.Int32
  public var readable: [NamiPairingFramework.NamiDeviceEndpoint.EndpointType.ReadableCluster]
  public var writable: [NamiPairingFramework.NamiDeviceEndpoint.EndpointType.WritableCluster]
  public static func == (a: NamiPairingFramework.NamiDeviceEndpoint, b: NamiPairingFramework.NamiDeviceEndpoint) -> Swift.Bool
}
public enum MeasurementSystem {
  case metric
  case uk
  case us
  public static func == (a: NamiPairingFramework.MeasurementSystem, b: NamiPairingFramework.MeasurementSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SwiftUICore.EnvironmentValues {
  public var measurementSystem: NamiPairingFramework.MeasurementSystem {
    get
  }
}
extension Foundation.Locale {
  #if compiler(>=5.3) && $NonescapableTypes
  public var systemOfMeasurements: Swift.String? {
    get
  }
  #endif
  public static let metricMeasurementSystem: Swift.String
  public static let usMeasurementSystem: Swift.String
  public static let ukMeasurementSystem: Swift.String
}
public enum NamiAlertReason : Swift.String, Swift.Comparable, Swift.Codable {
  case motion
  case device
  public static func < (lhs: NamiPairingFramework.NamiAlertReason, rhs: NamiPairingFramework.NamiAlertReason) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct DevicePeerInfo {
  public init(wifiMac: Swift.UInt64, rssi: Swift.Int32)
  public var wifiMac: Swift.UInt64
  public var rssi: Swift.Int32
}
public enum NamiMeasurementSystem : Swift.String, Swift.CaseIterable, Swift.Identifiable {
  case metric
  case imperial
  public var id: NamiPairingFramework.NamiMeasurementSystem {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias AllCases = [NamiPairingFramework.NamiMeasurementSystem]
  public typealias ID = NamiPairingFramework.NamiMeasurementSystem
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [NamiPairingFramework.NamiMeasurementSystem] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum KitCategory : Swift.String, Swift.CaseIterable {
  case bss
  case hms
  public var name: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias AllCases = [NamiPairingFramework.KitCategory]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [NamiPairingFramework.KitCategory] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct KitPairedDeviceInfo : Swift.Codable {
  public var deviceName: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public var deviceUrn: Swift.String
  public var roomName: Swift.String
  public init(from decoder: any Swift.Decoder) throws
  public init(deviceName: Swift.String, productId: NamiPairingFramework.DeviceProductID, deviceUrn: Swift.String, roomName: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct CodeLinkingInfo : Swift.Decodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(code: NamiPairingFramework.SignInCode, requestedAt: Foundation.Date, expiresAt: Foundation.Date, ip: Swift.String? = nil, browser: Swift.String? = nil, os: Swift.String? = nil, city: Swift.String? = nil, country: Swift.String? = nil)
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public var code: NamiPairingFramework.SignInCode
  public var requestedAt: Foundation.Date
  public var expiresAt: Foundation.Date
  public var ip: Swift.String?
  public var browser: Swift.String?
  public var os: Swift.String?
  public var city: Swift.String?
  public var country: Swift.String?
  public static func == (a: NamiPairingFramework.CodeLinkingInfo, b: NamiPairingFramework.CodeLinkingInfo) -> Swift.Bool
}
extension NamiPairingFramework.NamiDeviceModel {
  public static let preset: [NamiPairingFramework.NamiDeviceModel]
}
public enum NamiDeviceConnectivity {
  case hasWiFi
  case hasThread
  public static func == (a: NamiPairingFramework.NamiDeviceConnectivity, b: NamiPairingFramework.NamiDeviceConnectivity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.CharacterSet {
  public static var hexDigits: Foundation.CharacterSet
}
extension Swift.String {
  public func replacingCharacters(from characterSet: Foundation.CharacterSet, with replacement: Swift.String) -> Swift.String
  public var trimmingWhitespaces: Swift.String {
    get
  }
}
extension Combine.Publisher {
  public func first<T>(_ keyPath: Swift.KeyPath<Self.Output, T>, toEqual value: T) -> Combine.Publishers.FirstWhere<Combine.Publishers.MapKeyPath<Self, T>> where T : Swift.Equatable
  public func embed<Value>(as keyPath: Swift.WritableKeyPath<Value, Self.Output>, on value: Value) -> Combine.Publishers.Map<Self, Value>
  #if compiler(>=5.3) && $NonescapableTypes
  public func embed<Value>(as optionalKeyPath: Swift.WritableKeyPath<Value, Self.Output?>, on value: Value) -> Combine.Publishers.Map<Self, Value>
  #endif
  public func retry(_ retries: Swift.Int, if condition: @escaping (Self.Failure) -> Swift.Bool) -> Combine.Publishers.RetryIf<Self>
  public func switchMap<U>(_ transformation: @escaping (Self.Output) -> U) -> Combine.Publishers.FlatMapLatest<Self, U> where U : Combine.Publisher, Self.Failure == U.Failure
}
extension Combine.Publishers {
  public struct FlatMapLatest<Upstream, P> : Combine.Publisher where Upstream : Combine.Publisher, P : Combine.Publisher, Upstream.Failure == P.Failure {
    public typealias Output = P.Output
    public typealias Failure = Upstream.Failure
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, P.Failure == S.Failure, P.Output == S.Input
  }
}
extension Combine.Publishers {
  public struct RetryIf<Upstream> : Combine.Publisher where Upstream : Combine.Publisher {
    public typealias Output = Upstream.Output
    public typealias Failure = Upstream.Failure
    public let publisher: Upstream
    public let retries: Swift.Int
    public let condition: (Upstream.Failure) -> Swift.Bool
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Upstream.Failure == S.Failure, Upstream.Output == S.Input
  }
}
public enum TimeZoneLoadingError : Swift.Error {
  case fileNotFound
  case decodingError
  case noTimezonesAvailable
  public static func == (a: NamiPairingFramework.TimeZoneLoadingError, b: NamiPairingFramework.TimeZoneLoadingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TimeZoneLoader {
  public static let shared: NamiPairingFramework.TimeZoneLoader
  #if compiler(>=5.3) && $NonescapableTypes
  public func findTimeZone(byId id: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.NamiTimeZone?, Swift.Never>
  #endif
  public func getTimezones() -> Combine.AnyPublisher<[NamiPairingFramework.NamiTimeZone], NamiPairingFramework.TimeZoneLoadingError>
  @objc deinit
}
public struct TimeZoneLocation : Swift.Decodable, Swift.Hashable {
  public init(from decoder: any Swift.Decoder) throws
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(code: Swift.String?)
  #endif
  public let countryCode: Swift.String
  public let countryName: Swift.String?
  public static func == (a: NamiPairingFramework.TimeZoneLocation, b: NamiPairingFramework.TimeZoneLocation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NamiTimeZone : Swift.Decodable, Swift.Hashable {
  public init(from decoder: any Swift.Decoder) throws
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: Swift.String, city: Swift.String, location: NamiPairingFramework.TimeZoneLocation?, continent: Swift.String?, gmtOffset: Swift.String, aliases: [Swift.String])
  #endif
  public let id: Swift.String
  public let city: Swift.String
  public let location: NamiPairingFramework.TimeZoneLocation?
  public let continent: Swift.String?
  public let gmtOffset: Swift.String
  public let aliases: [Swift.String]
  public var timeZone: Foundation.TimeZone {
    get
  }
  public static func == (lhs: NamiPairingFramework.NamiTimeZone, rhs: NamiPairingFramework.NamiTimeZone) -> Swift.Bool
  public func displayName() -> Swift.String
  public func displayNameWithGMT() -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol HexValue {
  static func decodeHex(from c: any Swift.SingleValueDecodingContainer) throws -> Self
  func encodeHex(to c: inout any Swift.SingleValueEncodingContainer) throws
}
extension Foundation.Data : NamiPairingFramework.HexValue {
  public static func decodeHex(from c: any Swift.SingleValueDecodingContainer) throws -> Foundation.Data
  public func encodeHex(to c: inout any Swift.SingleValueEncodingContainer) throws
}
#if compiler(>=5.3) && $NonescapableTypes
extension Swift.Optional : NamiPairingFramework.HexValue where Wrapped == Foundation.Data {
  public static func decodeHex(from c: any Swift.SingleValueDecodingContainer) throws -> Swift.Optional<Foundation.Data>
  public func encodeHex(to c: inout any Swift.SingleValueEncodingContainer) throws
}
#endif
@propertyWrapper public struct HexEncoded<T> : Swift.Codable where T : NamiPairingFramework.HexValue, T : Swift.Decodable, T : Swift.Encodable {
  public var wrappedValue: T
  public init(wrappedValue: T)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public typealias TokenString = Swift.String
public typealias UserID = Swift.Int64
public typealias UserIconID = Swift.Int64
public typealias URN = Swift.String
public typealias PlaceID = Swift.Int64
public typealias UserPermissionsSet = [Swift.String]
public typealias PlaceZoneID = Swift.Int64
public typealias ThemeID = Swift.Int64
public typealias IconID = Swift.Int64
public typealias PlaceUserID = Swift.Int64
public typealias RoomID = Swift.Int64
public typealias DeviceProductID = Swift.Int64
public typealias DeviceID = Swift.Int64
public typealias NamiAlertID = Swift.Int64
public typealias EventID = Swift.Int64
public typealias InviteCode = Swift.String
public typealias SessionCode = Swift.String
public typealias SignInCode = Swift.String
public typealias SessionPermission = Swift.String
public typealias WiFiCredentialsUpdateSessionID = Swift.Int64
public typealias PropertyTypeID = Swift.Int64
public typealias PropertyElevationID = Swift.Int64
public typealias PropertyAvgFloorAreaID = Swift.Int64
public typealias AutomationID = Swift.Int64
public typealias PetTypeID = Swift.Int64
public typealias PinCredentialID = Swift.Int64
public struct EntryDelay : Swift.RawRepresentable, Swift.Equatable, Swift.Codable {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let `default`: NamiPairingFramework.EntryDelay
  public typealias RawValue = Swift.UInt
}
public struct ExitDelay : Swift.RawRepresentable, Swift.Equatable, Swift.Codable {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let `default`: NamiPairingFramework.ExitDelay
  public typealias RawValue = Swift.UInt
}
public struct DeviceUniversalID : Swift.Equatable, Swift.Decodable, Swift.Hashable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ string: Swift.String)
  #endif
  public init(_ number: Swift.UInt64)
  public init(from decoder: any Swift.Decoder) throws
  public var macFormatted: Swift.String {
    get
  }
  public var uInt64Formatted: Swift.UInt64 {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension NamiPairingFramework.DeviceUniversalID {
  public static func == (lhs: NamiPairingFramework.DeviceUniversalID, rhs: NamiPairingFramework.DeviceUniversalID) -> Swift.Bool
}
extension NamiPairingFramework.DeviceUniversalID {
  public func hash(into hasher: inout Swift.Hasher)
}
extension NamiPairingFramework.DeviceUniversalID : Swift.Comparable {
  public static func < (lhs: NamiPairingFramework.DeviceUniversalID, rhs: NamiPairingFramework.DeviceUniversalID) -> Swift.Bool
}
extension NamiPairingFramework.DeviceUniversalID : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension NamiPairingFramework.DeviceUniversalID {
  public static func randomValue() -> NamiPairingFramework.DeviceUniversalID
}
extension NamiPairingFramework.DeviceUniversalID : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Swift.UInt64 {
  public init(_ uid: NamiPairingFramework.DeviceUniversalID)
}
public struct NamiDeviceModel : Swift.Equatable {
  public init(codeName: Swift.String, hardwareModel: Swift.String, productLabel: Swift.String, productId: NamiPairingFramework.DeviceProductID, deviceType: NamiPairingFramework.NamiDeviceType, connectivity: [NamiPairingFramework.NamiDeviceConnectivity])
  public var codeName: Swift.String
  public var hardwareModel: Swift.String
  public var productLabel: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public var deviceType: NamiPairingFramework.NamiDeviceType
  public var connectivity: [NamiPairingFramework.NamiDeviceConnectivity]
  public static func == (a: NamiPairingFramework.NamiDeviceModel, b: NamiPairingFramework.NamiDeviceModel) -> Swift.Bool
}
extension NamiPairingFramework.NamiDeviceModel {
  public static let unknown: NamiPairingFramework.NamiDeviceModel
}
public enum NamiAppearance : Swift.String, Swift.Equatable, Swift.CaseIterable, Swift.Identifiable {
  case light
  case dark
  case system
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public var rawValue: Swift.String {
    get
  }
  public var resolve: NamiPairingFramework.NamiAppearance {
    get
  }
  public var id: NamiPairingFramework.NamiAppearance {
    get
  }
  public typealias AllCases = [NamiPairingFramework.NamiAppearance]
  public typealias ID = NamiPairingFramework.NamiAppearance
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [NamiPairingFramework.NamiAppearance] {
    get
  }
}
public enum NamiDeviceType : Swift.CaseIterable {
  case unknown
  case contactSensor
  case motionSensor
  case meshSensor
  case securityPod
  case alarmPod
  case sensePod
  case wifiSensor
  case keypad
  case widarSensor
  public static var allCases: [NamiPairingFramework.NamiDeviceType] {
    get
  }
  public static var allSensorDevices: [NamiPairingFramework.NamiDeviceType] {
    get
  }
  public static var allThreadDevices: [NamiPairingFramework.NamiDeviceType] {
    get
  }
  public static var allAccessoryDevices: [NamiPairingFramework.NamiDeviceType] {
    get
  }
  public var capabilities: [NamiPairingFramework.NamiDeviceCapability] {
    get
  }
  public var name: Swift.String {
    get
  }
  public var localizedName: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.NamiDeviceType, b: NamiPairingFramework.NamiDeviceType) -> Swift.Bool
  public typealias AllCases = [NamiPairingFramework.NamiDeviceType]
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NamiAlertMode : Swift.Int, Swift.Comparable, Swift.Codable {
  case armed
  case stay
  case standby
  public init(mode: Swift.String)
  public static func < (lhs: NamiPairingFramework.NamiAlertMode, rhs: NamiPairingFramework.NamiAlertMode) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum NamiOutletType : Swift.CaseIterable {
  case typeE
  case typeF
  case typeG
  case typeB
  case typeA
  case unknown
  public static func == (a: NamiPairingFramework.NamiOutletType, b: NamiPairingFramework.NamiOutletType) -> Swift.Bool
  public typealias AllCases = [NamiPairingFramework.NamiOutletType]
  nonisolated public static var allCases: [NamiPairingFramework.NamiOutletType] {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class OutletTypeMapper {
  public static let shared: NamiPairingFramework.OutletTypeMapper
  public func getOutletType(by countryCode: Swift.String) -> NamiPairingFramework.NamiOutletType
  @objc deinit
}
public protocol RemoteTemplateEntrypointProtocol : Swift.RawRepresentable where Self.RawValue == Swift.String {
}
extension NamiPairingFramework.RemoteTemplateEntrypointProtocol {
  public func url(base: Foundation.URL) -> Foundation.URL
}
public protocol PlacesResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Place : NamiPairingFramework.PlaceProtocol
  associatedtype UserPermissionsSet : Swift.Decodable, Swift.Encodable
  associatedtype PlaceUserRole : NamiPairingFramework.PlaceUserRoleProtocol
  var places: [Self.Place] { get }
  var permissions: [NamiPairingFramework.URN : Self.UserPermissionsSet] { get }
  var roles: [NamiPairingFramework.URN : [Self.PlaceUserRole]] { get }
}
public protocol PlaceProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Zone : NamiPairingFramework.ZoneProtocol
  associatedtype UsageLimits : NamiPairingFramework.PlaceUsageLimitsProtocol
  associatedtype WiredPlaceKeys : NamiPairingFramework.WiredPlaceKeysProtocol
  associatedtype CloudPlaceKey : NamiPairingFramework.CloudPlaceKeyProtocol
  var id: NamiPairingFramework.PlaceID { get }
  var urn: Swift.String { get }
  var name: Swift.String { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
  var themeId: NamiPairingFramework.ThemeID { get }
  var iconId: NamiPairingFramework.IconID { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var timeZone: Swift.String? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var propertyTypeId: NamiPairingFramework.PropertyTypeID? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var propertyElevationId: NamiPairingFramework.PropertyElevationID? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var petTypeId: NamiPairingFramework.PetTypeID? { get }
  #endif
  var zones: [Self.Zone] { get }
  var limits: Self.UsageLimits { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var placeKeys: Self.WiredPlaceKeys? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var decodedPlaceKeys: [Self.CloudPlaceKey]? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var entryDelay: NamiPairingFramework.EntryDelay? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var exitDelay: NamiPairingFramework.ExitDelay? { get }
  #endif
}
public protocol PlaceUsageLimitsProtocol : Swift.Decodable, Swift.Encodable {
  var membership: Swift.UInt { get }
}
public protocol ZoneProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Room : NamiPairingFramework.RoomProtocol
  associatedtype AlertMode : NamiPairingFramework.AlertModeProtocol
  associatedtype EngineConfig : NamiPairingFramework.EngineConfigProtocol
  associatedtype MotionStatus : NamiPairingFramework.ZoneMotionStatusProtocol
  var id: NamiPairingFramework.PlaceZoneID { get }
  var externalId: Swift.String { get }
  var urn: Swift.String { get }
  var name: Swift.String { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var rooms: [Self.Room] { get }
  var alertMode: Self.AlertMode { get }
  var engineConfig: Self.EngineConfig { get }
  var motionStatus: Self.MotionStatus { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
}
public protocol AlertModeProtocol : Swift.Decodable, Swift.Encodable {
}
public protocol EngineConfigProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype EngineType : NamiPairingFramework.EngineTypeProtocol
  var type: Self.EngineType { get }
  var sensitivityLevel: Swift.Int { get }
}
public protocol EngineTypeProtocol : Swift.Decodable, Swift.Encodable {
}
public protocol ZoneMotionStatusProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype ZoneHealth : NamiPairingFramework.ZoneHealthProtocol
  #if compiler(>=5.3) && $NonescapableTypes
  var detection: Swift.Bool? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var startedAt: Foundation.Date? { get }
  #endif
  var health: Self.ZoneHealth { get }
}
public protocol ZoneHealthProtocol : Swift.Decodable, Swift.Encodable {
}
public protocol RoomProtocol : Swift.Decodable, Swift.Encodable {
  var id: NamiPairingFramework.RoomID { get }
  var externalId: Swift.String { get }
  var urn: Swift.String { get }
  var name: Swift.String { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var zoneId: NamiPairingFramework.PlaceZoneID { get }
  var iconId: NamiPairingFramework.IconID { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
}
public protocol DeviceProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype CloudConnection : NamiPairingFramework.DeviceCloudConnectionStatusProtocol
  associatedtype State : NamiPairingFramework.DeviceCloudStateProtocol
  associatedtype Model : NamiPairingFramework.DeviceModelProtocol
  var id: NamiPairingFramework.DeviceID { get }
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var urn: Swift.String { get }
  var roomId: NamiPairingFramework.RoomID { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var bleDiscriminator: Swift.Int32? { get }
  #endif
  var name: Swift.String { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
  var model: Self.Model { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var cloudConnection: Self.CloudConnection? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var deviceState: Self.State? { get }
  #endif
}
public protocol DeviceCloudConnectionStatusProtocol : Swift.Decodable, Swift.Encodable {
  var isConnected: Swift.Bool { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var updatedAt: Foundation.Date? { get }
  #endif
}
public protocol DeviceCloudStateProtocol : Swift.Decodable, Swift.Encodable {
  var payload: Foundation.Data { get }
  var seqTime: Swift.UInt64 { get }
  var updatedAt: Foundation.Date { get }
}
public protocol DeviceModelProtocol : Swift.Decodable, Swift.Encodable {
  var codeName: Swift.String { get }
  var productLabel: Swift.String { get }
  var productId: NamiPairingFramework.DeviceProductID { get }
}
public protocol DevicesResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Device : NamiPairingFramework.DeviceProtocol
  var devices: [Self.Device] { get }
  var total: Swift.Int { get }
  var pageSize: Swift.Int { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var cursor: Swift.String? { get }
  #endif
}
public protocol DevicesQueryProtocol : Swift.Decodable, Swift.Encodable {
  var placeIds: [NamiPairingFramework.PlaceID] { get set }
  var zoneIds: [NamiPairingFramework.PlaceZoneID] { get set }
  var roomIds: [NamiPairingFramework.RoomID] { get set }
  var uids: [NamiPairingFramework.DeviceUniversalID] { get set }
  #if compiler(>=5.3) && $NonescapableTypes
  var cursor: Swift.String? { get set }
  #endif
}
public protocol DevicesCommandResponseProtocol : Swift.Decodable {
  associatedtype Result : NamiPairingFramework.DevicesCommandResponseResultProtocol
  var seqTime: Swift.UInt64 { get }
  var results: [Self.Result] { get }
}
public protocol DevicesCommandResponseResultProtocol : Swift.Decodable {
  associatedtype DeviceCommandResponseContent : NamiPairingFramework.DeviceCommandResponseContentProtocol
  var devices: [NamiPairingFramework.DeviceUniversalID : Self.DeviceCommandResponseContent] { get }
}
public protocol DeviceCommandResponseContentProtocol : Swift.Decodable {
  associatedtype DeviceCommandResponseError : NamiPairingFramework.DeviceCommandResponseErrorProtocol
  var success: Swift.Bool { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var error: Self.DeviceCommandResponseError? { get }
  #endif
}
public protocol DeviceCommandResponseErrorProtocol : Swift.Decodable, Swift.Encodable, Swift.Error {
  var error: Swift.String { get }
  var errorCode: Swift.String { get }
}
public protocol MembershipResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype User : NamiPairingFramework.PlaceUserProtocol
  associatedtype Invite : NamiPairingFramework.InviteLinkProtocol
  var users: [Self.User] { get }
  var invites: [Self.Invite] { get }
}
public protocol UserIdentityProtocol : Swift.Decodable, Swift.Encodable {
  var provider: Swift.String { get }
  var providerUserId: Swift.String { get }
}
public protocol FeatureFlagProtocol : Swift.Decodable, Swift.Encodable {
  var name: Swift.String { get }
  var resource: Swift.String { get }
}
public protocol PlaceUserProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Role : NamiPairingFramework.PlaceUserRoleProtocol
  #if compiler(>=5.3) && $NonescapableTypes
  var urn: Swift.String? { get }
  #endif
  var id: NamiPairingFramework.PlaceUserID { get }
  var userId: NamiPairingFramework.UserID { get }
  var iconId: NamiPairingFramework.UserIconID { get }
  var themeId: NamiPairingFramework.ThemeID { get }
  var role: Self.Role { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var name: Swift.String { get }
}
public protocol PlaceUserRoleProtocol : Swift.Decodable, Swift.Encodable {
  var id: Swift.String { get }
  var name: Swift.String { get }
}
public protocol InviteLinkProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Role : NamiPairingFramework.PlaceUserRoleProtocol
  var code: NamiPairingFramework.InviteCode { get }
  var name: Swift.String { get }
  var role: Self.Role { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var placeName: Swift.String? { get }
  #endif
  var state: Swift.String { get }
  var inviteUrl: Foundation.URL { get }
  var expiresAt: Foundation.Date { get }
}
public protocol InvitePeekProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Role : NamiPairingFramework.PlaceUserRoleProtocol
  var code: NamiPairingFramework.InviteCode { get }
  var name: Swift.String { get }
  var role: Self.Role { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var placeName: Swift.String { get }
  var placeIconId: NamiPairingFramework.IconID { get }
}
public protocol AutomationProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Trigger : NamiPairingFramework.AutomationTriggerProtocol
  associatedtype Reaction : NamiPairingFramework.AutomationReactionProtocol
  var id: NamiPairingFramework.AutomationID { get }
  var urn: Swift.String { get }
  var trigger: Self.Trigger { get }
  var reactions: [Self.Reaction] { get }
  var active: Swift.Bool { get }
}
public protocol AutomationTriggerProtocol : Swift.Decodable, Swift.Encodable {
  var type: Swift.String { get }
  var hour: Swift.Int { get }
  var minute: Swift.Int { get }
  var daysOfWeek: [Swift.String] { get }
}
public protocol AutomationReactionProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Action : NamiPairingFramework.AutomationActionProtocol
  var uuid: Swift.String { get }
  var targetType: Swift.String { get }
  var targetIds: [NamiPairingFramework.PlaceZoneID] { get }
  var action: Self.Action { get }
}
public protocol AutomationActionProtocol : Swift.Decodable, Swift.Encodable {
  var type: Swift.String { get }
  var mode: Swift.String { get }
}
public protocol ActivityEventProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype ZoneHealth : NamiPairingFramework.ZoneHealthProtocol
  #if compiler(>=5.3) && $NonescapableTypes
  var uuid: Foundation.UUID? { get }
  #endif
  var startedAt: Foundation.Date { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var endedAt: Foundation.Date? { get }
  #endif
  var detection: Swift.Bool { get }
  var health: Self.ZoneHealth { get }
}
public protocol ZoneMotionEventProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Event : NamiPairingFramework.ActivityEventProtocol
  var motionEvents: [Self.Event] { get }
  var occupancyEvents: [Self.Event] { get }
}
public protocol PlaceMotionHistoryProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Event : NamiPairingFramework.ActivityEventProtocol
  var placeId: NamiPairingFramework.PlaceID { get }
  var motionEvents: [Self.Event] { get }
  var occupancyEvents: [Self.Event] { get }
}
public protocol MotionIntervalProtocol : Swift.Decodable, Swift.Encodable {
  var start: Foundation.Date { get }
  var value: Swift.UInt8 { get }
}
public protocol MotionAggregateProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Interval : NamiPairingFramework.MotionIntervalProtocol
  associatedtype Resolution : NamiPairingFramework.MotionDataResolutionProtocol
  var metric: Swift.String { get }
  var resolution: Self.Resolution { get }
  var intervalLength: Foundation.TimeInterval { get }
  var intervals: [Self.Interval] { get }
}
public protocol PlaceMotionAggregatesProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Aggregate : NamiPairingFramework.MotionAggregateProtocol
  var placeId: NamiPairingFramework.PlaceID { get }
  var aggregates: [Self.Aggregate] { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var sparklines: [Swift.String : Self.Aggregate]? { get }
  #endif
}
public protocol ZoneMotionAggregatesProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Aggregate : NamiPairingFramework.MotionAggregateProtocol
  var zoneId: NamiPairingFramework.PlaceZoneID { get }
  var aggregates: [Self.Aggregate] { get }
}
public protocol ZoneMotionHistoryProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype ZoneMotionEvent : NamiPairingFramework.ZoneMotionEventProtocol
  var zoneMotionEvents: [Swift.String : Self.ZoneMotionEvent] { get }
}
public protocol MotionDataResolutionProtocol : Swift.Decodable, Swift.Encodable {
}
public protocol RestEventProtocol : Swift.Decodable, Swift.Encodable {
  var deviceUid: NamiPairingFramework.DeviceUniversalID { get }
  var startedAt: Foundation.Date { get }
  var endedAt: Foundation.Date { get }
}
public protocol RestEventsResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype RestEvent : NamiPairingFramework.RestEventProtocol
  var restEvents: [Self.RestEvent] { get }
}
public protocol RestInsightProtocol : Swift.Decodable, Swift.Encodable {
  var deviceUid: NamiPairingFramework.DeviceUniversalID { get }
  var totalRestTime: Swift.Int { get }
  var numberOfInterruptions: Swift.Int { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var timeToBed: Foundation.Date? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var outOfBedAt: Foundation.Date? { get }
  #endif
}
public protocol RestInsightsResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype RestInsight : NamiPairingFramework.RestInsightProtocol
  var restInsights: [Self.RestInsight] { get }
}
public protocol DeviceAttributeStateProtocol : Swift.Decodable, Swift.Encodable {
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var endpoint: Swift.Int { get }
  var path: Swift.String { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var value: Swift.String? { get }
  #endif
  var updatedAt: Foundation.Date { get }
  var isDeleted: Swift.Bool { get }
}
public protocol DeviceAttributeStateResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype DeviceAttributeState : NamiPairingFramework.DeviceAttributeStateProtocol
  var deviceAttributeStates: [Self.DeviceAttributeState] { get }
  var total: Swift.Int { get }
  var pageSize: Swift.Int { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var cursor: Swift.String? { get }
  #endif
}
public protocol PairDeviceResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype WiredPlaceKeys : NamiPairingFramework.WiredPlaceKeysProtocol
  associatedtype Device : NamiPairingFramework.DeviceProtocol
  var payload: Self.WiredPlaceKeys { get }
  var device: Self.Device { get }
}
public protocol PairingChallengeResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype DeviceModel : NamiPairingFramework.DeviceModelProtocol
  var challenge: Swift.String { get }
  var model: Self.DeviceModel { get }
}
public protocol WiFiCredentialsUpdateSessionResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype WiFiCredentialsUpdateSession : NamiPairingFramework.WiFiCredentialsUpdateSessionProtocol
  var sessions: [Self.WiFiCredentialsUpdateSession] { get }
}
public protocol WiFiCredentialsUpdateSessionProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype UpdatedDevice : NamiPairingFramework.UpdatedDeviceProtocol
  associatedtype Status : NamiPairingFramework.WiFiCredentialsUpdateStatusProtocol
  associatedtype WiFiCredentialsHoldingDevice : NamiPairingFramework.WiFiCredentialsHoldingDeviceProtocol
  var id: NamiPairingFramework.WiFiCredentialsUpdateSessionID { get }
  var urn: Swift.String { get }
  var zoneId: NamiPairingFramework.PlaceZoneID { get }
  var status: Self.Status { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var updatedDevices: [Self.UpdatedDevice]? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var wifiUpdateSessionDevices: [Self.WiFiCredentialsHoldingDevice]? { get }
  #endif
}
public protocol WiredPlaceKeysProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var ciphertext: Swift.String { get }
  var iv: Swift.String { get }
  var authTag: Swift.String { get }
  var serverKey: Swift.String { get }
}
public protocol UpdatedDeviceProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype UpdatedBy : NamiPairingFramework.UpdatedDeviceUserProtocol
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var urn: Swift.String { get }
  var updatedBy: Self.UpdatedBy { get }
  var updatedAt: Foundation.Date { get }
}
public protocol WiFiCredentialsHoldingDeviceProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var urn: Swift.String { get }
}
public protocol UpdatedDeviceUserProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  var urn: Swift.String? { get }
  #endif
  var name: Swift.String { get }
  var themeId: NamiPairingFramework.ThemeID { get }
  var iconId: NamiPairingFramework.IconID { get }
}
public protocol WiFiCredentialsUpdateStatusProtocol : Swift.Decodable, Swift.Encodable, Swift.RawRepresentable where Self.RawValue == Swift.String {
}
public protocol CloudPlaceKeyProtocol : Swift.Decodable, Swift.Encodable {
  var id: Swift.String { get }
  var key: Swift.String { get }
}
public protocol MoveDevicesResponseProtocol : Swift.Decodable, Swift.Encodable {
  associatedtype Device : NamiPairingFramework.DeviceProtocol
  var devices: [Self.Device] { get }
}
public protocol DeviceControlMessageProtocol : Swift.Decodable, Swift.Encodable {
  var data: Foundation.Data { get }
}
public protocol ThreadCredentialsMessageProtocol : Swift.Decodable, Swift.Encodable {
  var networkName: Swift.String { get }
  var extendedPanId: Foundation.Data { get }
  var panId: Swift.UInt16 { get }
  var channel: Swift.UInt8 { get }
  var pskc: Foundation.Data { get }
  var masterKey: Foundation.Data { get }
  var meshLocalPrefix: Foundation.Data { get }
  var operationalDataset: Foundation.Data { get }
  var borderAgentID: Foundation.Data { get }
}
public protocol PlaceKeyProtocol : Swift.Decodable, Swift.Encodable {
  var id: Swift.String { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var valid: Foundation.DateInterval { get }
  var key: Foundation.Data { get }
}
public protocol UserPermissionsSetProtocol : Swift.Decodable, Swift.Encodable {
}
public protocol SessionPermissionProtocol : Swift.Decodable, Swift.Encodable {
}
public protocol StorablePlaceProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable, Swift.Identifiable {
  var id: NamiPairingFramework.PlaceID { get }
  var urn: Swift.String { get }
  var name: Swift.String { get }
  var themeId: NamiPairingFramework.ThemeID { get }
  var iconId: NamiPairingFramework.IconID { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var propertyTypeId: NamiPairingFramework.PropertyTypeID? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var propertyElevationId: NamiPairingFramework.PropertyElevationID? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var petTypeId: NamiPairingFramework.PetTypeID? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var timeZone: Swift.String? { get }
  #endif
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var alertMode: Swift.String? { get }
  #endif
}
public protocol StorableZoneProtocol : Swift.Decodable, Swift.Encodable, Swift.Hashable, Swift.Identifiable {
  associatedtype EngineConfig : NamiPairingFramework.StorableEngineConfigProtocol
  var id: NamiPairingFramework.PlaceZoneID { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var externalId: Swift.String? { get }
  #endif
  var urn: Swift.String { get }
  var name: Swift.String { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var alertMode: Swift.String { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
  var engineConfig: Self.EngineConfig { get }
}
public protocol StorableRoomProtocol : Swift.Decodable, Swift.Encodable, Swift.Hashable, Swift.Identifiable {
  var id: NamiPairingFramework.RoomID { get }
  var urn: Swift.String { get }
  var name: Swift.String { get }
  var zoneId: NamiPairingFramework.PlaceZoneID { get }
  var iconId: NamiPairingFramework.IconID { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
}
public protocol StorableDeviceProtocol : Swift.Decodable, Swift.Encodable, Swift.Hashable, Swift.Identifiable {
  var id: NamiPairingFramework.DeviceID { get }
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var urn: Swift.String { get }
  var roomId: NamiPairingFramework.RoomID { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var bleDiscriminator: Swift.Int32? { get }
  #endif
  var name: Swift.String { get }
  var codeName: Swift.String { get }
  var productId: NamiPairingFramework.DeviceProductID { get }
  var createdAt: Foundation.Date { get }
  var updatedAt: Foundation.Date { get }
  var isBorderRouter: Swift.Bool { get }
}
public protocol StorableDeviceStateProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable, Swift.Identifiable {
  var id: NamiPairingFramework.DeviceID { get }
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var urn: Swift.String { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var cloudAccessible: Swift.Bool? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var lastCloudAccess: Foundation.Date? { get }
  #endif
  var seqTime: Swift.UInt64 { get }
  var state: Foundation.Data { get }
  var stateUpdatedAt: Foundation.Date { get }
}
public protocol StorableAutomationProtocol : Swift.Decodable, Swift.Encodable, Swift.Hashable, Swift.Identifiable {
  associatedtype Trigger : NamiPairingFramework.StorableAutomationTriggerProtocol
  associatedtype Reaction : NamiPairingFramework.StorableAutomationReactionProtocol
  var id: NamiPairingFramework.AutomationID { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  var trigger: Self.Trigger { get }
  var reactions: [Self.Reaction] { get }
  var active: Swift.Bool { get }
}
public protocol StorableAutomationTriggerProtocol : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  var type: Swift.String { get }
  var hour: Swift.Int { get }
  var minute: Swift.Int { get }
  var daysOfWeek: [Swift.String] { get }
}
public protocol StorableAutomationReactionProtocol : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  associatedtype Action : NamiPairingFramework.StorableAutomationActionProtocol
  var uuid: Swift.String { get }
  var targetType: Swift.String { get }
  var targetIds: [NamiPairingFramework.PlaceZoneID] { get }
  var action: Self.Action { get }
}
public protocol StorableAutomationActionProtocol : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  var type: Swift.String { get }
  var mode: NamiPairingFramework.NamiAlertMode { get }
}
public protocol StorablePlaceUserProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable, Swift.Identifiable {
  associatedtype Role : NamiPairingFramework.StorablePlaceUserRoleProtocol
  var id: NamiPairingFramework.UserID { get }
  var userId: NamiPairingFramework.UserID { get }
  var name: Swift.String { get }
  var urn: Swift.String { get }
  var role: Self.Role { get }
  var iconId: NamiPairingFramework.UserIconID { get }
  var themeId: NamiPairingFramework.ThemeID { get }
  var placeId: NamiPairingFramework.PlaceID { get }
}
public protocol StorablePlaceUserRoleProtocol : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  var id: Swift.String { get }
  var name: Swift.String { get }
}
public protocol StorableInviteLinkProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable, Swift.Identifiable {
  associatedtype Role : NamiPairingFramework.StorablePlaceUserRoleProtocol
  var id: Swift.String { get }
  var code: NamiPairingFramework.InviteCode { get }
  var name: Swift.String { get }
  var role: Self.Role { get }
  var placeId: NamiPairingFramework.PlaceID { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var placeName: Swift.String? { get }
  #endif
  var state: Swift.String { get }
  var inviteUrl: Foundation.URL { get }
  var expiresAt: Foundation.Date { get }
}
public protocol StorablePlaceUsageLimitsProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable, Swift.Identifiable {
  var urn: Swift.String { get }
  var membership: Swift.UInt { get }
  var id: NamiPairingFramework.URN { get }
}
public protocol StorableUpdatedDeviceProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable, Swift.Identifiable {
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID { get }
}
public protocol StorableUpdatedDeviceUserProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  var urn: Swift.String? { get }
  #endif
  var name: Swift.String { get }
  var themeId: NamiPairingFramework.ThemeID { get }
  var iconId: NamiPairingFramework.IconID { get }
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID { get }
}
public protocol StorablePlaceIntegrationsProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable, Swift.Identifiable {
  var placeId: NamiPairingFramework.PlaceID { get }
  var id: NamiPairingFramework.PlaceID { get }
}
public protocol StorableDeviceModelProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var codeName: Swift.String { get }
  var productLabel: Swift.String { get }
  var productId: NamiPairingFramework.DeviceProductID { get }
  var deviceType: Swift.String { get }
}
public protocol StorableMotionStatusProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  var detection: Swift.Bool? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var startedAt: Foundation.Date? { get }
  #endif
  var health: Swift.String { get }
}
public protocol StorableActivityEventProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  var uuid: Foundation.UUID? { get }
  #endif
  var startedAt: Foundation.Date { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var endedAt: Foundation.Date? { get }
  #endif
  var detection: Swift.Bool { get }
  var health: Swift.String { get }
}
public protocol StorableZoneMotionEventProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype Event : NamiPairingFramework.StorableActivityEventProtocol
  var zoneId: NamiPairingFramework.PlaceZoneID { get }
  var motionEvents: [Self.Event] { get }
  var occupancyEvents: [Self.Event] { get }
}
public protocol StorablePlaceMotionHistoryProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype Event : NamiPairingFramework.StorableActivityEventProtocol
  var placeId: NamiPairingFramework.PlaceID { get }
  var motionEvents: [Self.Event] { get }
  var occupancyEvents: [Self.Event] { get }
}
public protocol StorableMotionIntervalProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var start: Foundation.Date { get }
  var value: Swift.UInt8 { get }
}
public protocol StorableMotionAggregateProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype Interval : NamiPairingFramework.StorableMotionIntervalProtocol
  var metric: Swift.String { get }
  var resolution: Swift.String { get }
  var intervalLength: Foundation.TimeInterval { get }
  var intervals: [Self.Interval] { get }
}
public protocol StorablePlaceMotionAggregatesProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype Aggregate : NamiPairingFramework.StorableMotionAggregateProtocol
  var placeId: NamiPairingFramework.PlaceID { get }
  var aggregates: [Self.Aggregate] { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var sparklines: [Swift.String : Self.Aggregate]? { get }
  #endif
}
public protocol StorableZoneMotionAggregatesProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype Aggregate : NamiPairingFramework.StorableMotionAggregateProtocol
  var zoneId: NamiPairingFramework.PlaceZoneID { get }
  var aggregates: [Self.Aggregate] { get }
}
public protocol StorableRestEventProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var deviceUid: NamiPairingFramework.DeviceUniversalID { get }
  var startedAt: Foundation.Date { get }
  var endedAt: Foundation.Date { get }
}
public protocol StorableRestEventsResponseProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype RestEvent : NamiPairingFramework.StorableRestEventProtocol
  var restEvents: [Self.RestEvent] { get }
}
public protocol StorableRestInsightProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var deviceUid: NamiPairingFramework.DeviceUniversalID { get }
  var totalRestTime: Swift.Int { get }
  var numberOfInterruptions: Swift.Int { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var timeToBed: Foundation.Date? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var outOfBedAt: Foundation.Date? { get }
  #endif
}
public protocol StorableRestInsightsResponseProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype RestInsight : NamiPairingFramework.StorableRestInsightProtocol
  var restInsights: [Self.RestInsight] { get }
}
public protocol StorableDeviceAttributeStateProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var uid: NamiPairingFramework.DeviceUniversalID { get }
  var endpoint: Swift.Int { get }
  var path: Swift.String { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var value: Swift.String? { get }
  #endif
  var updatedAt: Foundation.Date { get }
  var isDeleted: Swift.Bool { get }
}
public protocol StorableDeviceAttributeStateResponseProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype DeviceAttributeState : NamiPairingFramework.StorableDeviceAttributeStateProtocol
  var deviceAttributeStates: [Self.DeviceAttributeState] { get }
  var total: Swift.Int { get }
  var pageSize: Swift.Int { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var cursor: Swift.String? { get }
  #endif
}
public protocol StorableEngineConfigProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var id: NamiPairingFramework.PlaceZoneID { get }
  var engineType: Swift.String { get }
  var sensitivityLevel: Swift.Int { get }
}
public protocol StorableZoneMotionStatusProtocol : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var id: NamiPairingFramework.PlaceZoneID { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var detection: Swift.Bool? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var startedAt: Foundation.Date? { get }
  #endif
  var health: Swift.String { get }
}
public protocol StorableDeviceStateAnalyzerProtocol {
  func isBorderRouter(from stateData: Foundation.Data) -> Swift.Bool
}
public protocol SecureStorageProtocol {
  associatedtype SecureStorageError : Swift.Error
  static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, Self.SecureStorageError>
  #endif
  static func delete(at key: Swift.String, server: Swift.String)
}
public typealias NamiI18n = NamiPairingFramework.I18n
public enum I18n {
  public static let accountLinkingAuthorizeSignInRequest: Swift.String
  public static let accountLinkingDidYouMakeThisRequest: Swift.String
  public static let accountLinkingPleaseSignin: Swift.String
  public static let accountLinkingSignInConfirmedBodyMessage: Swift.String
  public static let accountLinkingSignInError: Swift.String
  public static func accountLinkingSignInRequestIpTimeBrowser(_ p1: Swift.UnsafePointer<Swift.CChar>, _ p2: Swift.UnsafePointer<Swift.CChar>, _ p3: Swift.UnsafePointer<Swift.CChar>) -> Swift.String
  public static func accountLinkingSignInRequestPlaceIpTimeBrowserAndroid(_ p1: Swift.UnsafePointer<Swift.CChar>, _ p2: Swift.UnsafePointer<Swift.CChar>, _ p3: Swift.UnsafePointer<Swift.CChar>, _ p4: Swift.UnsafePointer<Swift.CChar>) -> Swift.String
  public static let activityEventOngoing: Swift.String
  public static let activityMotion: Swift.String
  public static let activityMotionDetectedIn: Swift.String
  public static let activityNoMotion: Swift.String
  public static let activityNoPresence: Swift.String
  public static let activityPresence: Swift.String
  public static let activityPresenceDetectedIn: Swift.String
  public static let activityTitle: Swift.String
  public static let activityTotalMotionTime: Swift.String
  public static func alarmDetectedAtAndroid(_ p1: Any, _ p2: Any) -> Swift.String
  public static let alarmDisarm: Swift.String
  public static func alarmFalseAlarmCauseListTitle(_ p1: Any) -> Swift.String
  public static let alarmFalseAlarmCauseMyself: Swift.String
  public static let alarmFalseAlarmCauseOther: Swift.String
  public static let alarmFalseAlarmCauseSmallMovingObjects: Swift.String
  public static let alarmFalseAlarmReportButtonTitle: Swift.String
  public static func alarmFalseAlarmReportHint(_ p1: Any) -> Swift.String
  public static let alarmFalseAlarmSelectCauseTitle: Swift.String
  public static let alarmFalseAlarmSensitivityExplanatioAdjustSensitivityButton: Swift.String
  public static let alarmFalseAlarmSensitivityExplanatioArmSelectedZones: Swift.String
  public static let alarmFalseAlarmSensitivityExplanatioPossibleReasons: Swift.String
  public static let alarmFalseAlarmSensitivityExplanatioSensitivityLevelHint: Swift.String
  public static let alarmFalseAlarmSensitivityExplanationReduceFalseAlarmsTitle: Swift.String
  public static let alarmFalseAlarmTitle: Swift.String
  public static func alarmIntrusionDescription(_ p1: Any, _ p2: Any) -> Swift.String
  public static func alarmIntrusionDescriptionAndroid(_ p1: Any, _ p2: Any) -> Swift.String
  public static let alarmIntrusionTitle: Swift.String
  public static func alarmLiveAlarmActivitiesStopped(_ p1: Any) -> Swift.String
  public static func alarmLiveAlarmNoActivity(_ p1: Any) -> Swift.String
  public static func alarmLiveAlarmOngoingActivity(_ p1: Any) -> Swift.String
  public static let alarmLiveAlarmSecurityMonitoring: Swift.String
  public static func alarmLiveAlarmStartedAtInZone(_ p1: Any, _ p2: Any) -> Swift.String
  public static func alarmLiveAlarmStoppedActivity(_ p1: Any) -> Swift.String
  public static let alarmReasonIntrusion: Swift.String
  public static let alarmReportAlarmDisarmed: Swift.String
  public static let alarmReportAlarmTriggered: Swift.String
  public static func alarmReportDeviceClosed(_ p1: Any) -> Swift.String
  public static func alarmReportDeviceOpened(_ p1: Any) -> Swift.String
  public static let alarmReportDuration: Swift.String
  public static func alarmReportEventStartEndTime(_ p1: Any, _ p2: Any) -> Swift.String
  public static let alarmReportFalse: Swift.String
  public static func alarmReportMotionStartedIn(_ p1: Any) -> Swift.String
  public static let alarmReportSecurityLog: Swift.String
  public static func alarmReportStartedAt(_ p1: Any) -> Swift.String
  public static func alarmReportSubjectHistory(_ p1: Any) -> Swift.String
  public static let alarmReportTitle: Swift.String
  public static func alarmReportTotalActiveTime(_ p1: Any) -> Swift.String
  public static let alarmReportZonesAffected: Swift.String
  public static let appName: Swift.String
  public static let appWidgetDescriptionMedium: Swift.String
  public static let appWidgetDescriptionSmall: Swift.String
  public static let appWidgetErrorNoInternetConnection: Swift.String
  public static let appWidgetLabelMedium: Swift.String
  public static let appWidgetLabelSmall: Swift.String
  public static let appwidgetDefaultPlaceName: Swift.String
  public static let appwidgetErrorText: Swift.String
  public static let areYouWantToCancelPairingProcess: Swift.String
  public static let automationAt: Swift.String
  public static let automationBack: Swift.String
  public static let automationChangeModeTo: Swift.String
  public static let automationConflictAutomationDescription: Swift.String
  public static let automationConflictAutomationTitle: Swift.String
  public static let automationCreateAutomation: Swift.String
  public static let automationDeleteAutomation: Swift.String
  public static let automationDeleteAutomationDescription: Swift.String
  public static let automationEditAutomation: Swift.String
  public static let automationEveryDay: Swift.String
  public static let automationEveryWeekday: Swift.String
  public static let automationEveryWeekend: Swift.String
  public static let automationFor: Swift.String
  public static func automationFormatTimeZone(_ p1: Any) -> Swift.String
  public static func automationIsYourPlaceLocatedInThisTimeZone(_ p1: Any) -> Swift.String
  public static let automationModes: Swift.String
  public static let automationMsgEmptyAutomation: Swift.String
  public static let automationNewAutomation: Swift.String
  public static let automationNoAutomationAvailableYet: Swift.String
  public static let automationNoPermissionToMakeChangeDialogDescription: Swift.String
  public static let automationNoPermissionToMakeChangeDialogGotIt: Swift.String
  public static let automationNoPermissionToMakeChangeDialogTitle: Swift.String
  public static let automationNoZonesAvailable: Swift.String
  public static let automationNoZonesSelected: Swift.String
  public static let automationRepeatOn: Swift.String
  public static let automationSelectTime: Swift.String
  public static let automationSelectTimezone: Swift.String
  public static let automationSelectZone: Swift.String
  public static let automationTooltipStayModeOnlyAvailable: Swift.String
  public static func automationTooltipStayModeUnselectedZones(_ p1: Any) -> Swift.String
  public static let automationsActionCannotUndone: Swift.String
  public static let automationsAt: Swift.String
  public static let automationsAutomationCannotBeSaved: Swift.String
  public static let automationsCreateAutomation: Swift.String
  public static let automationsDateAndTimeBasedOn: Swift.String
  public static let automationsDeleteAutomation: Swift.String
  public static let automationsEditAutomation: Swift.String
  public static let automationsEveryWeekday: Swift.String
  public static let automationsEveryWeekend: Swift.String
  public static let automationsEveryday: Swift.String
  public static let automationsFor: Swift.String
  public static let automationsModes: Swift.String
  public static let automationsNewAutomation: Swift.String
  public static let automationsNoZonesAvailable: Swift.String
  public static let automationsNoZonesSelected: Swift.String
  public static let automationsRepeatOn: Swift.String
  public static let automationsSetAScheduleToActivateModesAutomatically: Swift.String
  public static let automationsYouHaveConflict: Swift.String
  public static let changeUsernameEmptyErrorMessage: Swift.String
  public static let changeUsernamePlaceholder: Swift.String
  public static let changeUsernamePromptMessage: Swift.String
  public static let chooseRoomConfirm: Swift.String
  public static let chooseRoomCreateRoom: Swift.String
  public static let chooseRoomHeader: Swift.String
  public static let chooseRoomLoadDataFailed: Swift.String
  public static let chooseRoomSelectOrCreateHeader: Swift.String
  public static let chooseZoneCreateZone: Swift.String
  public static let chooseZoneHeader: Swift.String
  public static let chooseZoneNoDevices: Swift.String
  public static func chooseZoneThreadDevicesCount(_ p1: Any) -> Swift.String
  public static func chooseZoneWifiDevicesCount(_ p1: Any) -> Swift.String
  public static let commissioningModeCheckupZoneContactIsntaller: Swift.String
  public static let commissioningModeCompanionLandingCancel: Swift.String
  public static let commissioningModeCompanionLandingContactSupport: Swift.String
  public static let commissioningModeCompanionLandingGoToPlaceButton: Swift.String
  public static let commissioningModeCompanionLandingLoadingInfo: Swift.String
  public static let commissioningModeCompanionLandingPlaceFound: Swift.String
  public static let commissioningModeConfirmPlaceConfirmButton: Swift.String
  public static let commissioningModeConfirmPlaceNamePlaceHint: Swift.String
  public static let commissioningModeConfirmPlaceNamePlacePlaceholder: Swift.String
  public static let commissioningModeLoadingScreenLoadingContent: Swift.String
  public static let commissioningModePlaceDetailsAddDevicesHint: Swift.String
  public static let commissioningModePlaceDetailsAddZone: Swift.String
  public static let commissioningModePlaceDetailsContactIsntaller: Swift.String
  public static let commissioningModePlaceDetailsCreatedAt: Swift.String
  public static let commissioningModePlaceDetailsCreatedAtAndroid: Swift.String
  public static let commissioningModePlaceDetailsExitButton: Swift.String
  public static let commissioningModePlaceDetailsUpdatedAt: Swift.String
  public static let commissioningModePlaceDetailsUpdatedAtAndroid: Swift.String
  public static let commissioningModePlaceDetailsZonesSectionTitle: Swift.String
  public static let commissioningModeSetupModeSettingsExitSetup: Swift.String
  public static let commissioningModeSetupModeSettingsPlaceSettings: Swift.String
  public static let commissioningModeSetupModeSettingsSettings: Swift.String
  public static let companionEditPlaceNameHint: Swift.String
  public static let companionExitSetup: Swift.String
  public static let companionExitSetupAndroid: Swift.String
  public static let companionHomeContactYourInstallerToSetUpYourPlace: Swift.String
  public static let companionZoneMotionSensingConnectLocalWifi: Swift.String
  public static let companionZoneMotionSensingMovementDetected: Swift.String
  public static let companionZoneMotionSensingNoMovementDetected: Swift.String
  public static let companionZones: Swift.String
  public static let confirmCancelPairing: Swift.String
  public static let confirmPlaceNameButtonConfirm: Swift.String
  public static let confirmPlaceNameHeader: Swift.String
  public static let confirmPlaceNameSubhead: Swift.String
  public static let confirmRoomNameButtonConfirm: Swift.String
  public static let confirmRoomNameHeader: Swift.String
  public static let confirmRoomNameSubhead: Swift.String
  public static let connectivityIndicatorDeviceConnected: Swift.String
  public static let connectivityIndicatorDeviceDisconnected: Swift.String
  public static func connectivityIndicatorDeviceRssi(_ p1: Swift.Int) -> Swift.String
  public static let contactSensorSetupBeforeYouContinue: Swift.String
  public static let contactSensorSetupGuideDescription1: Swift.String
  public static let contactSensorSetupGuideDescription2: Swift.String
  public static let createFirstPlaceCancel: Swift.String
  public static let createFirstPlaceCreatePlace: Swift.String
  public static let createFirstPlaceCreatePlaceSlideText: Swift.String
  public static let createFirstPlaceJoinPlace: Swift.String
  public static let createFirstPlaceJoinPlaceSlideText: Swift.String
  public static let createFirstPlaceLetsStart: Swift.String
  public static let createFirstPlaceWelcomeText: Swift.String
  public static let createPlaceSectionTitle: Swift.String
  public static let createZoneButtonConfirm: Swift.String
  public static let createZoneDescription: Swift.String
  public static let createZoneEnterNameHint: Swift.String
  public static let createZoneFirstFloor: Swift.String
  public static let createZoneHeader: Swift.String
  public static let createZoneNameTheZoneDescription: Swift.String
  public static let createZonePlaceholder: Swift.String
  public static let createZoneSecondFloorPlaceholder: Swift.String
  public static let createZoneTitle: Swift.String
  public static let dashboardAddNewPlace: Swift.String
  public static func dashboardFormatDisconnectedDeviceInMultipleZoneAndroid(_ p1: Swift.Int) -> Swift.String
  public static func dashboardFormatDisconnectedDeviceInOneZoneAndroid(_ p1: Swift.Int) -> Swift.String
  public static func dashboardFormatIssueInAPlace(_ p1: Any) -> Swift.String
  public static func dashboardFormatIssueInMultiplePlace(_ p1: Swift.Int) -> Swift.String
  public static let dashboardPlaceTileCurrentStatus: Swift.String
  public static let dashboardPlaceTileIntrusionDetected: Swift.String
  public static let dashboardPlaceTileMovementDetected: Swift.String
  public static let dashboardPlaceTileNoMovementDetected: Swift.String
  public static let dashboardPlaceTileNoSensingData: Swift.String
  public static let dashboardPlaceTileNotAvailable: Swift.String
  public static let dashboardPlaceTilePairMore: Swift.String
  public static let dashboardPlaceTilePairOneMore: Swift.String
  public static func dashboardPlaceTileSinceStartedDate(_ p1: Any) -> Swift.String
  public static func dashboardPlaceTileSinceStartedDateAndroid(_ p1: Any) -> Swift.String
  public static let dashboardPlaces: Swift.String
  public static let dashboardSensingLinkBrokenInMultipleZone: Swift.String
  public static let dashboardSensingLinkBrokenInOneZone: Swift.String
  public static let defaultNotificationChannelId: Swift.String
  public static let defaultNotificationChannelName: Swift.String
  public static let deletePlaceConfirmDeletePlace: Swift.String
  public static let deletePlaceConfirmLeavePlace: Swift.String
  public static let deletePlaceDeleteAllRelatedData: Swift.String
  public static let deletePlaceDeleteAllRelatedDataDescription: Swift.String
  public static let deletePlaceDeletePlaceAndData: Swift.String
  public static let deletePlaceDeletePlaceTitle: Swift.String
  public static let deletePlaceInviteAgain: Swift.String
  public static let deletePlaceLeavePlaceTitle: Swift.String
  public static let deletePlaceLoseAccessToAllData: Swift.String
  public static let deletePlaceLoseAccessToAllDataDescription: Swift.String
  public static let deletePlaceLoseAccessToAllDevices: Swift.String
  public static let deletePlaceLoseAccessToAllDevicesDescription: Swift.String
  public static let deletePlaceRemoveAllUsers: Swift.String
  public static let deletePlaceRemoveAllUsersDescription: Swift.String
  public static let deletePlaceResetAllDevices: Swift.String
  public static let deletePlaceResetAllDevicesDescription: Swift.String
  public static let deletePlaceThisActionIsIrreversible: Swift.String
  public static let deletePlaceThisWillAlso: Swift.String
  public static let deviceCategoryAccessories: Swift.String
  public static let deviceCategoryActivitySensors: Swift.String
  public static let deviceCategorySensing: Swift.String
  public static let deviceDetailDoorSensorLowBattery: Swift.String
  public static let deviceDetailDoorSensorLowBatteryWarning: Swift.String
  public static let deviceDetailDoorSensorLowBatteryWarningLearnHow: Swift.String
  public static let deviceDetailsConnected: Swift.String
  public static func deviceDetailsLoadDataFailed(_ p1: Any) -> Swift.String
  public static let deviceEditDeviceNamePlaceholder: Swift.String
  public static let deviceEditTitle: Swift.String
  public static let deviceEnginesAerialMotionV1: Swift.String
  public static let deviceEnginesMotion: Swift.String
  public static let deviceEnginesSecurity: Swift.String
  public static let deviceEnginesUnknown: Swift.String
  public static let deviceInfoBbsid: Swift.String
  public static let deviceInfoBorderRouter: Swift.String
  public static let deviceInfoCloudConnection: Swift.String
  public static let deviceInfoDeviceConnected: Swift.String
  public static let deviceInfoDeviceDisconnected: Swift.String
  public static let deviceInfoDeviceModel: Swift.String
  public static let deviceInfoDeviceModelId: Swift.String
  public static let deviceInfoFirmvareVesrion: Swift.String
  public static let deviceInfoLocalConnection: Swift.String
  public static let deviceInfoMacAddress: Swift.String
  public static let deviceInfoNonBorderRouter: Swift.String
  public static let deviceInfoPairedAt: Swift.String
  public static let deviceInfoPanid: Swift.String
  public static let deviceInfoRole: Swift.String
  public static let deviceInfoRssi: Swift.String
  public static let deviceInfoTechnicalInformation: Swift.String
  public static let deviceInfoThreadNetwork: Swift.String
  public static let deviceInfoTitle: Swift.String
  public static let deviceInfoWidarPosition: Swift.String
  public static let deviceInfoWidarPositionMispositioned: Swift.String
  public static let deviceInfoWidarPositionNotAvailable: Swift.String
  public static let deviceInfoWidarPositionOptimal: Swift.String
  public static let deviceInfoWidarPositionStatus: Swift.String
  public static let deviceInfoWidarPositioningInformation: Swift.String
  public static let deviceInfoWidarSensing: Swift.String
  public static let deviceInfoWifiNetwork: Swift.String
  public static let deviceInfoZone: Swift.String
  public static let deviceInstructionsBulletPoint1: Swift.String
  public static let deviceInstructionsBulletPoint2: Swift.String
  public static let deviceInstructionsBulletPoint3: Swift.String
  public static let deviceInstructionsBulletPoint4: Swift.String
  public static let deviceInstructionsConfirmButton: Swift.String
  public static let deviceInstructionsDescription: Swift.String
  public static let deviceInstructionsTitle: Swift.String
  public static let deviceIsDisconnectedToInternet: Swift.String
  public static let deviceOverviewConnection: Swift.String
  public static let deviceOverviewConnectionCloud: Swift.String
  public static let deviceOverviewConnectionDirect: Swift.String
  public static let deviceOverviewConnectionLost: Swift.String
  public static let deviceOverviewDeletionDeleteConfirm: Swift.String
  public static let deviceOverviewRelayExplanation: Swift.String
  public static let deviceOverviewRelayIsOff: Swift.String
  public static let deviceOverviewRelayIsOn: Swift.String
  public static let deviceOverviewStatus: Swift.String
  public static let deviceOverviewWifiDisconnected: Swift.String
  public static let deviceOverviewWifiPoor: Swift.String
  public static let devicePlacementAvoidPlacingDeviceNearMetalic: Swift.String
  public static let devicePlacementConfirmButton: Swift.String
  public static let devicePlacementDoNotConnectToPowerYet: Swift.String
  public static let devicePlacementDoNotInstallOrConnectToPowerYet: Swift.String
  public static let devicePlacementDoNotMountDoorSensorYet: Swift.String
  public static let devicePlacementDoNotMountKeypadYet: Swift.String
  public static let devicePlacementDoNotMountMotionSensorYet: Swift.String
  public static let devicePlacementDoorSensorGuideContent1: Swift.String
  public static func devicePlacementDoorSensorGuideContent2Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementDoorSensorGuideContent2Metric(_ p1: Any) -> Swift.String
  public static let devicePlacementFirstBssGuide1Imperial: Swift.String
  public static let devicePlacementFirstBssGuide1Metric: Swift.String
  public static let devicePlacementFirstBssSecondDeviceGuide2Imperial: Swift.String
  public static let devicePlacementFirstBssSecondDeviceGuide2Metric: Swift.String
  public static let devicePlacementFirstBssThirdDeviceGuide3Imperial: Swift.String
  public static let devicePlacementFirstBssThirdDeviceGuide3Metric: Swift.String
  public static let devicePlacementFirstDeviceSetup: Swift.String
  public static let devicePlacementFirstDeviceSetupStep1: Swift.String
  public static let devicePlacementFirstDeviceSetupStep2Imperial: Swift.String
  public static let devicePlacementFirstDeviceSetupStep2Metric: Swift.String
  public static let devicePlacementFirstHmsSecondDeviceGuide2Imperial: Swift.String
  public static let devicePlacementFirstHmsSecondDeviceGuide2Metric: Swift.String
  public static let devicePlacementFirstHmsThirdDeviceGuide3Imperial: Swift.String
  public static let devicePlacementFirstHmsThirdDeviceGuide3Metric: Swift.String
  public static let devicePlacementFirstSensePlugGuide1Imperial: Swift.String
  public static let devicePlacementFirstSensePlugGuide1Metric: Swift.String
  public static let devicePlacementFirstSensePlugGuide2: Swift.String
  public static let devicePlacementFirstWifiSensorGuide1Imperial: Swift.String
  public static let devicePlacementFirstWifiSensorGuide1Metric: Swift.String
  public static let devicePlacementFirstWifiSensorGuide2: Swift.String
  public static func devicePlacementFirstWifiSensorGuide3(_ p1: Any) -> Swift.String
  public static let devicePlacementKeypadGuideContent1: Swift.String
  public static let devicePlacementMotionSensorGuideContent1: Swift.String
  public static let devicePlacementNonFirstBssHasBrGuide2Imperial: Swift.String
  public static let devicePlacementNonFirstBssHasBrGuide2Metric: Swift.String
  public static let devicePlacementNonFirstBssNoBrGuide1Imperial: Swift.String
  public static let devicePlacementNonFirstBssNoBrGuide1Metric: Swift.String
  public static func devicePlacementNonFirstHssThirdDeviceNoDeviceGuide3Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstHssThirdDeviceNoDeviceGuide3Metric(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstSensePlugGuide2Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstSensePlugGuide2Metric(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstWidarHasBrGuide1Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstWidarHasBrGuide1Metric(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstWidarSensorGuide2Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstWidarSensorGuide2Metric(_ p1: Any) -> Swift.String
  public static let devicePlacementNonFirstWifiSensorGuide1Imperial: Swift.String
  public static let devicePlacementNonFirstWifiSensorGuide1Metric: Swift.String
  public static func devicePlacementNonFirstWifiSensorGuide2Imperial(_ p1: Any) -> Swift.String
  public static func devicePlacementNonFirstWifiSensorGuide2Metric(_ p1: Any) -> Swift.String
  public static let devicePlacementNoticeNotice: Swift.String
  public static func devicePlacementNoticeNoticeKnownZone(_ p1: Any) -> Swift.String
  public static let devicePlacementPlaceDeviceOnSameFloor: Swift.String
  public static let devicePlacementRemainingDevicesSetup: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep1Imprerial: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep1Metric: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep2Imperial: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep2Metric: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep3: Swift.String
  public static let devicePlacementRemainingDevicesSetupStep4: Swift.String
  public static let devicePlacementSecureAnyEntryOrRoomDoor: Swift.String
  public static let devicePlacementSensorDialogDescription: Swift.String
  public static let devicePlacementSensorDialogTitle: Swift.String
  public static let devicePlacementThreadBorderRouterDialogDescription: Swift.String
  public static let devicePlacementThreadBorderRouterDialogTitle: Swift.String
  public static let devicePlacementWhereToPlaceDevice: Swift.String
  public static let deviceSettingsCustomizeDeviceDescription: Swift.String
  public static let deviceSettingsCustomizeDeviceTitle: Swift.String
  public static let deviceSettingsDeviceInfoTitle: Swift.String
  public static let deviceSettingsErrorDeviceNotFound: Swift.String
  public static let deviceSettingsRemoveDevice: Swift.String
  public static func deviceSettingsRemoveDeviceName(_ p1: Any) -> Swift.String
  public static let deviceSettingsTechnicalInformationSubtitleThread: Swift.String
  public static let deviceSettingsTechnicalInformationSubtitleThreadEnd: Swift.String
  public static let deviceSettingsTechnicalInformationSubtitleWifi: Swift.String
  public static let deviceSettingsTitle: Swift.String
  public static let deviceSetupAccessories: Swift.String
  public static let deviceSetupActivitySensors: Swift.String
  public static let deviceSetupAlarmPod: Swift.String
  public static let deviceSetupContactSensor: Swift.String
  public static let deviceSetupKeypad: Swift.String
  public static let deviceSetupMotionSensor: Swift.String
  public static let deviceSetupOthers: Swift.String
  public static let deviceSetupSecurityPod: Swift.String
  public static let deviceSetupSensePlug: Swift.String
  public static let deviceSetupSensePod: Swift.String
  public static let deviceSetupWidarSensor: Swift.String
  public static let deviceSetupWifiSensor: Swift.String
  public static let deviceTypeSelectionAccessoriesWarning: Swift.String
  public static let deviceTypeSelectionAccessoriesWarningLearnMore: Swift.String
  public static let deviceWidarMispositionedWarningMessage: Swift.String
  public static let devicesAddNewDevice: Swift.String
  public static let devicesAddNewRoom: Swift.String
  public static let devicesAddNewZone: Swift.String
  public static let doorSensorBatteryLevel: Swift.String
  public static func doorSensorBatteryPercentageAndroid(_ p1: Swift.Int) -> Swift.String
  public static let doorSensorClosed: Swift.String
  public static let doorSensorOpen: Swift.String
  public static let editDeviceEditDeviceNameHint: Swift.String
  public static let editDeviceEditDeviceTitle: Swift.String
  public static let editIconHeader: Swift.String
  public static let editPlaceCategory: Swift.String
  public static let editPlaceDeletePlaceGuideDescription2Android: Swift.String
  public static let editPlaceDeletePlaceGuideDescription4Android: Swift.String
  public static let editPlaceDeletePlaceGuideDescription6Android: Swift.String
  public static let editPlaceDeletePlaceGuideDescriptionAndroid: Swift.String
  public static let editPlaceDeletionDeleteButton: Swift.String
  public static let editPlaceEditPlace: Swift.String
  public static let editPlaceEditPlaceDescription: Swift.String
  public static let editPlaceEnterName: Swift.String
  public static let editPlaceIcon: Swift.String
  public static let editPlaceLeavePlaceGuideDescription4Android: Swift.String
  public static let editPlaceLeavePlaceGuideTitle: Swift.String
  public static let editPlaceSensitivity: Swift.String
  public static let editPlaceZeroDeviceAndroid: Swift.String
  public static func editProfileLoadFailed(_ p1: Any) -> Swift.String
  public static func editProfileSaveFailed(_ p1: Any) -> Swift.String
  public static let editRoomCategory: Swift.String
  public static let editRoomDeleteButton: Swift.String
  public static func editRoomDeleteFailed(_ p1: Any) -> Swift.String
  public static func editRoomDeleteZoneFailed(_ p1: Any) -> Swift.String
  public static let editRoomDeletionDeleteRoomAlertMessage: Swift.String
  public static let editRoomDeletionDeleteZoneAlertMessage: Swift.String
  public static let editRoomEditRoom: Swift.String
  public static let editRoomEnterName: Swift.String
  public static let editRoomIcon: Swift.String
  public static func editRoomLoadFailed(_ p1: Any) -> Swift.String
  public static func editRoomSaveFailed(_ p1: Any) -> Swift.String
  public static let editUserProfileChooseImageColor: Swift.String
  public static let editUserProfileChooseProfileImage: Swift.String
  public static let editUserProfileEmptyErrorMessage: Swift.String
  public static let editUserProfilePlaceholder: Swift.String
  public static let editUserProfileProfileName: Swift.String
  public static let editUserProfileTitle: Swift.String
  public static let editZoneDeleteAlertDescription: Swift.String
  public static let editZoneDeleteAlertTitle: Swift.String
  public static let editZoneDeleteButton: Swift.String
  public static let editZoneEditZone: Swift.String
  public static let editZoneEnterName: Swift.String
  public static let editZoneFailToCreateZone: Swift.String
  public static let editZoneFailToDeleteZone: Swift.String
  public static let editZoneFailToEditZone: Swift.String
  public static let editZoneFailToGetZoneInformation: Swift.String
  public static let editZoneTitle: Swift.String
  public static let editZoneZoneNameAlreadyInUse: Swift.String
  public static let engineSettingsEngineSettingsDescription: Swift.String
  public static let engineSettingsMotionEngine: Swift.String
  public static let engineSettingsMotionEngineDescription: Swift.String
  public static let engineSettingsSecurityEngine: Swift.String
  public static let engineSettingsSecurityEngineDescription: Swift.String
  public static let engineSettingsTitle: Swift.String
  public static let errorInsufficientPermissionActionCanNotBeCompleted: Swift.String
  public static let errorNoInternetConnection: Swift.String
  public static let errorsAuthenticationLoginRequired: Swift.String
  public static let errorsAuthenticationTitle: Swift.String
  public static let errorsAuthenticationTokenExpired: Swift.String
  public static let errorsJoinThreadNetworkFailMessage: Swift.String
  public static let errorsJoinThreadNetworkFailTitle: Swift.String
  public static let errorsLinkingErrorResponseParseError: Swift.String
  public static let errorsMoveDeviceErrorNoDeviceSelected: Swift.String
  public static let errorsMoveDeviceErrorTitle: Swift.String
  public static func errorsNetworkErrorConflict(_ p1: Any) -> Swift.String
  public static func errorsNetworkErrorConnectionError(_ p1: Any) -> Swift.String
  public static let errorsNetworkErrorForbidden: Swift.String
  public static func errorsNetworkErrorInvalidParameters(_ p1: Any) -> Swift.String
  public static func errorsNetworkErrorNotFound(_ p1: Any) -> Swift.String
  public static func errorsNetworkErrorServerError(_ p1: Any) -> Swift.String
  public static let errorsNetworkErrorTitle: Swift.String
  public static func errorsNetworkErrorUnauthorized(_ p1: Any) -> Swift.String
  public static func errorsNetworkErrorUnknown(_ p1: Any) -> Swift.String
  public static func errorsPairingBleDisconnectedDescription(_ p1: Any) -> Swift.String
  public static let errorsPairingConnectionTimeOutDescription: Swift.String
  public static let errorsPairingDeviceNotFoundDescription: Swift.String
  public static let errorsPairingDeviceNotFoundTitle: Swift.String
  public static let errorsPairingErrorDeviceCloudChallengeError: Swift.String
  public static let errorsPairingErrorDeviceSecureSessionError: Swift.String
  public static let errorsPairingErrorDeviceThreadJoinError: Swift.String
  public static let errorsPairingErrorDeviceThreadScanError: Swift.String
  public static let errorsPairingErrorDeviceTitle: Swift.String
  public static let errorsPairingErrorDeviceUnknownUnrecognized: Swift.String
  public static let errorsPairingErrorDeviceWifiJoinError: Swift.String
  public static let errorsPairingErrorDeviceWifiJoinIpError: Swift.String
  public static let errorsPairingErrorDeviceWifiJoinPasswordError: Swift.String
  public static let errorsPairingErrorDeviceWifiScanError: Swift.String
  public static let errorsPairingIncorrectWifiPasswordDescription: Swift.String
  public static let errorsPairingIncorrectWifiPasswordTitle: Swift.String
  public static let errorsPairingMachineDeserializationError: Swift.String
  public static let errorsPairingMachineEncryptionError: Swift.String
  public static let errorsPairingMachineSeanceError: Swift.String
  public static let errorsPairingMachineSerializationError: Swift.String
  public static let errorsPairingMachineTitle: Swift.String
  public static let errorsPairingMachineUnexpectedMessage: Swift.String
  public static let errorsPairingMachineUnexpectedState: Swift.String
  public static let errorsPairingThreadSetupErrorMixedEnvironment: Swift.String
  public static let errorsPairingThreadSetupErrorThreadNetworkNotFound: Swift.String
  public static let errorsPairingThreadSetupErrorThreadOperationalDatasetMissing: Swift.String
  public static let errorsPairingTimedOutConnectWifi: Swift.String
  public static let errorsUnexpectedOccurredPleaseTryAgain: Swift.String
  public static let externalSigninCheckIfUsersRequest: Swift.String
  public static let externalSigninConfirmRequest: Swift.String
  public static let externalSigninConfirmedTitle: Swift.String
  public static let externalSigninContinueOauth: Swift.String
  public static func externalSigninFromLocation(_ p1: Any) -> Swift.String
  public static func externalSigninOnOs(_ p1: Any) -> Swift.String
  public static let externalSigninRejectRequest: Swift.String
  public static let externalSigninRequestCodeCodeScreenTitle: Swift.String
  public static let externalSigninRequestCodeGrantAccess: Swift.String
  public static let externalSigninRequestCodeInstructions: Swift.String
  public static let externalSigninRequestCodePasteboardAccessExplained: Swift.String
  public static let externalSigninRequestedTitle: Swift.String
  public static func externalSigninSigninRequestPeekDescription(_ p1: Any, _ p2: Any, _ p3: Any, _ p4: Any) -> Swift.String
  public static let externalSigninSuccessMessage: Swift.String
  public static func externalSigninWithBrowser(_ p1: Any) -> Swift.String
  public static let faqTitle: Swift.String
  public static let fcmMessageTitle: Swift.String
  public static let generalAnd: Swift.String
  public static let generalAt: Swift.String
  public static let generalCamera: Swift.String
  public static let generalCancel: Swift.String
  public static let generalConnectionLost: Swift.String
  public static let generalConnectionLostExplanation: Swift.String
  public static let generalDelete: Swift.String
  public static let generalDone: Swift.String
  public static let generalError: Swift.String
  public static let generalErrorDescription: Swift.String
  public static let generalIntrusionTriggered: Swift.String
  public static let generalLoading: Swift.String
  public static let generalMore: Swift.String
  public static let generalMove: Swift.String
  public static let generalNext: Swift.String
  public static let generalNo: Swift.String
  public static let generalNotification: Swift.String
  public static let generalOk: Swift.String
  public static let generalSave: Swift.String
  public static let generalUnavailable: Swift.String
  public static let generalUndefined: Swift.String
  public static let generalYes: Swift.String
  public static func hintIssueAlarmIssues(_ p1: Any) -> Swift.String
  public static func hintIssuePluralSystemIssues(_ p1: Any) -> Swift.String
  public static func hintIssueSingularSystemIssue(_ p1: Any) -> Swift.String
  public static let homepageEmptyPlaceCreatePlace: Swift.String
  public static func homepageEmptyPlaceWelcome(_ p1: Any) -> Swift.String
  public static let homepageEmptyPlaceWelcomeDescription: Swift.String
  public static let installationGuideCompleteInstallation: Swift.String
  public static let installationGuideInstallContactSensor: Swift.String
  public static let installationGuideItems1: Swift.String
  public static let installationGuideItems2: Swift.String
  public static let installationGuideItems3Imperial: Swift.String
  public static let installationGuideItems3Metric: Swift.String
  public static let installationGuideItems4: Swift.String
  public static let installationGuideKeypadItem2: Swift.String
  public static func installationGuideTitle(_ p1: Any) -> Swift.String
  public static let internetConnection: Swift.String
  public static func intrusionBannerIntrusionDetectedAt(_ p1: Any) -> Swift.String
  public static let intrusionEventReportIntrusionHistory: Swift.String
  public static let intrusionHistoryErrorDataNotFound: Swift.String
  public static let intrusionHistoryHumanMotion: Swift.String
  public static let intrusionHistoryNoMotion: Swift.String
  public static func intrusionHistoryTimestamp(_ p1: Any) -> Swift.String
  public static let intrusionHistoryTitle: Swift.String
  public static let intrusionLiveDisarmSecuritySystem: Swift.String
  public static let intrusionLiveDisarmSecuritySystemDescription: Swift.String
  public static func intrusionLiveReportByDoorSensor(_ p1: Any, _ p2: Any) -> Swift.String
  public static let intrusionLiveReportDoorClosed: Swift.String
  public static let intrusionLiveReportDoorOpened: Swift.String
  public static let intrusionLiveReportMotion: Swift.String
  public static let intrusionLiveViewNoActivitySinceIntrusionBegan: Swift.String
  public static let invitationDetailAcceptButton: Swift.String
  public static let invitationDetailAgreementDetails: Swift.String
  public static let invitationDetailCancelButton: Swift.String
  public static let invitationDetailDeclineButton: Swift.String
  public static func invitationDetailHello(_ p1: Any) -> Swift.String
  public static func invitationDetailHelloAndroid(_ p1: Any) -> Swift.String
  public static let invitationDetailInviteFound: Swift.String
  public static let invitationDetailInviteNotFound: Swift.String
  public static func invitationDetailQuestion(_ p1: Any) -> Swift.String
  public static func invitationDetailQuestionAndroid(_ p1: Any) -> Swift.String
  public static let invitationDetailRetrievingInviteDetails: Swift.String
  public static let invitationDetailRole: Swift.String
  public static let invitationDetailsRevokeRevokeAlertMessage: Swift.String
  public static let inviteDetailsAskRevokeButton: Swift.String
  public static let inviteDetailsAskShareButton: Swift.String
  public static let inviteDetailsConfirmRevokeButton: Swift.String
  public static func inviteDetailsInviteExpirationText(_ p1: Any) -> Swift.String
  public static func inviteDetailsInviteExpirationTextAndroid(_ p1: Any) -> Swift.String
  public static let inviteDetailsInviteExpired: Swift.String
  public static func inviteDetailsInviteExpiresInText(_ p1: Any) -> Swift.String
  public static func inviteDetailsInviteTitle(_ p1: Any) -> Swift.String
  public static func inviteDetailsInviteTitleAndroid(_ p1: Any) -> Swift.String
  public static func inviteDetailsRevokeAlertMessage(_ p1: Any) -> Swift.String
  public static let inviteDetailsRevokeAlertTitle: Swift.String
  public static func inviteDetailsRevokeInvitationTitle(_ p1: Any) -> Swift.String
  public static let joinPlaceCameraPermissionGuide: Swift.String
  public static let joinPlaceInvalidInvite: Swift.String
  public static let joinPlaceInvalidQrCode: Swift.String
  public static let joinPlaceInviteFound: Swift.String
  public static let joinPlaceRoleGuide: Swift.String
  public static let joinPlaceRoleGuideAdmin: Swift.String
  public static let joinPlaceRoleUserGuide: Swift.String
  public static let joinPlaceScanAgain: Swift.String
  public static let joinPlaceScanInviteQr: Swift.String
  public static let keypadSetupGuideDescription2: Swift.String
  public static let keypadSetupGuideDescription3: Swift.String
  public static let kitExplanationFirstKitDesignedToHelpSecureYourPlace: Swift.String
  public static let kitExplanationFirstKitPlaceDevicesOnFirstFloor: Swift.String
  public static let kitExplanationNonFirstKitBssProvidesAdditionalSecurity: Swift.String
  public static let kitExplanationNonFirstKitHmsMonitorAdditionalAreas: Swift.String
  public static func kitTrackerPluralDeviceLeft(_ p1: Swift.Int) -> Swift.String
  public static func kitTrackerPluralDevicesAdded(_ p1: Swift.Int) -> Swift.String
  public static let letsAddDeviceDismissScreen: Swift.String
  public static let lostAccessPopupMessageMultiplePlaces: Swift.String
  public static let lostAccessPopupMessageSinglePlace: Swift.String
  public static func lostAccessPopupTitle(_ p1: Any) -> Swift.String
  public static let manageDevicesEmptyPlace: Swift.String
  public static let memberDetailsLeavePlace: Swift.String
  public static let memberDetailsRemoveMember: Swift.String
  public static func memberDetailsRemovePeopleMessage(_ p1: Any, _ p2: Any) -> Swift.String
  public static let motionHistoryActiveTime: Swift.String
  public static let motionHistoryDeviceIssue: Swift.String
  public static let motionHistoryDuration: Swift.String
  public static func motionHistoryFormatDaysAndroid(_ p1: Swift.Int) -> Swift.String
  public static func motionHistoryFormatHour(_ p1: Swift.Int) -> Swift.String
  public static func motionHistoryFormatHoursAndroid(_ p1: Swift.Int) -> Swift.String
  public static func motionHistoryFormatMinute(_ p1: Swift.Int) -> Swift.String
  public static func motionHistoryFormatSecond(_ p1: Swift.Int) -> Swift.String
  public static let motionHistoryIntensity: Swift.String
  public static let motionHistoryMonitorWasDegradedDueToDeviceIssue: Swift.String
  public static let motionHistoryMonitorWasDegradedInZonesWithDeviceIssue: Swift.String
  public static let motionHistoryMonitorWasDisabledDueToDeviceIssue: Swift.String
  public static let motionHistoryMonitorWasDisabledInZonesWithDeviceIssue: Swift.String
  public static let motionHistoryMotion: Swift.String
  public static let motionHistoryMotionToday: Swift.String
  public static let motionHistoryNoData: Swift.String
  public static let motionHistoryNotAvailable: Swift.String
  public static let motionHistorySensingDataNotAvailable: Swift.String
  public static let motionHistoryTileHistory: Swift.String
  public static let motionHistoryTileToday: Swift.String
  public static let motionHistoryTileTotalActiveTime: Swift.String
  public static let motionHistoryToday: Swift.String
  public static let motionNowConnectToWifi: Swift.String
  public static let motionNowConnectToWifiAsZone: Swift.String
  public static let motionNowConnectToWifiYourDeviceUsing: Swift.String
  public static let motionNowExplanationDescription1: Swift.String
  public static let motionNowExplanationDescription2: Swift.String
  public static let motionNowExplanationGotIt: Swift.String
  public static let motionNowExplanationLearnMore: Swift.String
  public static let motionNowExplanationSubTitle: Swift.String
  public static func motionNowFormatActiveZonesAndroid(_ p1: Swift.Int) -> Swift.String
  public static let motionNowGoToWifiSettings: Swift.String
  public static let motionNowHowPlaceGraphWorks: Swift.String
  public static let motionNowHowPlaceGraphWorksDescription: Swift.String
  public static let motionNowIntensity: Swift.String
  public static let motionNowMax: Swift.String
  public static let motionNowMin: Swift.String
  public static let motionNowMotionDetectedIn: Swift.String
  public static let motionNowNoSensingData: Swift.String
  public static let motionNowNow: Swift.String
  public static let motionNowThirtySecsAgo: Swift.String
  public static let motionNowTileConnectToWifi: Swift.String
  public static let motionNowTileMore: Swift.String
  public static let motionNowTileMovementDetected: Swift.String
  public static let motionNowTileNoMovementDetected: Swift.String
  public static let motionNowTileNoSensingData: Swift.String
  public static func motionNowTileNumberOfActiveZones(_ p1: Any) -> Swift.String
  public static let motionNowTileToViewMotionNow: Swift.String
  public static let motionNowTitle: Swift.String
  public static let motionSensorCoverageDoNotMountDeviceYet: Swift.String
  public static let motionSensorCoverageGuideTitle: Swift.String
  public static let motionSensorInstallationGuide1: Swift.String
  public static let motionSensorInstallationGuide2: Swift.String
  public static let motionSensorInstallationGuide3: Swift.String
  public static let motionSensorInstallationPreGuide1Imperial: Swift.String
  public static let motionSensorInstallationPreGuide1Metric: Swift.String
  public static let motionSensorInstallationPreGuide2Imperial: Swift.String
  public static let motionSensorInstallationPreGuide2Metric: Swift.String
  public static let motionSensorInstallationPreGuide3: Swift.String
  public static let motionSensorPreGuideDescription1: Swift.String
  public static let motionSensorPreGuideDescription2: Swift.String
  public static let motionSensorPreGuideDescription3: Swift.String
  public static let motionSensorPreGuideTitle1: Swift.String
  public static let motionSensorPreGuideTitle2: Swift.String
  public static let motionSensorPreGuideTitle3: Swift.String
  public static let motionSensorPreGuideTitle4: Swift.String
  public static let msgSessionExpired: Swift.String
  public static func muliplePlacesIntrusionInManyPlaces(_ p1: Swift.Int) -> Swift.String
  public static func muliplePlacesIntrusionInOnePlace(_ p1: Any) -> Swift.String
  public static let newInviteGenerateInviteButton: Swift.String
  public static let newInviteInviteAdminDescription: Swift.String
  public static let newInviteInviteDescription: Swift.String
  public static let newInviteInviteTitle: Swift.String
  public static let newInviteInviteUserDescription: Swift.String
  public static let newInviteInviteeNamePlaceholder: Swift.String
  public static let newInviteInviteeNameTitle: Swift.String
  public static let notificationGoToSettings: Swift.String
  public static func notificationMissingPermission(_ p1: Any) -> Swift.String
  public static func notificationMissingPermissionDesc(_ p1: Any, _ p2: Any) -> Swift.String
  public static let notificationPermissionGuide: Swift.String
  public static let pairDeviceGoToSettings: Swift.String
  public static func pairDeviceMissingPermission(_ p1: Any) -> Swift.String
  public static func pairDeviceMissingPermissionDesc(_ p1: Any, _ p2: Any) -> Swift.String
  public static let pairingAskToConnectConnectToWifi: Swift.String
  public static let pairingAskToConnectFirstThreadDeviceDescription1: Swift.String
  public static let pairingAskToConnectFirstThreadDeviceDescription2: Swift.String
  public static let pairingAskToConnectFirstThreadDeviceDescription3: Swift.String
  public static func pairingAskToConnectFirstWifiDeviceDescription1(_ p1: Any) -> Swift.String
  public static let pairingAskToConnectFirstWifiDeviceDescription2: Swift.String
  public static let pairingAskToConnectNonFirstThreadDeviceDescription1: Swift.String
  public static let pairingAskToConnectNonFirstThreadDeviceDescription2: Swift.String
  public static func pairingAskToConnectNonFirstThreadDeviceDescription3(_ p1: Any) -> Swift.String
  public static func pairingAskToConnectNonFirstWifiDeviceDescription1(_ p1: Any) -> Swift.String
  public static let pairingAskToConnectRemainingThreadDevice: Swift.String
  public static let pairingAskToConnectWifiDeviceImperialDistanceDescription: Swift.String
  public static let pairingAskToConnectWifiDeviceMetricDistanceDescription: Swift.String
  public static let pairingBluetoothDeviceFoundExplainedReadyToPair: Swift.String
  public static let pairingBluetoothDeviceFoundExplainedReadyToPairContactSensor: Swift.String
  public static let pairingBluetoothDeviceFoundHeader1: Swift.String
  public static let pairingBluetoothDeviceFoundHeader2: Swift.String
  public static let pairingBluetoothDeviceFoundHeaderConnectToPower: Swift.String
  public static let pairingBluetoothDeviceFoundNameAlreadyInUse: Swift.String
  public static let pairingBluetoothDeviceFoundNameDeviceExplained: Swift.String
  public static func pairingBluetoothDeviceFoundNameDeviceHeader(_ p1: Any) -> Swift.String
  public static let pairingBluetoothDeviceFoundNameYourDevice: Swift.String
  public static let pairingBluetoothDeviceFoundNextButton: Swift.String
  public static let pairingCancel: Swift.String
  public static let pairingConfirmCancelPairingDescription: Swift.String
  public static let pairingConfirmCancelPairingTitle: Swift.String
  public static func pairingConnectSuccessDeviceHasBeenSetupInZone(_ p1: Any, _ p2: Any) -> Swift.String
  public static func pairingConnectSuccessDeviceHasBeenSetupInZoneOptimizePosition(_ p1: Any, _ p2: Any) -> Swift.String
  public static func pairingConnectSuccessDeviceHasBeenSetupInZoneOptimizePositionIos(_ p1: Any, _ p2: Any) -> Swift.String
  public static let pairingConnectSuccessSetupAnotherDevice: Swift.String
  public static func pairingConnectWifiInputPassword(_ p1: Any) -> Swift.String
  public static let pairingConnectWifiNoWiFiNetworksFound: Swift.String
  public static let pairingConnectWifiSetUpAsBorderRouter: Swift.String
  public static let pairingConnectWifiSettingUpThisDevice: Swift.String
  public static let pairingDeviceSetupNavigationTitle: Swift.String
  public static let pairingDone: Swift.String
  public static let pairingEnableBluetoothInSettingsBluetoothDisabled: Swift.String
  public static let pairingEnableBluetoothInSettingsButtonSettings: Swift.String
  public static let pairingEnableBluetoothInSettingsHeader: Swift.String
  public static let pairingEnterWifiPasswordButtonReadyToConnect: Swift.String
  public static func pairingEnterWifiPasswordEnterPassword(_ p1: Any) -> Swift.String
  public static func pairingEnterWifiPasswordEnterPasswordIos(_ p1: Any) -> Swift.String
  public static func pairingEnterWifiPasswordHeader(_ p1: Any) -> Swift.String
  public static let pairingEnterWifiPasswordPasswordEntryFieldHint: Swift.String
  public static let pairingEnterWifiPasswordPasswordPlaceholder: Swift.String
  public static let pairingErrorAllBorderRouterOffline: Swift.String
  public static func pairingErrorAllBorderRouterOfflineDescription(_ p1: Any) -> Swift.String
  public static func pairingErrorAllBorderRouterOfflineDeviceInZone(_ p1: Any, _ p2: Any) -> Swift.String
  public static let pairingErrorMobilePhoneIsNotConnectedToWifi: Swift.String
  public static let pairingErrorMobilePhoneIsNotConnectedToWifiDescription: Swift.String
  public static let pairingErrorNoThreadBorderRouterInPlace: Swift.String
  public static let pairingErrorNoThreadBorderRouterInPlaceDescription: Swift.String
  public static let pairingErrorsActionIgnore: Swift.String
  public static let pairingErrorsActionRestart: Swift.String
  public static let pairingErrorsActionRestartSetup: Swift.String
  public static let pairingErrorsActionScanDeviceAgain: Swift.String
  public static let pairingErrorsActionTryAgain: Swift.String
  public static let pairingErrorsBleDisconnectedTitle: Swift.String
  public static func pairingErrorsContactSensorSetupErrorNoThreadNetworksFoundDescription1(_ p1: Any) -> Swift.String
  public static let pairingErrorsContactSensorSetupErrorNoThreadNetworksFoundDescription2: Swift.String
  public static let pairingErrorsContactSensorSetupErrorUnableJoinThreadNetworksDescription1: Swift.String
  public static func pairingErrorsContactSensorSetupErrorUnableJoinThreadNetworksDescription2(_ p1: Any) -> Swift.String
  public static let pairingErrorsDeviceSetupErrorDeviceMismatchDescription: Swift.String
  public static let pairingErrorsErrorOccurredTitle: Swift.String
  public static let pairingErrorsFailedToJoinWifiTitle: Swift.String
  public static let pairingErrorsNeedHelp: Swift.String
  public static let pairingErrorsThreadSetupErrorBorderRouterOffline: Swift.String
  public static func pairingErrorsThreadSetupErrorBorderRouterOfflineDescriptionAndroid(_ p1: Any, _ p2: Any) -> Swift.String
  public static let pairingErrorsThreadSetupErrorDeviceMismatchDescription: Swift.String
  public static let pairingErrorsThreadSetupErrorDeviceMismatchTitle: Swift.String
  public static let pairingErrorsThreadSetupErrorMissingThreadCredentials: Swift.String
  public static func pairingErrorsThreadSetupErrorNoThreadNetworksFoundDescription(_ p1: Any) -> Swift.String
  public static let pairingErrorsThreadSetupErrorNoThreadNetworksFoundTitle: Swift.String
  public static let pairingErrorsTimeoutDescription: Swift.String
  public static let pairingErrorsTimeoutTitle: Swift.String
  public static let pairingErrorsUnexpectedDescription: Swift.String
  public static let pairingErrorsUnexpectedTitle: Swift.String
  public static let pairingExit: Swift.String
  public static let pairingExitDeviceSetupDescription: Swift.String
  public static let pairingExitDeviceSetupTitle: Swift.String
  public static let pairingExitSetup: Swift.String
  public static let pairingFinishingSetupGameOfPong: Swift.String
  public static let pairingFinishingSetupHeader: Swift.String
  public static let pairingListWifiNetworksApOutOfReach: Swift.String
  public static let pairingListWifiNetworksAvailableNetworks: Swift.String
  public static let pairingListWifiNetworksButtonOtherNetwork: Swift.String
  public static let pairingListWifiNetworksConnectWifiTitle: Swift.String
  public static let pairingListWifiNetworksForget: Swift.String
  public static let pairingListWifiNetworksFoundSavedPassword: Swift.String
  public static let pairingListWifiNetworksNoNetworksFound: Swift.String
  public static let pairingListWifiNetworksProceed: Swift.String
  public static let pairingListWifiNetworksSelectNetwork: Swift.String
  public static func pairingListWifiNetworksUseSavedPassword(_ p1: Any) -> Swift.String
  public static func pairingLoadingDeviceConnecting(_ p1: Any) -> Swift.String
  public static let pairingNo: Swift.String
  public static let pairingOther: Swift.String
  public static let pairingOtherNetworkTitle: Swift.String
  public static let pairingOtherWifiNetworkDeviceConnectivityHint: Swift.String
  public static let pairingOtherWifiNetworkHeader: Swift.String
  public static let pairingOtherWifiNetworkNetworkNamePlaceholder: Swift.String
  public static let pairingPairedSuccessfullyButtonAddDevice: Swift.String
  public static let pairingPairedSuccessfullyButtonDone: Swift.String
  public static let pairingPairedSuccessfullyButtonNotNow: Swift.String
  public static let pairingPairedSuccessfullyButtonPairAnother: Swift.String
  public static let pairingPairedSuccessfullyButtonUpdateAnother: Swift.String
  public static let pairingPairedSuccessfullyCompleteSetupForMotionSensing: Swift.String
  public static func pairingPairedSuccessfullyCompleteSetupForMotionSensingDescription(_ p1: Any) -> Swift.String
  public static let pairingPairedSuccessfullyHeader3: Swift.String
  public static let pairingPowerOnAndScanningAskUserToWait: Swift.String
  public static let pairingPowerOnAndScanningScanning: Swift.String
  public static let pairingScanDeviceConnectingToThisDevice: Swift.String
  public static let pairingScanDeviceMissingBluetoothLocationPermissionExplanation: Swift.String
  public static let pairingScanDeviceMissingBluetoothLocationPermissionsTitle: Swift.String
  public static let pairingScanDeviceMissingBluetoothPermissionTitle: Swift.String
  public static let pairingScanDevicePleaseHold: Swift.String
  public static let pairingScanDeviceSearchingForDevice: Swift.String
  public static let pairingScanDeviceTheLedLightIsNotPulsing: Swift.String
  public static let pairingScanQrCodeErrorDescription: Swift.String
  public static let pairingScanQrCodeErrorTitle: Swift.String
  public static let pairingScanQrExpandCameraView: Swift.String
  public static let pairingScanQrSubtitle: Swift.String
  public static let pairingScanQrTitle: Swift.String
  public static let pairingScanQrWhereIsQr: Swift.String
  public static let pairingScanQrcodeMissingCameraPermissionDescription: Swift.String
  public static let pairingScanQrcodeMissingCameraPermissionTitle: Swift.String
  public static let pairingScanningBleFaq: Swift.String
  public static let pairingScanningBleHeaderContactSensor: Swift.String
  public static let pairingScanningBleHeaderKeypad: Swift.String
  public static let pairingSuccess: Swift.String
  public static let paringScanDeviceBluetoothIsOffDescription: Swift.String
  public static let paringScanDeviceBluetoothIsOffTitle: Swift.String
  public static let paringScanDeviceBluetoothRestrictedDescription: Swift.String
  public static let paringScanDeviceBluetoothRestrictedTitle: Swift.String
  public static let pkanDevicePlacementTitle: Swift.String
  public static let placeCreation: Swift.String
  public static let placeCreationCustomizeColorSelection: Swift.String
  public static let placeCreationCustomizeHeader: Swift.String
  public static let placeCreationErrorNoCategory: Swift.String
  public static let placeCreationFailToCreatePlace: Swift.String
  public static let placeCreationFailToGetPlaceInformation: Swift.String
  public static let placeCreationFailToUpdatePlace: Swift.String
  public static let placeCreationFloorDescription: Swift.String
  public static func placeCreationFloorFloorNumber(_ p1: Swift.Int) -> Swift.String
  public static func placeCreationFloorFloorNumberAndroid(_ p1: Any) -> Swift.String
  public static let placeCreationFloorHeader: Swift.String
  public static let placeCreationHeader: Swift.String
  public static let placeCreationNameCreatePlace: Swift.String
  public static let placeCreationNameDefaultName: Swift.String
  public static let placeCreationNameDescription: Swift.String
  public static let placeCreationNameEditHint: Swift.String
  public static let placeCreationNameError: Swift.String
  public static let placeCreationNameHeader: Swift.String
  public static let placeCreationPetsDescription: Swift.String
  public static let placeCreationPetsHeader: Swift.String
  public static let placeCreationSizeDescription: Swift.String
  public static let placeCreationSizeHeader: Swift.String
  public static func placeCreationZoneDefaultNameMultipleFloor(_ p1: Any) -> Swift.String
  public static let placeCreationZoneDefaultNameSingleFloor: Swift.String
  public static func placeDetailDoorSensorOpenAlert(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailDoorSensorOpenAlertIos(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailFormatDisconnectedDeviceInOneZoneAndroid(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailNumberOfZone(_ p1: Swift.Int) -> Swift.String
  public static let placeDetailSystemNotReadyToSecure: Swift.String
  public static let placeDetailTimezone: Swift.String
  public static let placeDetailsChangePlaceModeToArmedContainDegradedDescription: Swift.String
  public static let placeDetailsChangePlaceModeToArmedContainUnhealthyDescription: Swift.String
  public static let placeDetailsChangePlaceModeToAwareContainDegradedDescription: Swift.String
  public static let placeDetailsChangePlaceModeToAwareContainUnhealthyDescription: Swift.String
  public static let placeDetailsCustomize: Swift.String
  public static let placeDetailsDashboard: Swift.String
  public static let placeDetailsEvents: Swift.String
  public static func placeDetailsFormatDisconnectedDeviceInMultipleZoneAndroid(_ p1: Swift.Int) -> Swift.String
  public static let placeDetailsGetHelp: Swift.String
  public static let placeDetailsGraph: Swift.String
  public static func placeDetailsMemberPendingExpiryTime(_ p1: Any) -> Swift.String
  public static func placeDetailsMemberPendingExpiryTimeDays(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsMemberPendingExpiryTimeDaysWithHours(_ p1: Swift.Int, _ p2: Swift.Int) -> Swift.String
  public static func placeDetailsMemberPendingExpiryTimeHours(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsMemberPendingExpiryTimeMinutes(_ p1: Swift.Int) -> Swift.String
  public static let placeDetailsMembersActive: Swift.String
  public static func placeDetailsMembersDays(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsMembersHours(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsMembersMinutes(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsMembersMonths(_ p1: Swift.Int) -> Swift.String
  public static let placeDetailsNoDevicesPaired: Swift.String
  public static let placeDetailsOffline: Swift.String
  public static let placeDetailsPeople: Swift.String
  public static let placeDetailsPlaceMode: Swift.String
  public static func placeDetailsProceedWithDegradedZone(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsProceedWithUnhealthyZone(_ p1: Swift.Int) -> Swift.String
  public static let placeDetailsSecurityMode: Swift.String
  public static let placeDetailsSecurityModeDescription: Swift.String
  public static let placeDetailsSensingLinkBrokenInMultipleZone: Swift.String
  public static let placeDetailsSensingLinkBrokenInOneZone: Swift.String
  public static let placeDetailsSensorsAreNotResponding: Swift.String
  public static let placeDetailsStayModeNotActivatedAllZones: Swift.String
  public static let placeDetailsStayModeNotActivatedAllZonesDescription: Swift.String
  public static let placeDetailsStayModeNotAvailable: Swift.String
  public static let placeDetailsStayModeNotAvailableDescription: Swift.String
  public static let placeDetailsSystemNotReadyToSecureDescription: Swift.String
  public static let placeDetailsYesProceed: Swift.String
  public static func placeDetailsZoneInMode(_ p1: Swift.Int) -> Swift.String
  public static func placeDetailsZonesInModeAndroid(_ p1: Swift.Int) -> Swift.String
  public static let placeEventDateFilter: Swift.String
  public static let placeEventToday: Swift.String
  public static let placeEventYesterday: Swift.String
  public static let placeEventsDownloadingHistory: Swift.String
  public static func placeEventsEmptyDescription(_ p1: Any) -> Swift.String
  public static func placeEventsEmptyHistoryPlaceholder(_ p1: Any) -> Swift.String
  public static func placeEventsEmptyHistoryPlaceholderAndroid(_ p1: Any) -> Swift.String
  public static let placeEventsSearchNotFoundDescription: Swift.String
  public static let placeInformationAvgFloorArea: Swift.String
  public static let placeInformationFloors: Swift.String
  public static let placeInformationName: Swift.String
  public static let placeInformationPets: Swift.String
  public static let placeInformationSearchTimeZone: Swift.String
  public static let placeInformationTitle: Swift.String
  public static let placeInformationType: Swift.String
  public static func placeIntegrationsDescriptionPlaceholder(_ p1: Any) -> Swift.String
  public static let placeIntegrationsEnablingPlaceholder: Swift.String
  public static func placeIntegrationsIntegrationIs(_ p1: Any) -> Swift.String
  public static let placeIntegrationsIntegrations: Swift.String
  public static let placeIntegrationsIsDisabled: Swift.String
  public static let placeIntegrationsIsEnabled: Swift.String
  public static let placeIntegrationsWantDisable: Swift.String
  public static let placeModeAlertDialogStayModeNotAllZonesMessage: Swift.String
  public static let placeModeAlertDialogStayModeNotAllZonesTitle: Swift.String
  public static let placeModeAlertDialogStayModeWarningConfirm: Swift.String
  public static let placeModeAlertDialogStayModeWarningMessage: Swift.String
  public static let placeModeAlertDialogStayModeWarningTitle: Swift.String
  public static func placeModeDoorSensorOfflineAlert(_ p1: Swift.Int) -> Swift.String
  public static func placeModeDoorSensorOfflineAlertIos(_ p1: Swift.Int) -> Swift.String
  public static func placeModeWidgetAlarmIntrusionSince(_ p1: Any) -> Swift.String
  public static let placeModeWidgetConfigureSelectPlace: Swift.String
  public static let placeModeWidgetConfigureTitle: Swift.String
  public static let placeModeWidgetDataNotAvailable: Swift.String
  public static let placeModeWidgetErrorNoPlaces: Swift.String
  public static let placeModeWidgetErrorNoSelectedPlace: Swift.String
  public static let placeModeWidgetErrorUserLoggedOut: Swift.String
  public static let placeModeWidgetLogIn: Swift.String
  public static let placeModeWidgetSensingWarning: Swift.String
  public static let placeOverviewGraphNow: Swift.String
  public static let placeOverviewGraphThirtySecsAgo: Swift.String
  public static func placeOverviewIntrusionDetectionEndTime(_ p1: Any) -> Swift.String
  public static func placeOverviewIntrusionDetectionEndTimeFormatHour(_ p1: Swift.Int) -> Swift.String
  public static func placeOverviewIntrusionDetectionEndTimeFormatMinute(_ p1: Swift.Int) -> Swift.String
  public static func placeOverviewIntrusionDetectionStartTime(_ p1: Any) -> Swift.String
  public static let placeOverviewIntrusionDetectionTitle: Swift.String
  public static let placeOverviewMotion: Swift.String
  public static let placeOverviewNoDevicesHasBeenAdded: Swift.String
  public static let placeOverviewPairKitUnlockMotionSensing: Swift.String
  public static let placeOverviewPairingRequestAddDeviceButton: Swift.String
  public static let placeOverviewPairingRequestSetupAKit: Swift.String
  public static let placeOverviewPairingRequestSetupAKitGuide: Swift.String
  public static let placeOverviewSetupKitButton: Swift.String
  public static let placeOverviewZones: Swift.String
  public static let placePairOneMoreDeviceToUnlockTheMotionSensing: Swift.String
  public static let placePeopleInviteTitle: Swift.String
  public static let placePets: Swift.String
  public static let placePetsBigPets: Swift.String
  public static let placePetsBigPetsImperial: Swift.String
  public static let placePetsBigPetsMetric: Swift.String
  public static let placePetsBothSmallBigPets: Swift.String
  public static let placePetsNone: Swift.String
  public static let placePetsSmallPets: Swift.String
  public static let placePetsSmallPetsImperial: Swift.String
  public static let placePetsSmallPetsMetric: Swift.String
  public static let placePropertiesApartment: Swift.String
  public static let placePropertiesHouse: Swift.String
  public static let placeSettingEditPlaceToolbar: Swift.String
  public static let placeSettingHeaderAddDevices: Swift.String
  public static let placeSettingHeaderAddDevicesDescription: Swift.String
  public static let placeSettingHeaderGeneral: Swift.String
  public static let placeSettingHeaderSetup: Swift.String
  public static let placeSettingHeaderSetupADeviceDescription: Swift.String
  public static let placeSettingHeaderSetupADeviceTitle: Swift.String
  public static let placeSettingHeaderSetupAKitDescriptionDisableNonFirstKit: Swift.String
  public static let placeSettingHeaderSetupAKitDescriptionDisableOldPlace: Swift.String
  public static let placeSettingHeaderSetupAKitDescriptionEnable: Swift.String
  public static let placeSettingHeaderSetupAKitTitle: Swift.String
  public static let placeSettingPlaceInformation: Swift.String
  public static let placeSettingPlaceInformationDescription: Swift.String
  public static let placeSettingPlaceInformationEditName: Swift.String
  public static let placeSettingPlaceInformationFloor: Swift.String
  public static let placeSettingPlaceInformationName: Swift.String
  public static let placeSettingPlaceInformationSize: Swift.String
  public static let placeSettingPlaceInformationType: Swift.String
  public static let placeSettingsClearThreadCredential: Swift.String
  public static let placeSettingsDeletePlaceButton: Swift.String
  public static func placeSettingsDevicesDescriptionAndroid(_ p1: Swift.Int) -> Swift.String
  public static let placeSettingsEditPlace: Swift.String
  public static let placeSettingsEditPlaceDescription: Swift.String
  public static let placeSettingsEngine: Swift.String
  public static let placeSettingsEngineDoesNotSupportSensitivity: Swift.String
  public static func placeSettingsLastAdminLeaveDialogDescription(_ p1: Any) -> Swift.String
  public static let placeSettingsLastAdminLeaveDialogTitle: Swift.String
  public static let placeSettingsLeavePlaceButton: Swift.String
  public static func placeSettingsManageDevices(_ p1: Swift.Int) -> Swift.String
  public static let placeSettingsMotion: Swift.String
  public static let placeSettingsPlaceSettings: Swift.String
  public static let placeSettingsSectionGeneral: Swift.String
  public static let placeSettingsSectionSetup: Swift.String
  public static let placeSettingsSecurity: Swift.String
  public static let placeSettingsSensitivity: Swift.String
  public static func placeSettingsSensitivityLevel(_ p1: Any) -> Swift.String
  public static let placeSettingsSetupKit: Swift.String
  public static let placeSettingsTitle: Swift.String
  public static let placeSettingsUpdateWifiNetwork: Swift.String
  public static let placeSettingsUpdateWifiNetworkDescription: Swift.String
  public static let placeSettingsZeroDeviceDescription: Swift.String
  public static func placeSettingsZonesDescriptionAndroid(_ p1: Swift.Int) -> Swift.String
  public static let placeUsersInvitationInvitePeople: Swift.String
  public static func placeUsersInvitationUsersLimitReached(_ p1: Any) -> Swift.String
  public static func placeUsersInvitationUsersLimitReachedAndroid(_ p1: Any) -> Swift.String
  public static let placeUsersRoleRole: Swift.String
  public static let placeWidgetDoorSensorIsRequiredToActivateStayMode: Swift.String
  public static let placeWidgetStayModeActivatedForZonesWithoutDoorSensor: Swift.String
  public static let placesCategoryApartment: Swift.String
  public static let placesCategoryBusiness: Swift.String
  public static let placesCategoryDetachedHouse: Swift.String
  public static let placesCategoryEating: Swift.String
  public static let placesCategoryHouse: Swift.String
  public static let placesCategoryShopping: Swift.String
  public static let placesCategoryTownhouse: Swift.String
  public static let placesCategoryUnknown: Swift.String
  public static let placesCategoryWork: Swift.String
  public static let planDevicePlacementAvoidPlacementNearElectronic: Swift.String
  public static let planDevicePlacementGuide1Imperial: Swift.String
  public static let planDevicePlacementGuide1Metric: Swift.String
  public static let planDevicePlacementGuide2Imperial: Swift.String
  public static let planDevicePlacementGuide2Metric: Swift.String
  public static let planDevicePlacementGuide3Imperial: Swift.String
  public static let planDevicePlacementGuide3Metric: Swift.String
  public static func planDevicePlacementGuide4Imperial(_ p1: Any) -> Swift.String
  public static func planDevicePlacementGuide4Metric(_ p1: Any) -> Swift.String
  public static let planDevicePlacementGuide5Imperial: Swift.String
  public static let planDevicePlacementGuide5Metric: Swift.String
  public static let planDevicePlacementTitle: Swift.String
  public static let profileAccount: Swift.String
  public static let profileAccountManagementAccountDeletionDescription: Swift.String
  public static let profileAccountManagementConfirmAccountDeletion: Swift.String
  public static let profileAccountManagementDeleteAccountAlertDescription: Swift.String
  public static let profileAccountManagementDeleteAccountAlertTitle: Swift.String
  public static let profileAccountManagementDeleteAccountButton: Swift.String
  public static let profileAccountManagementTitle: Swift.String
  public static let profileAppVersion: Swift.String
  public static let profileAuthentication: Swift.String
  public static let profileCopied: Swift.String
  public static let profileCopiedToClipboard: Swift.String
  public static let profileCopyRecoveryKey: Swift.String
  public static let profileDeveloperModeAlertDescription: Swift.String
  public static let profileDeveloperModeAlertTitle: Swift.String
  public static let profileDeveloperModeDeactivateAction: Swift.String
  public static let profileDeveloperModeDeactivateAlertDescription: Swift.String
  public static let profileDeveloperModeDeactivateAlertTitle: Swift.String
  public static let profileDeveloperModeTitle: Swift.String
  public static let profileGoConfirmSigninRequest: Swift.String
  public static let profileHelpAndFeedback: Swift.String
  public static let profileHelpNFeedback: Swift.String
  public static let profileLegal: Swift.String
  public static let profileLinkAccountGuideText: Swift.String
  public static let profileLinked3rdPartyAccount: Swift.String
  public static let profileLinkedThirdPartyAccounts: Swift.String
  public static let profileLinkedThirdPartyAccountsNotLinkYet: Swift.String
  public static let profileLinkedThirdPartyAccountsUnlink: Swift.String
  public static let profileNoLinkedAccountsMessage: Swift.String
  public static let profilePrivacyPolicy: Swift.String
  public static let profileRecoveryInfoTitle: Swift.String
  public static let profileRecoveryKey: Swift.String
  public static let profileRecoveryKeyHint: Swift.String
  public static let profileSectionTitleAccount: Swift.String
  public static let profileSectionTitleHelp: Swift.String
  public static let profileSendTestPush: Swift.String
  public static let profileSettings: Swift.String
  public static let profileSignOut: Swift.String
  public static let profileSupportArticle: Swift.String
  public static let profileSupportArticles: Swift.String
  public static let profileTermsOfServices: Swift.String
  public static let profileUnlinkAlertConfirm: Swift.String
  public static let profileUnlinkAlertMessage: Swift.String
  public static let profileUnlinkAlertMessageAndroid: Swift.String
  public static let profileUnlinkAlertTitle: Swift.String
  public static let profileUser: Swift.String
  public static let profileUsername: Swift.String
  public static let profileUsernameYou: Swift.String
  public static let qrscannerWhereQr: Swift.String
  public static let recoveryButtonRecover: Swift.String
  public static let recoveryError: Swift.String
  public static let recoveryRecoveryKeyPlaceholder: Swift.String
  public static let recoveryTextGuide: Swift.String
  public static let removeDeviceChangeThreadNetwork: Swift.String
  public static func removeDeviceChangeThreadNetworkDescription(_ p1: Any) -> Swift.String
  public static let removeDeviceDataRemovedWarningThread: Swift.String
  public static func removeDeviceDataRemovedWarningThreadInZone(_ p1: Any) -> Swift.String
  public static let removeDeviceDataRemovedWarningWifi: Swift.String
  public static let removeDeviceDisableSensingFunction: Swift.String
  public static func removeDeviceDisableSensingFunctionDescription(_ p1: Any) -> Swift.String
  public static func removeDeviceRemoveDeviceName(_ p1: Any) -> Swift.String
  public static let removeDeviceRemoveThisDevice: Swift.String
  public static let removeDeviceRemoveThreadNetwork: Swift.String
  public static func removeDeviceRemoveThreadNetworkDescription(_ p1: Any) -> Swift.String
  public static func removeDeviceRestoreSensingInZone(_ p1: Any) -> Swift.String
  public static let removeDeviceRestoreSensingInZoneDescription: Swift.String
  public static let reportFalseAlarmByContinuingIntrusionWillBeDisarmed: Swift.String
  public static let reportFalseAlarmReportingAsFalseAlarmWillAlsoDisarmTheIntrusion: Swift.String
  public static let reportFalseAlarmTheIntrusionWasTriggeredBy: Swift.String
  public static let roomNamePlaceholder: Swift.String
  public static let roomSelectionTitle: Swift.String
  public static let roomsCategoryBathroom: Swift.String
  public static let roomsCategoryBedroom: Swift.String
  public static let roomsCategoryDinningArea: Swift.String
  public static let roomsCategoryKitchen: Swift.String
  public static let roomsCategoryLivingRoom: Swift.String
  public static let roomsCategoryOffice: Swift.String
  public static let roomsCategoryOther: Swift.String
  public static let roomsCategoryRetailSpace: Swift.String
  public static let roomsCategoryStoreRoom: Swift.String
  public static let roomsCategoryUnknown: Swift.String
  public static let securityModeAddMoreZoneToShowZoneSettings: Swift.String
  public static let securityModeDegradedZone: Swift.String
  public static let securityModeDisabledZone: Swift.String
  public static let securityModeDiscard: Swift.String
  public static let securityModeDiscardChanges: Swift.String
  public static let securityModeDiscardChangesDescription: Swift.String
  public static let securityModeExplanationBottomSheetGotIt: Swift.String
  public static let securityModeExplanationBottomSheetLearnMore: Swift.String
  public static let securityModeExplanationGotIt: Swift.String
  public static let securityModeExplanationLearnMore: Swift.String
  public static let securityModeExplanationStatusArmedDescription: Swift.String
  public static let securityModeExplanationStatusStandbyDescription: Swift.String
  public static let securityModeExplanationStatusStayDescription: Swift.String
  public static let securityModeExplanationSubTitle: Swift.String
  public static let securityModeExplanationTitle: Swift.String
  public static let securityModeStatusArmedDescription: Swift.String
  public static let securityModeStatusAwareDescription: Swift.String
  public static let securityModeStatusRelaxedDescription: Swift.String
  public static let securityModeStatusStandbyDescription: Swift.String
  public static let securityModeStatusStayDescription: Swift.String
  public static let securityModeZoneMode: Swift.String
  public static let securityModeZoneModeDescription: Swift.String
  public static let selectDeviceSetupDescription: Swift.String
  public static let selectFloorAreaDescription: Swift.String
  public static let selectFloorAreaHeader: Swift.String
  public static let selectFloorAreaOption1Imperial: Swift.String
  public static let selectFloorAreaOption1Metric: Swift.String
  public static let selectFloorAreaOption2Imperial: Swift.String
  public static let selectFloorAreaOption2Metric: Swift.String
  public static let selectFloorAreaOption3Imperial: Swift.String
  public static let selectFloorAreaOption3Metric: Swift.String
  public static let selectFloorAreaOption4Imperial: Swift.String
  public static let selectFloorAreaOption4Metric: Swift.String
  public static let selectFloorNumberDescription: Swift.String
  public static let selectFloorNumberHeader: Swift.String
  public static let selectKitDescription: Swift.String
  public static let selectKitMonitoringKit: Swift.String
  public static let selectKitMonitoringKitDescription: Swift.String
  public static let selectKitSecurityKit: Swift.String
  public static let selectKitSecurityKitDescription: Swift.String
  public static let selectKitTitle: Swift.String
  public static let selectPlaceIconHeader: Swift.String
  public static let selectPlaceThemeHeader: Swift.String
  public static let selectPlaceTypeDescription: Swift.String
  public static let selectPlaceTypeHeader: Swift.String
  public static let selectRoomCategoryHeader: Swift.String
  public static let selectRoomIconHeader: Swift.String
  public static let selectUserIconChooseProfileImage: Swift.String
  public static let selectUserIconPromptMessage: Swift.String
  public static let selectZoneDescription: Swift.String
  public static func selectZoneFormatAccessoryDevices(_ p1: Swift.Int) -> Swift.String
  public static func selectZoneFormatSensingDevices(_ p1: Swift.Int) -> Swift.String
  public static func selectZoneFormatThreadDevices(_ p1: Swift.Int) -> Swift.String
  public static func selectZoneFormatWifidevices(_ p1: Swift.Int) -> Swift.String
  public static let selectZoneTitle: Swift.String
  public static let sensing: Swift.String
  public static let sensitivitySettingsDescriptionUnavailable: Swift.String
  public static let sensitivitySettingsEngineUnavailable: Swift.String
  public static func sensitivitySettingsLevelAndroid(_ p1: Any) -> Swift.String
  public static let sensitivitySettingsMaxTitle: Swift.String
  public static let sensitivitySettingsMaxTitleAndroid: Swift.String
  public static let sensitivitySettingsMinTitle: Swift.String
  public static let sensitivitySettingsMinTitleAndroid: Swift.String
  public static let sensitivitySettingsSensitivityLevelDescription: Swift.String
  public static let sensitivitySettingsSuccess: Swift.String
  public static let sensitivitySettingsTitle: Swift.String
  public static let setupADeviceRoomSelectionSubTittle: Swift.String
  public static let setupADeviceRoomSelectionTittle: Swift.String
  public static let setupADeviceToolbarTitle: Swift.String
  public static let setupAKitFeatureNotAvailableDescription: Swift.String
  public static let setupAKitFeatureNotAvailableHeader: Swift.String
  public static let setupAKitHowDeviceWorkDescription: Swift.String
  public static let setupAKitHowDeviceWorkTittle: Swift.String
  public static let setupAKitHowDeviceWorksExplanationContent1: Swift.String
  public static let setupAKitHowDeviceWorksExplanationContent2: Swift.String
  public static let setupAKitHowDeviceWorksExplanationContent3: Swift.String
  public static let setupAKitHowDeviceWorksExplanationContent4: Swift.String
  public static let setupAKitHowDeviceWorksExplanationContent5: Swift.String
  public static let setupAKitHowDeviceWorksGuideContent1: Swift.String
  public static let setupAKitHowDeviceWorksGuideContent2: Swift.String
  public static let setupAKitHowDeviceWorksGuideContent3: Swift.String
  public static let setupAKitHowDeviceWorksGuideContent4: Swift.String
  public static let setupAKitHowDeviceWorksGuideContent5: Swift.String
  public static let setupAKitHowDeviceWorksStart: Swift.String
  public static func setupAKitHowToPlaceDeviceAddDevice(_ p1: Any) -> Swift.String
  public static let setupAKitHowToPlaceDeviceAddFirstSensePlug: Swift.String
  public static let setupAKitHowToPlaceDeviceAddSecondSensePlug: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideContent1FirstPairedDevice: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideContent2FirstPairedDeviceImperial: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideContent2FirstPairedDeviceMetric: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideContent3NonFirstPairedDevice: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideFirstDevice: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideFirstDeviceInZone: Swift.String
  public static let setupAKitHowToPlaceDeviceGuideNonFirstDevice: Swift.String
  public static let setupAKitHowToPlaceDeviceNonFirstPairedDeviceGuideContent1: Swift.String
  public static let setupAKitHowToPlaceDeviceNonFirstPairedDeviceGuideContent2Imperial: Swift.String
  public static let setupAKitHowToPlaceDeviceNonFirstPairedDeviceGuideContent2Metric: Swift.String
  public static let setupAKitHowToPlaceDeviceNonFirstWidarHasBrGuideContent3: Swift.String
  public static let setupAKitIntroduceZoneContent1: Swift.String
  public static let setupAKitIntroduceZoneContent2: Swift.String
  public static let setupAKitIntroduceZoneContent3: Swift.String
  public static let setupAKitIntroduceZoneContent4: Swift.String
  public static let setupAKitIntroduceZoneContent5: Swift.String
  public static let setupAKitIntroduceZoneTitle: Swift.String
  public static let setupAKitKitSelectionTittle: Swift.String
  public static let setupAKitSelectYourPreferredZoneTitle: Swift.String
  public static let setupAKitToolbarTittle: Swift.String
  public static let setupAKitWhereToSetupAddGuide: Swift.String
  public static let setupAKitWhereToSetupOneFloorTitle: Swift.String
  public static func setupAKitWhereToSetupPlaceSizeLargeCoverage1Floor(_ p1: Any) -> Swift.String
  public static func setupAKitWhereToSetupPlaceSizeLargeCoverageMoreFloors(_ p1: Any) -> Swift.String
  public static let setupAKitWhereToSetupPlaceSizeSmallCoverage1Floor: Swift.String
  public static let setupAKitWhereToSetupSubTittleMoreFloorMonitoring: Swift.String
  public static let setupAKitWhereToSetupSubTittleMoreFloorSecurity: Swift.String
  public static let setupAKitWhereToSetupSubtitleMonitorOneFloorBigSize: Swift.String
  public static let setupAKitWhereToSetupSubtitleOneFloorSmallSize: Swift.String
  public static let setupAKitWhereToSetupSubtitleSecurityOneFloorBigSize: Swift.String
  public static let setupAKitWhereToSetupTittle: Swift.String
  public static let setupKitKitTrackerAllDevicesAdded: Swift.String
  public static let setupKitSecurityModeControlHowYourPlaceIsProtected: Swift.String
  public static let setupKitSecurityModeSelectSecurityModeForPlace: Swift.String
  public static let setupKitSecurityModeWhatIsSecurityMode: Swift.String
  public static let setupKitSecurityModeYouCanChangeLater: Swift.String
  public static let setupKitTestSystemCompleteTest: Swift.String
  public static let setupKitTestSystemDoorSensorDescription: Swift.String
  public static let setupKitTestSystemDoorSensorFaq: Swift.String
  public static let setupKitTestSystemMotionSensingDescription: Swift.String
  public static let setupKitTestSystemMotionSensingFaq: Swift.String
  public static let setupKitTestSystemPreparingDevice: Swift.String
  public static let setupKitTestSystemSiren: Swift.String
  public static let setupKitTestSystemSirenDescription: Swift.String
  public static let setupKitTestSystemSirenFaq: Swift.String
  public static let setupKitTestSystemSkipAll: Swift.String
  public static let setupKitTestSystemSoundSiren: Swift.String
  public static let setupKitTestSystemStopSiren: Swift.String
  public static let setupKitTestSystemTitle: Swift.String
  public static let setupKitTitle: Swift.String
  public static let setupKitYourSystemIsReadyToSecureYourPlace: Swift.String
  public static let setupKitYoureAllSet: Swift.String
  public static let setupMotionSensingFirstBssFirstKit: Swift.String
  public static func setupMotionSensingFirstBssNonFirstKitHasBr(_ p1: Any) -> Swift.String
  public static let setupMotionSensingFirstBssNonFirstKitNoBr: Swift.String
  public static let setupMotionSensingFirstHmsFirstKit: Swift.String
  public static func setupMotionSensingFirstHmsNonFirstKitHasBr(_ p1: Any) -> Swift.String
  public static let setupMotionSensingFirstHmsNonFirstKitNoBr: Swift.String
  public static let setupMotionSensingFirstNot: Swift.String
  public static let setupMotionSensingFirstTheDoorSensorDoesNotDetectMotion: Swift.String
  public static let setupMotionSensingFirstTheDoorSensorDoesNotDetectMotionMarkdown: Swift.String
  public static let setupMotionSensingFirstTitle: Swift.String
  public static let setupMotionSensingFirstWidarFirstKit: Swift.String
  public static func setupMotionSensingFirstWidarNonFirstKitHasBr1(_ p1: Any) -> Swift.String
  public static let setupMotionSensingFirstWidarNonFirstKitHasBr2: Swift.String
  public static let setupMotionSensingFirstWidarNonFirstKitNoBr: Swift.String
  public static let signUpAnonymousAccountText: Swift.String
  public static let signUpAnonymousAccountText1: Swift.String
  public static let signUpAnonymousAccountText2: Swift.String
  public static let signUpAnonymousAccountText3: Swift.String
  public static let signUpButtonRecoveryKey: Swift.String
  public static let signUpButtonSignUpAnonymous: Swift.String
  public static let signUpContinueWithApple: Swift.String
  public static let signUpContinueWithGoogle: Swift.String
  public static let signUpOtherSignUpOptions: Swift.String
  public static let signUpPrivacyPolicy: Swift.String
  public static let signUpTermsOfService: Swift.String
  public static let signUpTosAndPrivacyPart1: Swift.String
  public static let signUpTosAndPrivacyPart2: Swift.String
  public static let signUpTosAndPrivacyPart2Android: Swift.String
  public static let signUpTosAndPrivacyPart3: Swift.String
  public static let signUpTosAndPrivacyPart4: Swift.String
  public static let signUpTosAndPrivacyPart4Android: Swift.String
  public static let signUpWelcomeText: Swift.String
  public static let statusAlert: Swift.String
  public static let statusArmed: Swift.String
  public static let statusArmedHint: Swift.String
  public static let statusArmedHintDisabled: Swift.String
  public static let statusAware: Swift.String
  public static let statusAwareHint: Swift.String
  public static func statusInSwitchingMode(_ p1: Any, _ p2: Any) -> Swift.String
  public static let statusRelaxed: Swift.String
  public static let statusRelaxedHint: Swift.String
  public static let statusStandby: Swift.String
  public static let statusStandbyHint: Swift.String
  public static let statusStay: Swift.String
  public static let statusStayHint: Swift.String
  public static let statusStayHintDisabled: Swift.String
  public static let systemSetupBasicSecuritySystem: Swift.String
  public static let systemSetupBasicSecuritySystemDescription: Swift.String
  public static let systemSetupHomeMonitoringSystem: Swift.String
  public static let systemSetupHomeMonitoringSystemDescription: Swift.String
  public static let systemSetupOthers: Swift.String
  public static let systemSetupSetupSingleDeviceDialogButton: Swift.String
  public static let systemSetupSetupSingleDeviceDialogDescription: Swift.String
  public static let systemSetupSetupSingleDeviceDialogTitle: Swift.String
  public static let systemSetupWidarDoorSensor: Swift.String
  public static let systemSetupWidarDoorSensorDescription: Swift.String
  public static let tabbarTitleAutomation: Swift.String
  public static let tabbarTitlePlace: Swift.String
  public static let tabbarTitleSettings: Swift.String
  public static let timeZoneNoResultsFound: Swift.String
  public static let timeZoneSearchTimeZone: Swift.String
  public static func updateWifiDeviceAlreadyUpdated(_ p1: Any) -> Swift.String
  public static func updateWifiDeviceNotInZone(_ p1: Any) -> Swift.String
  public static let updateWifiHowItWorksConfirmButton: Swift.String
  public static let updateWifiHowItWorksDescription: Swift.String
  public static let updateWifiHowItWorksHelp: Swift.String
  public static let updateWifiHowItWorksInstructionBulletPoint1: Swift.String
  public static let updateWifiHowItWorksInstructionBulletPoint2: Swift.String
  public static let updateWifiHowItWorksInstructionBulletPoint3: Swift.String
  public static let updateWifiHowItWorksInstructionBulletPoint4: Swift.String
  public static let updateWifiHowItWorksInstructionPart1: Swift.String
  public static let updateWifiHowItWorksInstructionPart2: Swift.String
  public static let updateWifiHowItWorksInstructionTitle: Swift.String
  public static let updateWifiHowItWorksTitle: Swift.String
  public static let updateWifiLocateDeviceButton: Swift.String
  public static let updateWifiNetworkCommissioningModeCustomizePlace: Swift.String
  public static func updateWifiNetworkDeviceQrCodeDeviceAlreadyRepairedAndroid(_ p1: Any) -> Swift.String
  public static func updateWifiNetworkDeviceQrCodeDeviceNotInZoneAndroid(_ p1: Any) -> Swift.String
  public static let updateWifiNetworkHowItWorksGuideSubtitle: Swift.String
  public static let updateWifiNetworkResetDeviceGuidePlugType: Swift.String
  public static let updateWifiNetworkResetDeviceGuidePod2: Swift.String
  public static let updateWifiNetworkResetDeviceGuidePodType: Swift.String
  public static let updateWifiNetworkUpdateSuccessfullyHeader1: Swift.String
  public static let updateWifiNetworkZoneStatusGuideCompletedUpdate: Swift.String
  public static let updateWifiNetworkZonesSelectionGuide: Swift.String
  public static let updateWifiNotNamiQrCodeNoZone: Swift.String
  public static let updateWifiQrCodeError: Swift.String
  public static let updateWifiQrDoesNotMatch: Swift.String
  public static let updateWifiResetDeviceConfirmButton: Swift.String
  public static let updateWifiResetDeviceDescription: Swift.String
  public static func updateWifiResetDeviceHowToReset(_ p1: Any) -> Swift.String
  public static let updateWifiResetDevicePlugResetInstructions1: Swift.String
  public static let updateWifiResetDevicePlugResetInstructions2: Swift.String
  public static let updateWifiResetDevicePlugResetInstructions3: Swift.String
  public static let updateWifiResetDevicePlugResetInstructions4: Swift.String
  public static let updateWifiResetDevicePodResetInstructions1: Swift.String
  public static let updateWifiResetDevicePodResetInstructions2: Swift.String
  public static let updateWifiResetDevicePodResetInstructions3: Swift.String
  public static let updateWifiResetDevicePodResetInstructions4: Swift.String
  public static let updateWifiResetDeviceTitle: Swift.String
  public static let updateWifiSelectZoneToUpdateConfirmButton: Swift.String
  public static let updateWifiSelectZoneToUpdateDescription: Swift.String
  public static let updateWifiSelectZoneToUpdateNonThreadZoneSupport: Swift.String
  public static func updateWifiSelectZoneToUpdateNumberOfDevices(_ p1: Any) -> Swift.String
  public static let updateWifiSelectZoneToUpdateSelectZone: Swift.String
  public static let updateWifiSelectZoneToUpdateTitle: Swift.String
  public static let updateWifiTitle: Swift.String
  public static let updateWifiZoneDeviceCheckScanQr: Swift.String
  public static let updateWifiZoneWifiUpdateConfirmButton: Swift.String
  public static let updateWifiZoneWifiUpdateCongratulations: Swift.String
  public static let updateWifiZoneWifiUpdateDescription: Swift.String
  public static let updateWifiZoneWifiUpdateDevicesUpdated: Swift.String
  public static let updateWifiZoneWifiUpdateFinishButton: Swift.String
  public static let updateWifiZoneWifiUpdateLastDeviceDescription: Swift.String
  public static let updateWifiZoneWifiUpdateLocateDevice: Swift.String
  public static let updateWifiZoneWifiUpdateSessionCompleted: Swift.String
  public static let updateWifiZoneWifiUpdateUpdateAnotherZoneButton: Swift.String
  public static func upgradeMultiZonesCreateFailed(_ p1: Any) -> Swift.String
  public static func upgradeMultiZonesLoadZoneFailed(_ p1: Any) -> Swift.String
  public static func upgradeMultiZonesUpdateFailed(_ p1: Any) -> Swift.String
  public static let userDetailsAskLeavePlaceButton: Swift.String
  public static let userDetailsAskRemoveUserButton: Swift.String
  public static let userDetailsConfirmLeavePlaceButton: Swift.String
  public static let userDetailsConfirmRemoveUserButton: Swift.String
  public static func userDetailsLeavePlaceAlertMessage(_ p1: Any) -> Swift.String
  public static let userDetailsLeavePlaceAlertTitle: Swift.String
  public static func userDetailsRemoveUserAlertMessage(_ p1: Any, _ p2: Any) -> Swift.String
  public static let userDetailsRemoveUserAlertTitle: Swift.String
  public static let userDetailsSaveChangesButton: Swift.String
  public static let userRemoveUserDescription: Swift.String
  public static func userRemoveUserTitle(_ p1: Any) -> Swift.String
  public static let userRoleAdministrator: Swift.String
  public static let userRoleUser: Swift.String
  public static let welcomePagePolicy: Swift.String
  public static let widarCancelPopupBackToPositioningButton: Swift.String
  public static let widarCancelPopupCancelButton: Swift.String
  public static let widarCancelPopupMessage: Swift.String
  public static let widarCancelPopupTitle: Swift.String
  public static let widarErrorDeviceNotFoundMessage: Swift.String
  public static let widarErrorExitButton: Swift.String
  public static let widarErrorRetryButton: Swift.String
  public static let widarErrorTitle: Swift.String
  public static let widarErrorWrongStep: Swift.String
  public static let widarHeaderTitle: Swift.String
  public static let widarInfoButtonText: Swift.String
  public static let widarInfoInfoAvoidMovingWhenOptimized: Swift.String
  public static let widarInfoInfoMustOptimisePosition: Swift.String
  public static let widarInfoTitle: Swift.String
  public static let widarPositionCancelButton: Swift.String
  public static let widarPositionFinishButton: Swift.String
  public static let widarPositionGuideImperial: Swift.String
  public static let widarPositionGuideMetric: Swift.String
  public static let widarPositionImperialGuide: Swift.String
  public static let widarPositionMetricGuide: Swift.String
  public static let widarPositionStatusChecking: Swift.String
  public static let widarPositionStatusGettingBetter: Swift.String
  public static let widarPositionStatusLabel: Swift.String
  public static let widarPositionStatusMispositioned: Swift.String
  public static let widarPositionStatusOptimized: Swift.String
  public static let widarPositionTertiaryButtonText: Swift.String
  public static let widarPositionTip: Swift.String
  public static let widarPositionTitle: Swift.String
  public static let widarRecommendationsButtonText: Swift.String
  public static let widarRecommendationsInfoAttachBase: Swift.String
  public static let widarRecommendationsInfoKeepAreaClear: Swift.String
  public static let widarRecommendationsInfoWireOnBack: Swift.String
  public static let widarRecommendationsTitle: Swift.String
  public static func widarSuccessContentMessage(_ p1: Any) -> Swift.String
  public static let widarSuccessDoneButton: Swift.String
  public static let widarSuccessTitle: Swift.String
  public static let zoneChecksMotionSensingCheckName: Swift.String
  public static let zoneChecksMotionSensingStatusDisconnected: Swift.String
  public static let zoneChecksMotionSensingStatusNotWorking: Swift.String
  public static let zoneChecksMotionSensingStatusWorkingMotionDetected: Swift.String
  public static let zoneChecksMotionSensingStatusWorkingMotionNotDetected: Swift.String
  public static let zoneChecksZoneHealthCheckName: Swift.String
  public static let zoneChecksZoneHealthHintAssessingZoneHealth: Swift.String
  public static let zoneChecksZoneHealthHintCheckNeeded: Swift.String
  public static let zoneChecksZoneHealthHintWorksWell: Swift.String
  public static let zoneChecksZoneHealthStatusDegraded: Swift.String
  public static let zoneChecksZoneHealthStatusHealthy: Swift.String
  public static let zoneChecksZoneHealthStatusUnhealthy: Swift.String
  public static let zoneChecksZoneHealthStatusUnknown: Swift.String
  public static let zoneDefaultName: Swift.String
  public static let zoneGuideGotIt: Swift.String
  public static let zoneGuideHeader: Swift.String
  public static let zoneGuideSubtitle1: Swift.String
  public static let zoneGuideSubtitle2: Swift.String
  public static let zoneGuideTitle1: Swift.String
  public static let zoneGuideTitle2: Swift.String
  public static let zoneGuideTitle3: Swift.String
  public static let zoneSelectionAddYourKitTo: Swift.String
  public static let zoneSelectionIDontKnowWhatToChoose: Swift.String
  public static let zoneSelectionNonThreadBorderRouterZoneExplain: Swift.String
  public static let zoneSelectionTitle: Swift.String
  public static let zoneSelectionZoneDeviceLimitationExplain: Swift.String
}
extension NamiPairingFramework.I18n {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func setLanguageOverride(_ languageCode: Swift.String?)
  #endif
}
public enum Log {
  public static func info(_ items: Any...)
  public static func warning(_ items: Any...)
  public static func `if`(_ condition: Swift.Bool = true, run: () -> Swift.Void)
  public static func enableLogtoFile(enableLogtoFile: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  public static func getLogFile() -> Foundation.URL?
  #endif
  public static func resetLogFile()
  public static var isEnabledLogFile: Swift.Bool {
    get
  }
}
public enum Tokens : Swift.String {
  case access
  case refresh
  case recovery
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum TokenStoreError : Swift.Error {
  case notFound
  case decodingError
  case systemError
  public static func == (a: NamiPairingFramework.TokenStoreError, b: NamiPairingFramework.TokenStoreError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TokenStore {
  func store<TokenType>(token: TokenType, at key: NamiPairingFramework.Tokens) where TokenType : Swift.Decodable, TokenType : Swift.Encodable
  #if compiler(>=5.3) && $NonescapableTypes
  func retrieve<TokenType>(a type: TokenType.Type, from key: NamiPairingFramework.Tokens) -> Swift.Result<TokenType, NamiPairingFramework.TokenStoreError> where TokenType : Swift.Decodable, TokenType : Swift.Encodable
  #endif
  func delete(at key: NamiPairingFramework.Tokens)
}
final public class TokenSecureStorage : NamiPairingFramework.TokenStore {
  public init(server: Swift.String)
  final public func store<TokenType>(token: TokenType, at key: NamiPairingFramework.Tokens) where TokenType : Swift.Decodable, TokenType : Swift.Encodable
  #if compiler(>=5.3) && $NonescapableTypes
  final public func retrieve<TokenType>(a type: TokenType.Type, from key: NamiPairingFramework.Tokens) -> Swift.Result<TokenType, NamiPairingFramework.TokenStoreError> where TokenType : Swift.Decodable, TokenType : Swift.Encodable
  #endif
  final public func delete(at key: NamiPairingFramework.Tokens)
  @objc deinit
}
public enum KeychainError : Swift.Error, Swift.Equatable {
  case notFound
  case systemError
  public static func == (a: NamiPairingFramework.KeychainError, b: NamiPairingFramework.KeychainError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SecureStorage {
  public static var accessGroup: Swift.String {
    get
  }
  public static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  public static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, NamiPairingFramework.KeychainError>
  #endif
  public static func delete(at key: Swift.String, server: Swift.String)
}
extension Swift.Int32 {
  public var description: Swift.String {
    get
  }
}
public enum KeychainMigration {
  public static func migrateToAccessGroupStorage(server: Swift.String)
}
public enum ISO8601MsecDecoder {
  public static let defaultFormatter: Foundation.ISO8601DateFormatter
  public static func decodedDate(_ decoder: any Swift.Decoder) throws -> Foundation.Date
  public static func encodeDate(date: Foundation.Date, encoder: any Swift.Encoder) throws
}
extension Foundation.JSONDecoder {
  public static func ISO8601Msec() -> Foundation.JSONDecoder
}
extension Foundation.JSONEncoder {
  public static func ISO8601Msec() -> Foundation.JSONEncoder
}
public enum PacketBoatError : Swift.String, Swift.Error {
  case wrongDataFormat
  case wrongDataSize
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
final public class PacketBoat {
  public init()
  final public var doneSending: Swift.Bool {
    get
  }
  final public var doneReceiving: Swift.Bool {
    get
  }
  final public func startSending(data: Foundation.Data)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func nextBitToSend(maxSize: Swift.UInt) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func receivedData() -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func receiveNext(data: Foundation.Data) -> Swift.Result<Swift.Bool, NamiPairingFramework.PacketBoatError>
  #endif
  @objc deinit
}
public enum SeanceError : Swift.Error {
  case keyDerivationError
  case wrongState(Swift.String)
  case keyAgreementError
  case verificationError
  case unsupportedHashingAlgorithm(Swift.String)
}
public class Seance {
  public init(role: NamiPairingFramework.Seance.Role)
  public enum Role {
    case prover
    case verifier
    public static func == (a: NamiPairingFramework.Seance.Role, b: NamiPairingFramework.Seance.Role) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum State {
    case initial
    case started
    case unverified
    case established
    public static func == (a: NamiPairingFramework.Seance.State, b: NamiPairingFramework.Seance.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum HashingAlgorithm {
    case sha256
    case sha384
    case sha512
    public init(_ algo: Swift.String) throws
    public static func == (a: NamiPairingFramework.Seance.HashingAlgorithm, b: NamiPairingFramework.Seance.HashingAlgorithm) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let role: NamiPairingFramework.Seance.Role
  public var state: NamiPairingFramework.Seance.State {
    get
  }
  public static func preProcessPassword(_ password: Swift.UInt32, salt: [Swift.UInt8], iterations: Swift.UInt32 = 100000) throws -> Foundation.Data
  public static func deriveKey(_ password: Swift.String, salt: [Swift.UInt8], iterations: Swift.UInt32, hashingAlgorithm: NamiPairingFramework.Seance.HashingAlgorithm = .sha256, derivedKeyLength: Swift.Int = 32) throws -> Foundation.Data
  public static func deriveKey(_ password: [Swift.UInt8], salt: [Swift.UInt8], iterations: Swift.UInt32, hashingAlgorithm: NamiPairingFramework.Seance.HashingAlgorithm = .sha256, derivedKeyLength: Swift.Int = 32) throws -> Foundation.Data
  public func start(preProcessedPassword: Foundation.Data) throws -> Foundation.Data
  public func makeSharedKey(otherKeyData: Foundation.Data) throws -> Foundation.Data
  public func verify(otherValue: Foundation.Data) throws -> NamiPairingFramework.GhostBox
  @objc deinit
}
public struct GhostMessage {
  public let nonce: Foundation.Data
  public let ciphertext: Foundation.Data
  public let tag: Foundation.Data
}
@_hasMissingDesignatedInitializers final public class GhostBox {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func encrypt(message: Foundation.Data) -> NamiPairingFramework.GhostMessage?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func decrypt(nonce: Foundation.Data, ciphertext: Foundation.Data, tag: Foundation.Data) -> Foundation.Data?
  #endif
  @objc deinit
}
public protocol ThreadSecureStorageProtocol {
  associatedtype Thread_SecureStorageError : Swift.Error
  static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, Self.Thread_SecureStorageError>
  #endif
  static func delete(at key: Swift.String, server: Swift.String)
}
public enum MeshCoPType : Swift.Equatable, Swift.Codable {
  case channel(Swift.UInt16)
  case panID(Swift.UInt16)
  case extendedPanID(Swift.UInt64)
  case networkName(Swift.String)
  case pskc([Swift.UInt8])
  case networkKey(Foundation.Data)
  case sequenceCounter(Swift.UInt64)
  case meshLocalPrefix(Swift.UInt64)
  case securityPolicy(Swift.UInt32)
  case activeTimestamp(Swift.UInt64)
  case pendingTimestamp(Swift.UInt64)
  case delayTimer(Swift.UInt32)
  case channelMask([[Swift.UInt8]])
  public static func == (a: NamiPairingFramework.MeshCoPType, b: NamiPairingFramework.MeshCoPType) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum OperationalDatasetAcquisitionError : Swift.Error {
  case noDatasetInStoreOrLocalNetwork
  public static func == (a: NamiPairingFramework.OperationalDatasetAcquisitionError, b: NamiPairingFramework.OperationalDatasetAcquisitionError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class ThreadOperationalDatasetProvider<SecureStorage> where SecureStorage : NamiPairingFramework.ThreadSecureStorageProtocol {
  public init(secureStoreServer: Swift.String, storage: SecureStorage.Type, deviceConnectionsManager: any NamiPairingFramework.DeviceConnectionsManagerProtocol)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func newRandomDataset(networkName: Swift.String?) -> NamiPairingFramework.NamiThreadOperationalDataset
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Synchronous retrieval blocks a thread. Update to use `getDataset(for: PlaceID) -> AnyPublisher<NamiThreadOperationalDataset, Error>`")
  final public func retrieve(placeId: NamiPairingFramework.PlaceID) -> NamiPairingFramework.NamiThreadOperationalDataset?
  #endif
  final public func getDataset(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.NamiThreadOperationalDataset, any Swift.Error>
  final public func removeDataset(for placeId: NamiPairingFramework.PlaceID)
  final public func storeDataset(_ dataset: Foundation.Data, for placeId: NamiPairingFramework.PlaceID)
  final public func storeDataset(_ dataset: NamiPairingFramework.NamiThreadOperationalDataset, for placeId: NamiPairingFramework.PlaceID)
  @objc deinit
}
public typealias PanID = Foundation.Data
public struct NamiThreadOperationalDataset : Swift.Equatable, Swift.Codable {
  public init()
  public init(placeName: Swift.String)
  public init(networkName: Swift.String)
  public init(data: Foundation.Data)
  public let tlvs: [NamiPairingFramework.MeshCoPType]
  public var data: Foundation.Data {
    get
  }
  public func equalsNumericalPanID<ID>(_ panId: ID) -> Swift.Bool where ID : Swift.FixedWidthInteger
  public static func == (a: NamiPairingFramework.NamiThreadOperationalDataset, b: NamiPairingFramework.NamiThreadOperationalDataset) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiWiFiNetwork : Swift.Equatable, Swift.Hashable {
  public let ssid: Swift.String
  public let rssi: Swift.Int
  public let bssid: NamiPairingFramework.BSSID
  public let open: Swift.Bool
  public static func == (a: NamiPairingFramework.NamiWiFiNetwork, b: NamiPairingFramework.NamiWiFiNetwork) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias BSSID = Foundation.Data
public struct ScanWiFiNetworksParameters : Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID?, currentDeviceUid: NamiPairingFramework.DeviceUniversalID?, scanFinishedSessionId: Swift.Int? = nil, passwordReEntryRequested: Swift.Bool = false)
  #endif
  public var sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID?
  public var scanFinishedSessionId: Swift.Int?
  public var currentDeviceUid: NamiPairingFramework.DeviceUniversalID?
  public var passwordReEntryRequested: Swift.Bool
  public static func == (a: NamiPairingFramework.ScanWiFiNetworksParameters, b: NamiPairingFramework.ScanWiFiNetworksParameters) -> Swift.Bool
}
public struct ScannedWiFiNetworks : Swift.Equatable {
  public init(networks: [NamiPairingFramework.PublicWiFiNetwork], canRetry: Swift.Bool)
  public var networks: [NamiPairingFramework.PublicWiFiNetwork]
  public var canRetry: Swift.Bool
  public static func == (a: NamiPairingFramework.ScannedWiFiNetworks, b: NamiPairingFramework.ScannedWiFiNetworks) -> Swift.Bool
}
public struct PairingDevice : NamiPairingFramework.DeviceProtocol, Swift.Codable, Swift.Equatable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias State = NamiPairingFramework.PairingDeviceCloudState
  public typealias CloudConnection = NamiPairingFramework.PairingDeviceCloudConnectionStatus
  public typealias Model = NamiPairingFramework.PairingDeviceModel
  public var isBorderRouter: Swift.Bool
  public var id: NamiPairingFramework.DeviceID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var name: Swift.String
  public var roomId: NamiPairingFramework.RoomID
  public var bleDiscriminator: Swift.Int32?
  public var codeName: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var model: NamiPairingFramework.PairingDeviceModel
  public var cloudConnection: NamiPairingFramework.PairingDeviceCloudConnectionStatus?
  public var deviceState: NamiPairingFramework.PairingDeviceCloudState?
  public static func == (lhs: NamiPairingFramework.PairingDevice, rhs: NamiPairingFramework.PairingDevice) -> Swift.Bool
}
public struct PairingDeviceCloudConnectionStatus : NamiPairingFramework.DeviceCloudConnectionStatusProtocol, Swift.Codable, Swift.Equatable {
  public var isConnected: Swift.Bool
  public var updatedAt: Foundation.Date?
  public static func == (a: NamiPairingFramework.PairingDeviceCloudConnectionStatus, b: NamiPairingFramework.PairingDeviceCloudConnectionStatus) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingDeviceCloudState : NamiPairingFramework.DeviceCloudStateProtocol, Swift.Codable, Swift.Equatable {
  public var payload: Foundation.Data
  public var seqTime: Swift.UInt64
  public var updatedAt: Foundation.Date
  public init(payload: Foundation.Data, seqTime: Swift.UInt64, updatedAt: Foundation.Date)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.PairingDeviceCloudState, b: NamiPairingFramework.PairingDeviceCloudState) -> Swift.Bool
}
public struct PairingDeviceModel : Swift.Codable, NamiPairingFramework.DeviceModelProtocol, Swift.Equatable {
  public var codeName: Swift.String
  public var productLabel: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public static func == (a: NamiPairingFramework.PairingDeviceModel, b: NamiPairingFramework.PairingDeviceModel) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingAlertMode : NamiPairingFramework.AlertModeProtocol, Swift.Codable, Swift.Equatable {
  public let rawValue: Swift.String
  public init(_ stringValue: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.PairingAlertMode, b: NamiPairingFramework.PairingAlertMode) -> Swift.Bool
}
public struct PairingEngineConfig : NamiPairingFramework.EngineConfigProtocol, Swift.Codable, Swift.Equatable {
  public typealias EngineType = NamiPairingFramework.PairingEngineType
  public var type: NamiPairingFramework.PairingEngineType
  public var sensitivityLevel: Swift.Int
  public init(type: NamiPairingFramework.PairingEngineType, sensitivityLevel: Swift.Int)
  public static func == (a: NamiPairingFramework.PairingEngineConfig, b: NamiPairingFramework.PairingEngineConfig) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingEngineType : NamiPairingFramework.EngineTypeProtocol, Swift.Codable, Swift.Equatable {
  public let rawValue: Swift.String
  public init(_ stringValue: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.PairingEngineType, b: NamiPairingFramework.PairingEngineType) -> Swift.Bool
}
public struct PairingZoneHealth : NamiPairingFramework.ZoneHealthProtocol, Swift.Codable, Swift.Equatable {
  public let rawValue: Swift.String
  public init(_ stringValue: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.PairingZoneHealth, b: NamiPairingFramework.PairingZoneHealth) -> Swift.Bool
}
public struct PairingZoneMotionStatus : NamiPairingFramework.ZoneMotionStatusProtocol, Swift.Codable, Swift.Equatable {
  public typealias ZoneHealth = NamiPairingFramework.PairingZoneHealth
  public var detection: Swift.Bool?
  public var startedAt: Foundation.Date?
  public var health: NamiPairingFramework.PairingZoneHealth
  #if compiler(>=5.3) && $NonescapableTypes
  public init(detection: Swift.Bool? = nil, startedAt: Foundation.Date? = nil, health: NamiPairingFramework.PairingZoneHealth)
  #endif
  public static func == (a: NamiPairingFramework.PairingZoneMotionStatus, b: NamiPairingFramework.PairingZoneMotionStatus) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingRoom : NamiPairingFramework.RoomProtocol, Swift.Codable, Swift.Equatable {
  public var id: NamiPairingFramework.RoomID
  public var externalId: Swift.String
  public var urn: Swift.String
  public var name: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var iconId: NamiPairingFramework.IconID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public init(id: NamiPairingFramework.RoomID, externalId: Swift.String, urn: Swift.String, name: Swift.String, placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID, iconId: NamiPairingFramework.IconID, createdAt: Foundation.Date, updatedAt: Foundation.Date)
  public static func == (a: NamiPairingFramework.PairingRoom, b: NamiPairingFramework.PairingRoom) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingPlaceUsageLimits : NamiPairingFramework.PlaceUsageLimitsProtocol, Swift.Codable, Swift.Equatable {
  public var membership: Swift.UInt
  public init(membership: Swift.UInt)
  public static func == (a: NamiPairingFramework.PairingPlaceUsageLimits, b: NamiPairingFramework.PairingPlaceUsageLimits) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingWiredPlaceKeys : NamiPairingFramework.WiredPlaceKeysProtocol, Swift.Codable, Swift.Equatable {
  public var ciphertext: Swift.String
  public var iv: Swift.String
  public var authTag: Swift.String
  public var serverKey: Swift.String
  public init(ciphertext: Swift.String, iv: Swift.String, authTag: Swift.String, serverKey: Swift.String)
  public static func == (a: NamiPairingFramework.PairingWiredPlaceKeys, b: NamiPairingFramework.PairingWiredPlaceKeys) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingCloudPlaceKey : NamiPairingFramework.CloudPlaceKeyProtocol, Swift.Codable, Swift.Equatable {
  public var id: Swift.String
  public var key: Swift.String
  public init(id: Swift.String, key: Swift.String)
  public static func == (a: NamiPairingFramework.PairingCloudPlaceKey, b: NamiPairingFramework.PairingCloudPlaceKey) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingPlace : NamiPairingFramework.PlaceProtocol, Swift.Codable, Swift.Equatable {
  public typealias Zone = NamiPairingFramework.PairingPlaceZone
  public typealias UsageLimits = NamiPairingFramework.PairingPlaceUsageLimits
  public typealias WiredPlaceKeys = NamiPairingFramework.PairingWiredPlaceKeys
  public typealias CloudPlaceKey = NamiPairingFramework.PairingCloudPlaceKey
  public var id: NamiPairingFramework.PlaceID
  public var name: Swift.String
  public var timeZone: Swift.String?
  public var propertyTypeId: NamiPairingFramework.PropertyTypeID?
  public var propertyElevationId: NamiPairingFramework.PropertyElevationID?
  public var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID?
  public var petTypeId: NamiPairingFramework.PetTypeID?
  public var urn: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var zones: [NamiPairingFramework.PairingPlaceZone]
  public var limits: NamiPairingFramework.PairingPlaceUsageLimits
  public var placeKeys: NamiPairingFramework.PairingWiredPlaceKeys?
  public var decodedPlaceKeys: [NamiPairingFramework.PairingCloudPlaceKey]?
  public var entryDelay: NamiPairingFramework.EntryDelay?
  public var exitDelay: NamiPairingFramework.ExitDelay?
  public static func == (a: NamiPairingFramework.PairingPlace, b: NamiPairingFramework.PairingPlace) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingPlaceZone : NamiPairingFramework.ZoneProtocol, Swift.Codable, Swift.Equatable {
  public typealias Room = NamiPairingFramework.PairingRoom
  public typealias AlertMode = NamiPairingFramework.PairingAlertMode
  public typealias EngineConfig = NamiPairingFramework.PairingEngineConfig
  public typealias MotionStatus = NamiPairingFramework.PairingZoneMotionStatus
  public var id: NamiPairingFramework.PlaceZoneID
  public var externalId: Swift.String
  public var name: Swift.String
  public var urn: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var rooms: [NamiPairingFramework.PairingRoom]
  public var alertMode: NamiPairingFramework.PairingAlertMode
  public var engineConfig: NamiPairingFramework.PairingEngineConfig
  public var motionStatus: NamiPairingFramework.PairingZoneMotionStatus
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.PairingPlaceZone, b: NamiPairingFramework.PairingPlaceZone) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingUpdatedDeviceUser : NamiPairingFramework.UpdatedDeviceUserProtocol, Swift.Codable, Swift.Equatable {
  public var urn: Swift.String?
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  #if compiler(>=5.3) && $NonescapableTypes
  public init(urn: Swift.String? = nil, name: Swift.String, themeId: NamiPairingFramework.ThemeID, iconId: NamiPairingFramework.IconID)
  #endif
  public static func == (a: NamiPairingFramework.PairingUpdatedDeviceUser, b: NamiPairingFramework.PairingUpdatedDeviceUser) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingWiFiCredentialsUpdateStatus : NamiPairingFramework.WiFiCredentialsUpdateStatusProtocol, Swift.Codable, Swift.Equatable {
  public let rawValue: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public init(_ stringValue: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias RawValue = Swift.String
}
public struct PairingWiFiCredentialsHoldingDevice : NamiPairingFramework.WiFiCredentialsHoldingDeviceProtocol, Swift.Codable, Swift.Equatable {
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public init(uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String)
  public static func == (a: NamiPairingFramework.PairingWiFiCredentialsHoldingDevice, b: NamiPairingFramework.PairingWiFiCredentialsHoldingDevice) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class CodeScannerUIView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  #endif
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
  @objc deinit
}
@_Concurrency.MainActor @preconcurrency public struct CodeScannerView : SwiftUI.UIViewRepresentable {
  public typealias UIViewType = NamiPairingFramework.CodeScannerUIView
  @objc @_hasMissingDesignatedInitializers final public class Coordinator : ObjectiveC.NSObject {
    @objc final public func metadataOutput(_: AVFoundation.AVCaptureMetadataOutput, didOutput metadataObjects: [AVFoundation.AVMetadataObject], from _: AVFoundation.AVCaptureConnection)
    @objc deinit
  }
  @_Concurrency.MainActor @preconcurrency public func makeCoordinator() -> NamiPairingFramework.CodeScannerView.Coordinator
  @_Concurrency.MainActor @preconcurrency public func makeUIView(context: NamiPairingFramework.CodeScannerView.Context) -> NamiPairingFramework.CodeScannerUIView
  @_Concurrency.MainActor @preconcurrency public func updateUIView(_ uiView: NamiPairingFramework.CodeScannerUIView, context _: NamiPairingFramework.CodeScannerView.Context)
  public typealias Body = Swift.Never
}
public enum QRScanner {
  public enum ScanError : Swift.String, Swift.Identifiable {
    case unknownQR
    public var id: Swift.String {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias ID = Swift.String
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct State : NamiPairingFramework.ViewModelState {
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public var qrCode: NamiPairingFramework.NamiQRCode?
    public var outletType: NamiPairingFramework.NamiOutletType?
    public var kit: NamiPairingFramework.KitCategory?
    public var error: NamiPairingFramework.QRScanner.ScanError?
    public var setupType: NamiPairingFramework.SetupType
    public static func == (a: NamiPairingFramework.QRScanner.State, b: NamiPairingFramework.QRScanner.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case reset
    case shouldDismissItself
    case gotData(Swift.String?)
    case dismissScanError
    case pauseScanning
    case scanningUnauthorized
    public static func == (a: NamiPairingFramework.QRScanner.Event, b: NamiPairingFramework.QRScanner.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.QRScannerViewModelProtocol {
    public typealias State = NamiPairingFramework.QRScanner.State
    public typealias Event = NamiPairingFramework.QRScanner.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.QRScanner.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.QRScanner.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public var undecoratedScannerView: NamiPairingFramework.CodeScannerView {
      get
    }
    final public func send(event: NamiPairingFramework.QRScanner.ViewModel.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public struct NamiQRCode : Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ string: Swift.String)
  #endif
  public var discriminator: Swift.Int32
  public static func == (a: NamiPairingFramework.NamiQRCode, b: NamiPairingFramework.NamiQRCode) -> Swift.Bool
}
public struct BluetoothCentralState : Swift.Equatable {
  public var bluetoothState: CoreBluetooth.CBManagerState
  public var authorization: CoreBluetooth.CBManagerAuthorization
  public static func == (a: NamiPairingFramework.BluetoothCentralState, b: NamiPairingFramework.BluetoothCentralState) -> Swift.Bool
}
extension NamiPairingFramework.BluetoothCentralState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
final public class Tomonari<Container> where Container : NamiPairingFramework.PairingStepsContainer {
  public init(api: any NamiPairingFramework.PairingWebAPIProtocol, wifiStorage: any NamiPairingFramework.PairingWiFiStorageProtocol, threadDatasetProvider: any NamiPairingFramework.PairingThreadOperationalDatasetProviderProtocol)
  public typealias DevicePairingStatePublisher = Combine.PassthroughSubject<NamiPairingFramework.Tomonari<Container>.DevicePairingState, any Swift.Error>
  public struct PairingParameters : Swift.Equatable {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(qrCode: NamiPairingFramework.NamiQRCode? = nil, updateWiFiCredentials: Swift.Bool = false, bssid: Foundation.Data? = nil, countryCode: Swift.String? = nil, deviceName: Swift.String? = nil)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    @available(*, deprecated, message: "`updateWiFiCredentialsSessionId` is deprecated. We are dropping the 'update session' logic.\nUpdates are now volatile: once the user exits the flow, the state resets and they can retry updating all devices.\nTomonari (library) and backend no longer persist which devices were updated. Use `updateWiFiCredentials` instead.")
    public init(qrCode: NamiPairingFramework.NamiQRCode? = nil, updateWiFiCredentialsSessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID? = nil, bssid: Foundation.Data? = nil, countryCode: Swift.String? = nil)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    @available(*, deprecated, message: "This initializer is deprecated. Use `updateWiFiCredentials: Bool`, `bssid: Data?`")
    public init(qrCode: NamiPairingFramework.NamiQRCode? = nil, updateWiFiCredentialsSessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID? = nil, bssid: [Swift.UInt8], countryCode: Swift.String? = nil)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    @available(*, deprecated, message: "This initializer is deprecated. Use `updateWiFiCredentials: Bool`, `bssid: Data?`")
    public init(qrCode: NamiPairingFramework.NamiQRCode? = nil, updateWiFiCredentialsSessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID? = nil, bssid: Swift.String, countryCode: Swift.String? = nil)
    #endif
    public static var none: NamiPairingFramework.Tomonari<Container>.PairingParameters {
      get
    }
    public var qrCode: NamiPairingFramework.NamiQRCode? {
      get
    }
    public var updateWiFiCredentials: Swift.Bool {
      get
    }
    public var bssid: Foundation.Data? {
      get
    }
    public var countryCode: Swift.String? {
      get
    }
    public var deviceName: Swift.String? {
      get
    }
    public static func == (a: NamiPairingFramework.Tomonari<Container>.PairingParameters, b: NamiPairingFramework.Tomonari<Container>.PairingParameters) -> Swift.Bool
  }
  public enum DevicePairingState {
    case deviceCommisionedAtCloud(NamiPairingFramework.PairingDevice, in: NamiPairingFramework.PlaceID)
    case deviceOperable(NamiPairingFramework.DeviceID, NamiPairingFramework.NamiDeviceType?, ssid: Swift.String?, bssid: [Swift.UInt8]?, positionAdjustmentNeeded: Swift.Bool?)
    case deviceDecommissioned(NamiPairingFramework.DeviceID)
    case pairingCancelled(NamiPairingFramework.Pairing.PairingCancellationdReason)
  }
  final public let devicePairingState: NamiPairingFramework.Tomonari<Container>.DevicePairingStatePublisher
  final public func startPairing(placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID, roomId: NamiPairingFramework.RoomID, deviceType: NamiPairingFramework.NamiDeviceType = .unknown, pairingParameters: NamiPairingFramework.Tomonari<Container>.PairingParameters = .none, pairingSteps: Container) -> some SwiftUICore.View
  
  @objc deinit
}
@available(*, deprecated, message: "`PositioningResult` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This view initialization closure is to be dropped in the future versions of the SDK.")
public enum PositioningResult {
  case finished
  case cancelled
  public static func == (a: NamiPairingFramework.PositioningResult, b: NamiPairingFramework.PositioningResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NamiPairingFramework.NamiDeviceType {
  public func qrCodeImageName(outletType: NamiPairingFramework.NamiOutletType) -> Swift.String
}
extension SwiftUICore.EnvironmentValues {
  public var hideBackButton: Swift.Bool {
    get
    set
  }
}
public enum PairingMachineState : Swift.Equatable, Swift.CustomDebugStringConvertible, Swift.Identifiable {
  case initial
  case gotAdvertisement(NamiPairingFramework.PublicPairingAdvertisement)
  case sentProverPublicKey
  case sentProverSharedKey
  case establishedSession
  case sentDeviceCertificateRequest
  case gotDeviceCertificateResponse(Swift.String)
  case sentCloudChallenge
  case gotCloudChallengeResponse(Foundation.Data)
  case sentCloudPayload
  case gotCloudChallengeOK
  case sentScanWiFiNetworks
  case gotWiFiNetworks([NamiPairingFramework.PublicWiFiNetwork])
  case sentWiFiCredentials
  case gotWiFiIPAddress(Swift.String)
  case sentScanThreadNetworks
  case gotThreadNetworks([NamiPairingFramework.ThreadScanResult])
  case sentJoinThreadNetwork
  case threadJoinFinished(Foundation.Data)
  case sentHandshakeAck
  public var id: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.PairingMachineState, b: NamiPairingFramework.PairingMachineState) -> Swift.Bool
  public typealias ID = Swift.String
}
public enum PairingMachineError : Swift.Error, Swift.Equatable {
  case unexpectedState
  case unexpectedMessage
  case seanceError(any Swift.Error)
  case pairingError(NamiPairingFramework.PublicPairingError)
  case serializationError(any Swift.Error)
  case deserializationError(any Swift.Error)
  case encryptionError
  case notSupportDeviceType(NamiPairingFramework.NamiDeviceType)
  case connectionTimeOutError
  case bluetoothDisconnectedError(NamiPairingFramework.NamiDeviceType, Swift.Bool)
  public static func == (lhs: NamiPairingFramework.PairingMachineError, rhs: NamiPairingFramework.PairingMachineError) -> Swift.Bool
}
public enum PairingErrorScreen {
  public struct State : NamiPairingFramework.ViewModelState {
    public var error: NamiPairingFramework.Pairing.Error
    public var actions: [NamiPairingFramework.Pairing.ActionOnError]
    public var chosenAction: NamiPairingFramework.Pairing.ActionOnError?
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public var setupType: NamiPairingFramework.SetupType
    public static func == (a: NamiPairingFramework.PairingErrorScreen.State, b: NamiPairingFramework.PairingErrorScreen.State) -> Swift.Bool
  }
  public enum Event {
    case didChooseAction(NamiPairingFramework.Pairing.ActionOnError)
    case reconfigure(NamiPairingFramework.Pairing.Error, [NamiPairingFramework.Pairing.ActionOnError])
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.PairingErrorScreen.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PairingErrorScreen.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PairingErrorScreen.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.PairingErrorScreen.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum BluetoothDeviceFound {
  public struct State : NamiPairingFramework.ViewModelState {
    public var placeId: NamiPairingFramework.PlaceID
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public var deviceModel: NamiPairingFramework.NamiDeviceModel?
    public var deviceName: Swift.String
    public var deviceNames: [Swift.String]
    public var deviceNameConfirmed: Swift.Bool
    public var showDuplicateError: Swift.Bool {
      get
    }
    public var setupType: NamiPairingFramework.SetupType
    public static func == (a: NamiPairingFramework.BluetoothDeviceFound.State, b: NamiPairingFramework.BluetoothDeviceFound.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case deviceNameConfirmed
    case gotDeviceNames([Swift.String])
    public static func == (a: NamiPairingFramework.BluetoothDeviceFound.Event, b: NamiPairingFramework.BluetoothDeviceFound.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.BluetoothDeviceFound.State
    public typealias Event = NamiPairingFramework.BluetoothDeviceFound.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.BluetoothDeviceFound.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.BluetoothDeviceFound.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.BluetoothDeviceFound.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum ListWiFiNetworks {
  public struct State {
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public var networks: [NamiPairingFramework.NamiWiFiNetwork]?
    public var selectedNetwork: NamiPairingFramework.NamiWiFiNetwork?
    public var shouldShowBSSIDWarning: Swift.Bool
    public var shouldAskAboutSavedPassword: Swift.Bool
    public var deviceSupportsBSSID: Swift.Bool {
      get
    }
    public var shouldShowProgressView: Swift.Bool {
      get
    }
    public var shouldShowNoNetworksHint: Swift.Bool {
      get
    }
    public var couldShowAddOtherNetwork: Swift.Bool {
      get
    }
    public var setupType: NamiPairingFramework.SetupType
    public static func == (a: NamiPairingFramework.ListWiFiNetworks.State, b: NamiPairingFramework.ListWiFiNetworks.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case empty
    case dismissItself
    case tappedConfirmSelection
    case tappedRefreshNetwork
    case tappedOtherNetwork
    case selectNetwork(NamiPairingFramework.NamiWiFiNetwork)
    case selectNetworkAndConfirm(NamiPairingFramework.NamiWiFiNetwork)
    case didTapUsePassword
    case didTapForgetPassword
    case didSearchForSavedPassword(Swift.String?)
    case confirmingSelection
    case shouldAskAboutSavedPassword(Swift.Bool)
    case gotError(NamiPairingFramework.Pairing.Error)
    public static func == (a: NamiPairingFramework.ListWiFiNetworks.Event, b: NamiPairingFramework.ListWiFiNetworks.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.StoredPasswordRetrievingViewModel {
    public typealias State = NamiPairingFramework.ListWiFiNetworks.State
    public typealias Event = NamiPairingFramework.ListWiFiNetworks.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.ListWiFiNetworks.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.ListWiFiNetworks.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.ListWiFiNetworks.ViewModel.Event)
    final public func usePassword()
    final public func forgetPassword()
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum PowerOnAndScanning {
  public struct State : NamiPairingFramework.ViewModelState {
    public var showsProgressIndicator: Swift.Bool
    public let deviceType: NamiPairingFramework.NamiDeviceType
    public var outletType: NamiPairingFramework.NamiOutletType?
    public var centralState: NamiPairingFramework.BluetoothCentralState
    public var setupType: NamiPairingFramework.SetupType
    public static func == (a: NamiPairingFramework.PowerOnAndScanning.State, b: NamiPairingFramework.PowerOnAndScanning.State) -> Swift.Bool
  }
  public enum Event {
    case stopShowingProgress
    case centralDidUpdate(NamiPairingFramework.BluetoothCentralState)
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.PowerOnAndScanning.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PowerOnAndScanning.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PowerOnAndScanning.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.PowerOnAndScanning.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum OtherWiFiNetwork {
  public struct State {
    public var networkName: Swift.String
    public var password: Swift.String
    public var shouldAskAboutSavedPassword: Swift.Bool
    public var setupType: NamiPairingFramework.SetupType
    public static func == (a: NamiPairingFramework.OtherWiFiNetwork.State, b: NamiPairingFramework.OtherWiFiNetwork.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case empty
    case didConfirmName
    case lookForSavedPassword
    case shouldAskAboutSavedPassword(Swift.Bool)
    case didTapUsePassword
    case didTapForgetPassword
    case didSearchForSavedPassword(Swift.String?)
    public static func == (a: NamiPairingFramework.OtherWiFiNetwork.Event, b: NamiPairingFramework.OtherWiFiNetwork.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.StoredPasswordRetrievingViewModel {
    public typealias State = NamiPairingFramework.OtherWiFiNetwork.State
    public typealias Event = NamiPairingFramework.OtherWiFiNetwork.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.OtherWiFiNetwork.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.OtherWiFiNetwork.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.OtherWiFiNetwork.ViewModel.Event)
    final public func usePassword()
    final public func forgetPassword()
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum BluetoothUsageHint {
  public struct State : NamiPairingFramework.ViewModelState {
    public var nextTapped: Swift.Bool
    public var setupType: NamiPairingFramework.SetupType
    public static func == (a: NamiPairingFramework.BluetoothUsageHint.State, b: NamiPairingFramework.BluetoothUsageHint.State) -> Swift.Bool
  }
  public enum Event {
    case tapNext
    public static func == (a: NamiPairingFramework.BluetoothUsageHint.Event, b: NamiPairingFramework.BluetoothUsageHint.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.BluetoothUsageHint.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.BluetoothUsageHint.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.BluetoothUsageHint.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.BluetoothUsageHint.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum EnterWiFiPassword {
  public struct State : NamiPairingFramework.ViewModelState {
    public var deviceType: NamiPairingFramework.NamiDeviceType
    public var password: Swift.String
    public var networkName: Swift.String {
      get
    }
    public var setupType: NamiPairingFramework.SetupType
    public static func == (a: NamiPairingFramework.EnterWiFiPassword.State, b: NamiPairingFramework.EnterWiFiPassword.State) -> Swift.Bool
  }
  public enum Event {
    case confirmPassword
    case goBack
    public static func == (a: NamiPairingFramework.EnterWiFiPassword.Event, b: NamiPairingFramework.EnterWiFiPassword.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.EnterWiFiPassword.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.EnterWiFiPassword.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.EnterWiFiPassword.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.EnterWiFiPassword.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
@available(*, deprecated, message: "The `HowToPosition` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
public enum HowToPosition {
  public struct State : Swift.Equatable {
    public static func == (a: NamiPairingFramework.HowToPosition.State, b: NamiPairingFramework.HowToPosition.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case wantToDismiss
    case startPositioningTapped
    public static func == (a: NamiPairingFramework.HowToPosition.Event, b: NamiPairingFramework.HowToPosition.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.HowToPosition.State
    public typealias Event = NamiPairingFramework.HowToPosition.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.HowToPosition.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      @available(*, deprecated, message: "The `HowToPosition` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      @available(*, deprecated, message: "The `HowToPosition` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.HowToPosition.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      @available(*, deprecated, message: "The `HowToPosition` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      set
    }
    final public func send(_ event: NamiPairingFramework.HowToPosition.ViewModel.Event)
    @available(*, deprecated, message: "The `HowToPosition` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
@available(*, deprecated, message: "The `InitialScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
public enum InitialScreen {
  public struct State : Swift.Equatable {
    public static func == (a: NamiPairingFramework.InitialScreen.State, b: NamiPairingFramework.InitialScreen.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case howToPositionTapped
    public static func == (a: NamiPairingFramework.InitialScreen.Event, b: NamiPairingFramework.InitialScreen.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.InitialScreen.State
    public typealias Event = NamiPairingFramework.InitialScreen.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.InitialScreen.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      @available(*, deprecated, message: "The `InitialScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      @available(*, deprecated, message: "The `InitialScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.InitialScreen.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      @available(*, deprecated, message: "The `InitialScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      set
    }
    final public func send(_ event: NamiPairingFramework.InitialScreen.Event)
    @available(*, deprecated, message: "The `InitialScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
@available(*, deprecated, message: "The `PositioningGuidance` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
public enum PositioningGuidance {
  public enum PositioningQuality : Swift.Equatable {
    case unknown
    public static func == (a: NamiPairingFramework.PositioningGuidance.PositioningQuality, b: NamiPairingFramework.PositioningGuidance.PositioningQuality) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PositioningState : Swift.Equatable {
    case unknown
    public static func == (a: NamiPairingFramework.PositioningGuidance.PositioningState, b: NamiPairingFramework.PositioningGuidance.PositioningState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct State : Swift.Equatable {
    public var wantCancel: Swift.Bool
    public var canNotFinish: Swift.Bool
    public var canNotCancel: Swift.Bool {
      get
    }
    public var positioningQuality: NamiPairingFramework.PositioningGuidance.PositioningQuality
    public var positioningState: NamiPairingFramework.PositioningGuidance.PositioningState
    public static func == (a: NamiPairingFramework.PositioningGuidance.State, b: NamiPairingFramework.PositioningGuidance.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case cancelViewDismissed
    case wantToDismiss
    case wantFinishTapped
    case wantCancelTapped
    case confirmPositioningCancel
    public static func == (a: NamiPairingFramework.PositioningGuidance.Event, b: NamiPairingFramework.PositioningGuidance.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.PositioningGuidance.State
    public typealias Event = NamiPairingFramework.PositioningGuidance.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PositioningGuidance.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      @available(*, deprecated, message: "The `PositioningGuidance` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      @available(*, deprecated, message: "The `PositioningGuidance` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PositioningGuidance.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      @available(*, deprecated, message: "The `PositioningGuidance` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      set
    }
    final public func send(_ event: NamiPairingFramework.PositioningGuidance.Event)
    @available(*, deprecated, message: "The `PositioningGuidance` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
@available(*, deprecated, message: "The `PositioningComplete` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
public enum PositioningComplete {
  public struct State : Swift.Equatable {
    public var deviceName: Swift.String
    public static func == (a: NamiPairingFramework.PositioningComplete.State, b: NamiPairingFramework.PositioningComplete.State) -> Swift.Bool
  }
  public enum Event {
    case confirmPositioningComplete
    public static func == (a: NamiPairingFramework.PositioningComplete.Event, b: NamiPairingFramework.PositioningComplete.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.PositioningComplete.State
    public typealias Event = NamiPairingFramework.PositioningComplete.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PositioningComplete.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      @available(*, deprecated, message: "The `PositioningComplete` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      @available(*, deprecated, message: "The `PositioningComplete` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PositioningComplete.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      @available(*, deprecated, message: "The `PositioningComplete` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      set
    }
    final public func send(_ event: NamiPairingFramework.PositioningComplete.Event)
    @available(*, deprecated, message: "The `PositioningComplete` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
@available(*, deprecated, message: "The `ErrorScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
public enum ErrorScreen {
  public struct State : Swift.Equatable {
    public static func == (a: NamiPairingFramework.ErrorScreen.State, b: NamiPairingFramework.ErrorScreen.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case cancelPositioning
    case retryPositioning
    public static func == (a: NamiPairingFramework.ErrorScreen.Event, b: NamiPairingFramework.ErrorScreen.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.ErrorScreen.State
    public typealias Event = NamiPairingFramework.ErrorScreen.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.ErrorScreen.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      @available(*, deprecated, message: "The `ErrorScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      @available(*, deprecated, message: "The `ErrorScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.ErrorScreen.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      @available(*, deprecated, message: "The `ErrorScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
      set
    }
    final public func send(_ event: NamiPairingFramework.ErrorScreen.Event)
    @available(*, deprecated, message: "The `ErrorScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum Pairing {
  public struct CloudPayload : NamiPairingFramework.WiredPlaceKeysProtocol {
    public var ciphertext: Swift.String
    public var iv: Swift.String
    public var authTag: Swift.String
    public var serverKey: Swift.String
    public static func == (a: NamiPairingFramework.Pairing.CloudPayload, b: NamiPairingFramework.Pairing.CloudPayload) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct DeviceSetupParameters : Swift.Equatable {
    public static func == (a: NamiPairingFramework.Pairing.DeviceSetupParameters, b: NamiPairingFramework.Pairing.DeviceSetupParameters) -> Swift.Bool
  }
  public enum ConnectTo : Swift.Equatable {
    case thread
    case wifi
    public static func == (a: NamiPairingFramework.Pairing.ConnectTo, b: NamiPairingFramework.Pairing.ConnectTo) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error, Swift.Identifiable, Swift.Equatable {
    case underlying(any Swift.Error)
    public var id: Swift.String {
      get
    }
    public static func == (lhs: NamiPairingFramework.Pairing.Error, rhs: NamiPairingFramework.Pairing.Error) -> Swift.Bool
    public typealias ID = Swift.String
  }
  public enum ThreadError : Swift.Error, Swift.Equatable {
    case threadOperationalDatasetMissing
    case threadNetworkNotFound(zoneName: Swift.String, deviceType: NamiPairingFramework.NamiDeviceType)
    case wifiIsDisconnected
    case noBorderRouter
    case allBorderRoutersOffline
    public static func == (a: NamiPairingFramework.Pairing.ThreadError, b: NamiPairingFramework.Pairing.ThreadError) -> Swift.Bool
  }
  public enum ActionOnError : Swift.Equatable {
    case restart
    case tryAgain
    case ignore
    case exit
    public static func == (a: NamiPairingFramework.Pairing.ActionOnError, b: NamiPairingFramework.Pairing.ActionOnError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PairingCancellationdReason {
    case backButtonCancelled
    case exitPairing
    case restartPairing
    case unknown
    public static func == (a: NamiPairingFramework.Pairing.PairingCancellationdReason, b: NamiPairingFramework.Pairing.PairingCancellationdReason) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Routes : Swift.Equatable {
    case qrCodeScanner(NamiPairingFramework.NamiDeviceType, NamiPairingFramework.NamiOutletType?, NamiPairingFramework.NamiQRCode?)
    case cameraEnableInSettings(NamiPairingFramework.NamiDeviceType)
    case powerOnAndScanning(NamiPairingFramework.NamiDeviceType, NamiPairingFramework.NamiOutletType?)
    case deviceFound(placeId: NamiPairingFramework.PlaceID, deviceType: NamiPairingFramework.NamiDeviceType, deviceModel: NamiPairingFramework.NamiDeviceModel, updatingWiFiCredentials: Swift.Bool, deviceName: Swift.String?)
    case listWiFiNetworks(zoneId: NamiPairingFramework.PlaceZoneID, deviceType: NamiPairingFramework.NamiDeviceType, wifiNetworks: [NamiPairingFramework.NamiWiFiNetwork]?, bssidLookupComplete: Swift.Bool)
    case finishingSetup(NamiPairingFramework.NamiDeviceType)
    public static func == (a: NamiPairingFramework.Pairing.Routes, b: NamiPairingFramework.Pairing.Routes) -> Swift.Bool
  }
  public struct State : Swift.Equatable {
    public var placeId: NamiPairingFramework.PlaceID
    public var zoneId: NamiPairingFramework.PlaceZoneID
    public var roomId: NamiPairingFramework.RoomID
    public var updateWiFiCredentials: Swift.Bool
    public var deviceName: Swift.String
    public var deviceType: NamiPairingFramework.NamiDeviceType
    #if compiler(>=5.3) && $NonescapableTypes
    public var zoneName: Swift.String? {
      get
    }
    #endif
    public static func == (a: NamiPairingFramework.Pairing.State, b: NamiPairingFramework.Pairing.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case empty
    case centralDidUpdate(NamiPairingFramework.BluetoothCentralState)
    case pairingMachineDidUpdate(NamiPairingFramework.PairingMachineState)
    case startScanning
    case didStartScanning
    case didResetPairingState
    case stopPresenting
    case gotQRCode(NamiPairingFramework.NamiQRCode)
    case bluetoothHintAcknowledged
    case didInitBluetooth
    case identifiedModelByProductId(NamiPairingFramework.NamiDeviceModel)
    case setRoute(NamiPairingFramework.Pairing.Routes)
    case shouldContinuePairing
    case didContinuePairing
    case setDeviceName(Swift.String)
    case renameDevice(Swift.String)
    case gotDeviceCertificate(Swift.String)
    case gotPairingChallenge(challenge: Swift.String, model: NamiPairingFramework.NamiDeviceModel)
    case gotDeviceChallengeResponse(Foundation.Data)
    case gotPairDeviceResponseFromCloud(NamiPairingFramework.Pairing.CloudPayload, NamiPairingFramework.PairingDevice)
    case shouldStartScanningWiFi
    case retryScanningWiFi
    case didStartScanningWiFi
    case gotWiFiCredentials(NamiPairingFramework.NamiWiFiNetwork, Swift.String?)
    case didFoundSavedBSSID(Foundation.Data?)
    case bssidNotFound
    case otherNetwork
    case enterPassword(NamiPairingFramework.NamiWiFiNetwork)
    case didSendWiFiCredentials
    case shouldStartScanForThreadNetwork
    case didStartScanForThreadNetwork
    case shouldSendThreadOperationalDataset(Foundation.Data)
    case shouldStartCheckThreadCommissioningConditions
    case didStartCheckThreadCommissioningConditions
    case didSentThreadOperationalDataset
    case shouldDismissItself
    case routeBasedDismissal
    case dismissalApproved(NamiPairingFramework.DeviceID?)
    case dismissalWithDeleteApproved(NamiPairingFramework.DeviceID)
    case dismissStackablePresented
    case dismissFullscreenPresented
    case shouldPairAnother
    case gotAPIError(NamiPairingFramework.Pairing.Error)
    case gotPairingMachineError(NamiPairingFramework.PairingMachineError)
    case gotErrorAction(NamiPairingFramework.Pairing.Error, NamiPairingFramework.Pairing.ActionOnError)
    case askTryRescanThreadNetworks
    case notSupportedDeviceTypeError(NamiPairingFramework.NamiDeviceType)
    case pairingCancelled(NamiPairingFramework.Pairing.PairingCancellationdReason)
    case gotPlace(NamiPairingFramework.PairingPlace)
    case gotZones([NamiPairingFramework.PairingPlaceZone])
    case refreshPairingChallange
    case gotTimeZones([NamiPairingFramework.NamiTimeZone])
    case startTimerForConnectionTimeOut
    case stopTimerForConnectionTimeOut
    case connectionTimeOutError
    case bluetoothDisconnected(Swift.Bool)
    case doneRenamingDevice
    case doneDeletingDevice
    case exitPairing
    case updatedWifiReachability(Network.NWPath)
    case noBorderRouterError
    case allBorderRoutersOfflineError
    public static func == (a: NamiPairingFramework.Pairing.Event, b: NamiPairingFramework.Pairing.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel<Container> where Container : NamiPairingFramework.PairingStepsContainer {
    public typealias State = NamiPairingFramework.Pairing.State
    public typealias Event = NamiPairingFramework.Pairing.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.Pairing.ViewModel<Container>.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.Pairing.ViewModel<Container>.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.Pairing.ViewModel<Container>.Event)
    @objc deinit
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  }
}
public protocol PairingStepViewModelProtocol : Combine.ObservableObject {
  associatedtype State : Swift.Equatable
}
public protocol PairingStepEventSendableViewModelProtocol : NamiPairingFramework.PairingStepViewModelProtocol {
  associatedtype Event : Swift.Equatable
  func send(event: Self.Event)
}
public enum SetupType : Swift.Equatable {
  case commissioning
  case kitSetup
  case updateWiFiCreds
  public static func == (a: NamiPairingFramework.SetupType, b: NamiPairingFramework.SetupType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ViewModelState : Swift.Equatable {
  var setupType: NamiPairingFramework.SetupType { get }
}
public protocol StoredPasswordRetrievingViewModel {
  func usePassword()
  func forgetPassword()
}
public protocol QRScannerViewModelProtocol : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {
  var undecoratedScannerView: NamiPairingFramework.CodeScannerView { get }
}
public protocol PairingStepsContainer {
  associatedtype ViewForPowerOnAndScanning : SwiftUICore.View
  associatedtype ViewForEnableCameraInSettings : SwiftUICore.View
  associatedtype ViewForBluetoothDeviceFound : SwiftUICore.View
  associatedtype ViewForQRCodeScanner : SwiftUICore.View
  associatedtype ViewForListWiFiNetworks : SwiftUICore.View
  associatedtype ViewForOtherWiFiNetwork : SwiftUICore.View
  associatedtype ViewForEnterWiFiPassword : SwiftUICore.View
  associatedtype ViewForFinishingSetup : SwiftUICore.View
  associatedtype ViewForPairingError : SwiftUICore.View
  associatedtype BackButtonView : SwiftUICore.View
  var powerOnAndScanning: (NamiPairingFramework.PowerOnAndScanning.ViewModel) -> Self.ViewForPowerOnAndScanning { get }
  var enableCameraInSettings: (_ deviceType: Swift.String) -> Self.ViewForEnableCameraInSettings { get }
  var bluetoothDeviceFound: (NamiPairingFramework.BluetoothDeviceFound.ViewModel) -> Self.ViewForBluetoothDeviceFound { get }
  var qrCodeScanner: (NamiPairingFramework.QRScanner.ViewModel) -> Self.ViewForQRCodeScanner { get }
  var listWiFiNetworks: (NamiPairingFramework.ListWiFiNetworks.ViewModel) -> Self.ViewForListWiFiNetworks { get }
  var otherWiFiNetwork: (NamiPairingFramework.OtherWiFiNetwork.ViewModel) -> Self.ViewForOtherWiFiNetwork { get }
  var enterWiFiPassword: (NamiPairingFramework.EnterWiFiPassword.ViewModel) -> Self.ViewForEnterWiFiPassword { get }
  var finishingSetup: (_ title: Swift.String) -> Self.ViewForFinishingSetup { get }
  var pairingError: (NamiPairingFramework.PairingErrorScreen.ViewModel) -> Self.ViewForPairingError { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var backButton: () -> Self.BackButtonView? { get }
  #endif
  @available(*, deprecated, message: "The `ViewForPositioningErrorScreen` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This associatedtype is to be dropped in the future versions of the SDK.")
  associatedtype ViewForPositioningErrorScreen : SwiftUICore.View
  @available(*, deprecated, message: "The `ViewForHowToPosition` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This associatedtype is to be dropped in the future versions of the SDK.")
  associatedtype ViewForHowToPosition : SwiftUICore.View
  @available(*, deprecated, message: "The `ViewForInitialPositioningScreen` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This associatedtype is to be dropped in the future versions of the SDK.")
  associatedtype ViewForInitialPositioningScreen : SwiftUICore.View
  @available(*, deprecated, message: "The `ViewForPositioningGuidance` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This associatedtype is to be dropped in the future versions of the SDK.")
  associatedtype ViewForPositioningGuidance : SwiftUICore.View
  @available(*, deprecated, message: "The `ViewForPositioningComplete` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This associatedtype is to be dropped in the future versions of the SDK.")
  associatedtype ViewForPositioningComplete : SwiftUICore.View
  @available(*, deprecated, message: "The `howToPosition` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This view initialization closure is to be dropped in the future versions of the SDK.")
  var howToPosition: (NamiPairingFramework.HowToPosition.ViewModel) -> Self.ViewForHowToPosition { get }
  @available(*, deprecated, message: "The `initialPositioningScreen` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This view initialization closure is to be dropped in the future versions of the SDK.")
  var initialPositioningScreen: (NamiPairingFramework.InitialScreen.ViewModel) -> Self.ViewForInitialPositioningScreen { get }
  @available(*, deprecated, message: "The `positioningGuidance` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This view initialization closure is to be dropped in the future versions of the SDK.")
  var positioningGuidance: (NamiPairingFramework.PositioningGuidance.ViewModel) -> Self.ViewForPositioningGuidance { get }
  @available(*, deprecated, message: "The `positioningComplete` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This view initialization closure is to be dropped in the future versions of the SDK.")
  var positioningComplete: (NamiPairingFramework.PositioningComplete.ViewModel) -> Self.ViewForPositioningComplete { get }
  @available(*, deprecated, message: "The `positionError` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This view initialization closure is to be dropped in the future versions of the SDK.")
  var positionError: (NamiPairingFramework.ErrorScreen.ViewModel) -> Self.ViewForPositioningErrorScreen { get }
}
extension NamiPairingFramework.PairingStepsContainer {
  #if compiler(>=5.3) && $NonescapableTypes
  public var backButton: () -> NamiPairingFramework.NoView? {
    get
  }
  #endif
}
@_Concurrency.MainActor @preconcurrency public struct NoView : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework6NoViewV4bodyQrvp", 0) __
}
public protocol PairingThreadOperationalDatasetProviderProtocol {
  associatedtype Pairing_NamiThreadOperationalDataset : NamiPairingFramework.PairingNamiThreadOperationalDatasetProtocol
  #if compiler(>=5.3) && $NonescapableTypes
  func newRandomDataset(networkName: Swift.String?) -> Self.Pairing_NamiThreadOperationalDataset
  #endif
  func getDataset(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.Pairing_NamiThreadOperationalDataset, any Swift.Error>
  func removeDataset(for placeId: NamiPairingFramework.PlaceID)
  func storeDataset(_ dataset: Foundation.Data, for placeId: NamiPairingFramework.PlaceID)
  func storeDataset(_ dataset: Self.Pairing_NamiThreadOperationalDataset, for placeId: NamiPairingFramework.PlaceID)
}
public protocol PairingNamiThreadOperationalDatasetProtocol : Swift.Decodable, Swift.Encodable {
  var data: Foundation.Data { get }
  func equalsNumericalPanID<ID>(_ panId: ID) -> Swift.Bool where ID : Swift.FixedWidthInteger
}
public protocol StateWithRoute : Swift.Equatable {
  associatedtype Route : Swift.Equatable
  #if compiler(>=5.3) && $NonescapableTypes
  var route: Self.Route? { get set }
  #endif
}
public protocol WiDarPositioningViewModelProtocol : Combine.ObservableObject {
  associatedtype State : Swift.Equatable
}
public protocol WiDarPositioningEventSendableViewModelProtocol : NamiPairingFramework.WiDarPositioningViewModelProtocol {
  associatedtype Event : Swift.Equatable
  func send(_ event: Self.Event)
}
public protocol WiDarPositioningRoutBindableViewModelProtocol : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol where Self.State : NamiPairingFramework.StateWithRoute {
  #if compiler(>=5.3) && $NonescapableTypes
  func onRouteChange(_ event: Self.Event) -> SwiftUICore.Binding<Self.State.Route?>
  #endif
}
extension NamiPairingFramework.WiDarPositioningRoutBindableViewModelProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public func binding(route: Self.State.Route?, event: Self.Event) -> SwiftUICore.Binding<Self.State.Route?>
  #endif
}
public protocol PairingNetworkError : Swift.Error {
  var localizedDescription: Swift.String { get }
}
public protocol PairingWiFiStorageProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  func save(password: Swift.String?, for networkSSID: Swift.String)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func password(for networkSSID: Swift.String) -> Swift.String?
  #endif
  func removeAll()
}
public protocol PairingWebAPIProtocol {
  associatedtype Pairing_DevicesQueryProtocol : NamiPairingFramework.DevicesQueryProtocol
  associatedtype Pairing_DeviceResponse : NamiPairingFramework.DeviceProtocol
  associatedtype Pairing_DevicesResponse : NamiPairingFramework.DevicesResponseProtocol
  associatedtype Pairing_PairDeviceResponse : NamiPairingFramework.PairDeviceResponseProtocol
  associatedtype Pairing_Place : NamiPairingFramework.PlaceProtocol
  associatedtype Pairing_PlaceZone : NamiPairingFramework.ZoneProtocol
  associatedtype Pairing_PairingChallengeResponse : NamiPairingFramework.PairingChallengeResponseProtocol
  associatedtype Pairing_WiFiCredentialsUpdateSession : NamiPairingFramework.WiFiCredentialsUpdateSessionProtocol
  func placeDetails(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.Pairing_Place, any Swift.Error>
  func listDevices(query: any NamiPairingFramework.DevicesQueryProtocol) -> Combine.AnyPublisher<Self.Pairing_DevicesResponse, any Swift.Error>
  func listPlaceZones(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Self.Pairing_PlaceZone], any Swift.Error>
  func requestPairingChallenge(roomId: NamiPairingFramework.RoomID, deviceCertificate: Swift.String) -> Combine.AnyPublisher<Self.Pairing_PairingChallengeResponse, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  func pairDevice(roomId: NamiPairingFramework.RoomID, deviceName: Swift.String, cloudChallenge: Swift.String, deviceResponse: Swift.String, deviceCertificate: Swift.String, intent: Swift.String?) -> Combine.AnyPublisher<Self.Pairing_PairDeviceResponse, any Swift.Error>
  #endif
  func renameDevice(id: NamiPairingFramework.DeviceID, name: Swift.String) -> Combine.AnyPublisher<Self.Pairing_DeviceResponse, any Swift.Error>
  func deleteDevice(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func getWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<Self.Pairing_WiFiCredentialsUpdateSession, any Swift.Error>
  func deleteDeviceFromSession(uid: NamiPairingFramework.DeviceUniversalID, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<Self.Pairing_WiFiCredentialsUpdateSession, any Swift.Error>
}
public typealias PortableTypedCache = NamiPairingFramework.TypedCache
final public class TypedCache {
  public init()
  final public func retrieve<Element>(_ type: Element.Type, toInit: (inout Swift.Set<Combine.AnyCancellable>) -> Element) -> Element where Element : AnyObject
  final public func replace<Element>(_ type: Element.Type, toInit: (inout Swift.Set<Combine.AnyCancellable>) -> Element) -> Element where Element : AnyObject
  final public func delete<Element>(_ type: Element.Type) where Element : AnyObject
  @objc deinit
}
public class TemplatesVariablesBridge : Swift.AnyObject {
  public init(initial: [Swift.String : Swift.AnyHashable], onUpsert: @escaping (_ name: Swift.String, _ newValue: Swift.AnyHashable) -> Swift.Void)
  public func setNewValueInTemplate(_ name: Swift.String, _ newValue: Swift.AnyHashable)
  public func setNewVariablesDictionaryInTemplate(_ newValues: [Swift.String : Swift.AnyHashable])
  public func setArrayVariable(_ name: Swift.String, ints: [Swift.Int64])
  #if compiler(>=5.3) && $NonescapableTypes
  public func getValue<T>(name: Swift.String) -> T?
  #endif
  @objc deinit
}




public struct PresentedScreen : Swift.Sendable {
  public enum TrailingItem : Swift.Sendable {
    case support(Foundation.URL)
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(type: Swift.String, url: Foundation.URL)
    #endif
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(url: Foundation.URL, title: Swift.String? = nil, backButtonEnabled: Swift.Bool = true, trailingItem: NamiPairingFramework.PresentedScreen.TrailingItem? = nil)
  #endif
}


public enum ValueRepresentation : Swift.Equatable {
  case absolute
  case relative
  public static func == (a: NamiPairingFramework.ValueRepresentation, b: NamiPairingFramework.ValueRepresentation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_Concurrency.MainActor @preconcurrency public struct SplineGraph : SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(dataPoints: [Swift.Double], nagativeHandling: NamiPairingFramework.SplineGraph.NegativeValuesHandlingStrategy = .zero, showValues: NamiPairingFramework.ValueRepresentation = .absolute, strokeColor: SwiftUICore.Color = Color(hex: 0x479DCD), strokeStyle: SwiftUICore.StrokeStyle = StrokeStyle(lineWidth: 2, lineCap: .butt, lineJoin: .miter, miterLimit: 10, dash: [], dashPhase: 10), minMaxLabels: Swift.Bool = false, labelTopText: Swift.String? = nil, labelBottomText: Swift.String? = nil, labelColor: SwiftUICore.Color? = nil, labelFont: SwiftUICore.Font? = nil, dashColor: SwiftUICore.Color? = nil)
  #endif
  public enum NegativeValuesHandlingStrategy {
    case none
    case zero
    case magnitude
    case custom((Swift.Double) -> Swift.Double)
  }
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework11SplineGraphV4bodyQrvp", 0) __
}
public enum SDUIPresenterError : Swift.Error {
  case alreadyPresented([NamiPairingFramework.PresentedScreen])
}
final public class NamiSDUIPresenter : Foundation.ObservableObject {
  @usableFromInline
  internal static func defaultOnLoadError(_ error: any Swift.Error)
  @usableFromInline
  internal static func mapUrl(_ url: Foundation.URL) -> NamiPairingFramework.PresentedScreen
  public enum PresentationUpdate {
    case replaceByUrl(NamiPairingFramework.PresentedScreen)
    case replaceByIndex(Swift.Int, NamiPairingFramework.PresentedScreen)
    case replaceTopmost(NamiPairingFramework.PresentedScreen)
    case replaceStack([NamiPairingFramework.PresentedScreen])
    case pushOnStack(NamiPairingFramework.PresentedScreen)
    case popTopmost(_: Swift.Int = 1)
    case popUntil(Swift.String)
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(variablesBridge: NamiPairingFramework.TemplatesVariablesBridge, onLoadError: @escaping (any Swift.Error) -> Swift.Void = NamiSDUIPresenter.defaultOnLoadError, mapUrl: @escaping (Foundation.URL) -> NamiPairingFramework.PresentedScreen? = NamiSDUIPresenter.mapUrl)
  #endif
  @_Concurrency.MainActor final public func present(_ screens: NamiPairingFramework.PresentedScreen..., onDismiss: @escaping () -> Swift.Void = {}) throws -> some SwiftUICore.View
  
  @_Concurrency.MainActor final public func updatePresentedScreens(with mutation: NamiPairingFramework.NamiSDUIPresenter.PresentationUpdate)
  @_Concurrency.MainActor final public func showProgressIndicator(_ show: Swift.Bool)
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
@_Concurrency.MainActor @preconcurrency public struct CircleImageButton : SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(image: SwiftUICore.Image, foregroundColor: SwiftUICore.Color? = nil, backgroundColor: SwiftUICore.Color? = nil, imagePadding: CoreFoundation.CGFloat = 0, action: @escaping () -> Swift.Void = {})
  #endif
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework17CircleImageButtonV4bodyQrvp", 0) __
}
extension UIKit.UINavigationController : @retroactive UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func gestureRecognizerShouldBegin(_: UIKit.UIGestureRecognizer) -> Swift.Bool
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func allowSwipeBackNavigation(_ isAllowed: Swift.Bool) -> some SwiftUICore.View
  
}
extension SwiftUICore.Text {
  public init(_ content: any Swift.StringProtocol, font: NamiPairingFramework.NamiTextStyle)
  public init(_ content: any Swift.StringProtocol, font: SwiftUICore.Font)
  public func fillWidth(_ width: CoreFoundation.CGFloat = .infinity, alignment: SwiftUICore.Alignment = .leading) -> some SwiftUICore.View
  
}
public var statusbarAndNavbarShift: CoreFoundation.CGFloat {
  get
}
public var statusbarShift: CoreFoundation.CGFloat {
  get
}
public var navbarBackgroundViewHeight: CoreFoundation.CGFloat {
  get
}
public var navbarContentViewHeight: CoreFoundation.CGFloat {
  get
}
public var screenWidth: CoreFoundation.CGFloat {
  get
}
public var firstKeyWindow: UIKit.UIWindow?
public var defaultNavbarHeight: CoreFoundation.CGFloat
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func navigationPopGestureDisabled(_ disabled: Swift.Bool) -> some SwiftUICore.View
  
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func onHeightUpdate(_ action: @escaping (CoreFoundation.CGFloat) -> Swift.Void) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func readSize(onChange: @escaping (CoreFoundation.CGSize) -> Swift.Void) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func readSafeAreaInsets(onChange: @escaping (SwiftUICore.EdgeInsets) -> Swift.Void) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public var anyView: SwiftUICore.AnyView {
    get
  }
}
extension SwiftUICore.Binding {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func bindingBool<Item>(_ item: SwiftUICore.Binding<Item?>) -> SwiftUICore.Binding<Swift.Bool>
  #endif
}
extension UIKit.UIFont {
  public class func preferredFont(from font: SwiftUICore.Font) -> UIKit.UIFont
  public class func convertToUIFontCustom(_ font: SwiftUICore.Font) -> UIKit.UIFont
}
@_Concurrency.MainActor @preconcurrency public struct RoundedRectContainerView<Subviews> : SwiftUICore.View where Subviews : SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(spacing: CoreFoundation.CGFloat? = nil, cornerRadius: CoreFoundation.CGFloat = 16.0, excludingCorners: UIKit.UIRectCorner = [], shadowRadius: CoreFoundation.CGFloat? = nil, strokeWidth: CoreFoundation.CGFloat? = nil, strokeColor: SwiftUICore.Color? = nil, backgroundColor: SwiftUICore.Color? = nil, alignment: SwiftUICore.Alignment? = .center, @SwiftUICore.ViewBuilder subviews: () -> Subviews)
  #endif
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework24RoundedRectContainerViewV4bodyQrvp", 0) __<Subviews>
}
@available(iOS 13, macOS 11, *)
@_Concurrency.MainActor @preconcurrency public struct ToastView : SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(type: NamiPairingFramework.ToastView.ToastType, title: Swift.String? = nil, subTitle: Swift.String? = nil, style: NamiPairingFramework.ToastView.AlertStyle? = nil, animationType: NamiPairingFramework.ToastView.ToastAnimationType? = .slide, hideCloseButton: Swift.Bool = false)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(type: NamiPairingFramework.ToastView.ToastType, title: Swift.String? = nil, animationType: NamiPairingFramework.ToastView.ToastAnimationType? = .slide, hideCloseButton: Swift.Bool = false)
  #endif
  public enum ToastAnimationType {
    case slide
    case pop
    public static func == (a: NamiPairingFramework.ToastView.ToastAnimationType, b: NamiPairingFramework.ToastView.ToastAnimationType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ToastType : Swift.Equatable {
    case info
    case success
    case warning
    case error
    case systemImage(_: Swift.String, _: SwiftUICore.Color)
    case image(_: Swift.String, _: SwiftUICore.Color)
    case regular
    public static func == (a: NamiPairingFramework.ToastView.ToastType, b: NamiPairingFramework.ToastView.ToastType) -> Swift.Bool
  }
  public enum AlertStyle : Swift.Equatable {
    case style(backgroundColor: SwiftUICore.Color? = nil, titleColor: SwiftUICore.Color? = nil, subTitleColor: SwiftUICore.Color? = nil, titleFont: SwiftUICore.Font? = nil, subTitleFont: SwiftUICore.Font? = nil)
    public static func == (a: NamiPairingFramework.ToastView.AlertStyle, b: NamiPairingFramework.ToastView.AlertStyle) -> Swift.Bool
  }
  @_Concurrency.MainActor @preconcurrency public var type: NamiPairingFramework.ToastView.ToastType
  @_Concurrency.MainActor @preconcurrency public var title: Swift.String?
  @_Concurrency.MainActor @preconcurrency public var subTitle: Swift.String?
  @_Concurrency.MainActor @preconcurrency public var style: NamiPairingFramework.ToastView.AlertStyle?
  @_Concurrency.MainActor @preconcurrency public var animationType: NamiPairingFramework.ToastView.ToastAnimationType?
  @_Concurrency.MainActor @preconcurrency public var hideCloseButton: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @available(iOS 13, macOS 11, *)
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework9ToastViewV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiXMarkButton : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(appearance: NamiPairingFramework.NamiXMarkButton.Appearance = .regular, diameter: CoreFoundation.CGFloat = 60, onTap: @escaping () -> Swift.Void)
  public enum Appearance {
    case regular
    case inverted
    public static func == (a: NamiPairingFramework.NamiXMarkButton.Appearance, b: NamiPairingFramework.NamiXMarkButton.Appearance) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A11XMarkButtonV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiNavBackButton : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public var action: () -> Swift.Void
  @_Concurrency.MainActor @preconcurrency public init()
  @_Concurrency.MainActor @preconcurrency public init(action: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A13NavBackButtonV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiCircularXMarkButton : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(appearance: NamiPairingFramework.NamiCircularXMarkButton.Appearance = .regular, diameter: CoreFoundation.CGFloat = 60, onTap: @escaping () -> Swift.Void)
  public enum Appearance {
    case regular
    case inverted
    public static func == (a: NamiPairingFramework.NamiCircularXMarkButton.Appearance, b: NamiPairingFramework.NamiCircularXMarkButton.Appearance) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A19CircularXMarkButtonV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiPageIndexIndicatorView : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(numberOfPages: Swift.Int, currentIndex: Swift.Int, activeColor: SwiftUICore.Color = Color.gray, inactiveColor: SwiftUICore.Color = Color.gray.opacity(0.5), heightOfIndicator: CoreFoundation.CGFloat = 16, spacingOfIndicator: CoreFoundation.CGFloat = 12)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A22PageIndexIndicatorViewV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct TextFieldView : SwiftUI.UIViewRepresentable {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(placeholder: Swift.String, text: SwiftUICore.Binding<Swift.String>, isEditing: SwiftUICore.Binding<Swift.Bool>, returnKeyType: UIKit.UIReturnKeyType = .default, textColor: UIKit.UIColor? = nil, font: UIKit.UIFont? = nil)
  #endif
  @objc final public class Coordinator : ObjectiveC.NSObject {
    public init(text: SwiftUICore.Binding<Swift.String>, isEditing: SwiftUICore.Binding<Swift.Bool>, showsPassword: SwiftUICore.Binding<Swift.Bool>, showImageName: Swift.String, hideImageName: Swift.String)
    @objc deinit
  }
  @_Concurrency.MainActor @preconcurrency public static func dismantleUIView(_ uiView: UIKit.UITextField, coordinator: NamiPairingFramework.TextFieldView.Coordinator)
  @_Concurrency.MainActor @preconcurrency public func makeCoordinator() -> NamiPairingFramework.TextFieldView.Coordinator
  @_Concurrency.MainActor @preconcurrency public func makeUIView(context: NamiPairingFramework.TextFieldView.Context) -> UIKit.UITextField
  @_Concurrency.MainActor @preconcurrency public func updateUIView(_ textField: UIKit.UITextField, context: NamiPairingFramework.TextFieldView.Context)
  public typealias Body = Swift.Never
  public typealias UIViewType = UIKit.UITextField
}
extension NamiPairingFramework.TextFieldView.Coordinator : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldDidBeginEditing(_: UIKit.UITextField)
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldDidEndEditing(_: UIKit.UITextField)
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
}
public enum NamiTextFieldStyle {
  case neutral
  case positive
  case negative
  public static func == (a: NamiPairingFramework.NamiTextFieldStyle, b: NamiPairingFramework.NamiTextFieldStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_Concurrency.MainActor @preconcurrency public struct NamiTextField : SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(placeholder: Swift.String, text: SwiftUICore.Binding<Swift.String>, isEditing: SwiftUICore.Binding<Swift.Bool>? = nil, returnKeyType: UIKit.UIReturnKeyType = .default, textFieldFont: SwiftUICore.Font? = nil, subTextFont: SwiftUICore.Font? = nil, textColor: SwiftUICore.Color? = nil, maxLength: Swift.Int? = nil)
  #endif
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A9TextFieldV4bodyQrvp", 0) __
}
extension NamiPairingFramework.NamiTextField {
  @_Concurrency.MainActor @preconcurrency public func style(_ style: NamiPairingFramework.NamiTextFieldStyle) -> NamiPairingFramework.NamiTextField
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func subText(_ subText: Swift.String?) -> NamiPairingFramework.NamiTextField
  #endif
  @_Concurrency.MainActor @preconcurrency public func secureTextEntry(_ secure: Swift.Bool) -> NamiPairingFramework.NamiTextField
}
@_Concurrency.MainActor @preconcurrency public struct NamiErrorChatBubble : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(_ text: Swift.String)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A15ErrorChatBubbleV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiChatBubble : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(_ text: Swift.String)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A10ChatBubbleV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiTopNavigationScreen<LeadingGroup, TrailingGroup, BottomGroup, NotificationArea, Subviews, MainContent> : SwiftUICore.View where LeadingGroup : SwiftUICore.View, TrailingGroup : SwiftUICore.View, BottomGroup : SwiftUICore.View, NotificationArea : SwiftUICore.View, Subviews : SwiftUICore.View, MainContent : SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(title: Swift.String? = nil, largeTitle: Swift.String? = nil, themeId: NamiPairingFramework.ThemeID = 0, colorOverride: SwiftUICore.Color? = nil, statusbarColorOverride: SwiftUICore.Color? = nil, navbarBackgroundBleed: CoreFoundation.CGFloat = 0, contentBehavior: NamiPairingFramework.ContentBehavior = .scrollable, @SwiftUICore.ViewBuilder mainContent: @escaping () -> MainContent = { EmptyView() }, @SwiftUICore.ViewBuilder leadingButtonsGroup: @escaping () -> LeadingGroup = { EmptyView() }, @SwiftUICore.ViewBuilder trailingButtonsGroup: @escaping () -> TrailingGroup = { EmptyView() }, @SwiftUICore.ViewBuilder notificationAreaView: @escaping () -> NotificationArea = { EmptyView() }, @SwiftUICore.ViewBuilder additionalViews: @escaping () -> Subviews = { EmptyView() }, @SwiftUICore.ViewBuilder bottomButtonsGroup: @escaping () -> BottomGroup = { EmptyView() })
  #endif
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A19TopNavigationScreenV4bodyQrvp", 0) __<LeadingGroup, TrailingGroup, BottomGroup, NotificationArea, Subviews, MainContent>
}
public enum ContentBehavior {
  case scrollable(onScroll: (CoreFoundation.CGFloat) -> Swift.Void)
  case fixed
  public static var scrollable: NamiPairingFramework.ContentBehavior {
    get
  }
}
extension NamiPairingFramework.ContentBehavior : Swift.Equatable {
  public static func == (lhs: NamiPairingFramework.ContentBehavior, rhs: NamiPairingFramework.ContentBehavior) -> Swift.Bool
}
@_Concurrency.MainActor @preconcurrency public struct LottieAnimationView : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(animation: Swift.KeyPath<NamiPairingFramework.Animations, Lottie.LottieAnimation>, loopMode: Lottie.LottieLoopMode = .loop)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework19LottieAnimationViewV4bodyQrvp", 0) __
}
public typealias LottieAnimations = NamiPairingFramework.Animations
public struct LottieAnimationsKey : SwiftUICore.EnvironmentKey {
  public static let defaultValue: NamiPairingFramework.LottieAnimations
  public typealias Value = NamiPairingFramework.LottieAnimations
}
@_Concurrency.MainActor @preconcurrency public struct CircleButton : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init()
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework12CircleButtonV4bodyQrvp", 0) __
}
public struct NamiTextStyle : Swift.Identifiable {
  public enum Leading {
    case loose
    case tight
    case standard
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: SwiftUICore.Font.Leading)
    #endif
    public static func == (a: NamiPairingFramework.NamiTextStyle.Leading, b: NamiPairingFramework.NamiTextStyle.Leading) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let headline: NamiPairingFramework.NamiTextStyle
  public static let headline2: NamiPairingFramework.NamiTextStyle
  public static let headline3: NamiPairingFramework.NamiTextStyle
  public static let headline4: NamiPairingFramework.NamiTextStyle
  public static let headline5: NamiPairingFramework.NamiTextStyle
  public static let headline6: NamiPairingFramework.NamiTextStyle
  public static let paragraph1: NamiPairingFramework.NamiTextStyle
  public static let paragraph2: NamiPairingFramework.NamiTextStyle
  public static let small: NamiPairingFramework.NamiTextStyle
  public static let small2: NamiPairingFramework.NamiTextStyle
  public let id: Swift.String
  public var font: SwiftUICore.Font {
    get
  }
  public var uiFont: UIKit.UIFont {
    get
  }
  public typealias ID = Swift.String
}
@_Concurrency.MainActor @preconcurrency public struct NamiSFSafariView : SwiftUI.UIViewControllerRepresentable {
  @_Concurrency.MainActor @preconcurrency public init(url: Foundation.URL)
  @_Concurrency.MainActor @preconcurrency public func makeUIViewController(context _: SwiftUI.UIViewControllerRepresentableContext<NamiPairingFramework.NamiSFSafariView>) -> SafariServices.SFSafariViewController
  @_Concurrency.MainActor @preconcurrency public func updateUIViewController(_: SafariServices.SFSafariViewController, context _: SwiftUI.UIViewControllerRepresentableContext<NamiPairingFramework.NamiSFSafariView>)
  public typealias Body = Swift.Never
  public typealias Coordinator = Swift.Void
  public typealias UIViewControllerType = SafariServices.SFSafariViewController
}
@available(iOS 15, *)
@_Concurrency.MainActor @preconcurrency public struct NamiTextHyperLink : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(content: Foundation.AttributedString)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(text: Swift.String, link: Swift.String, linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(markdownString: Swift.String, linkTexts: Swift.String..., linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(markdownString: Swift.String, linkTexts: [Swift.String], linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(content: Swift.String, textsAndLinks: [(Swift.String, Swift.String)], linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil)
  #endif
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @available(iOS 15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A13TextHyperLinkV4bodyQrvp", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiTextHyperLinkLegacy : SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(text: Swift.String, link: Swift.String, linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil)
  #endif
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A19TextHyperLinkLegacyV4bodyQrvp", 0) __
}
public enum NamiTextHyperLinkHelpers {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func hyperLink(text: Swift.String, link: Swift.String, linkColor: SwiftUICore.Color, underlineColor: SwiftUICore.Color? = nil) -> some SwiftUICore.View
  
  #endif
}
extension SwiftUICore.View {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func dynamicBottomSheet<SheetContent>(isPresented: SwiftUICore.Binding<Swift.Bool>, dragIndicatorVisible: Swift.Bool = false, onDismiss: SwiftUICore.Binding<(() -> Swift.Void)?>, backgroundColor: SwiftUICore.Color = .white, @SwiftUICore.ViewBuilder content: @escaping () -> SheetContent) -> some SwiftUICore.View where SheetContent : SwiftUICore.View
  
  #endif
}
@_Concurrency.MainActor @preconcurrency public struct NotificationButtonStyle : SwiftUI.ButtonStyle {
  @_Concurrency.MainActor @preconcurrency public init(color: SwiftUICore.Color = Color(hex: 0xEAEAEA))
  @_Concurrency.MainActor @preconcurrency public struct NotificationButton : SwiftUICore.View {
    @_Concurrency.MainActor @preconcurrency public init(configuration: NamiPairingFramework.NotificationButtonStyle.Configuration, color: SwiftUICore.Color)
    @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
      get
    }
    public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework23NotificationButtonStyleV0dE0V4bodyQrvp", 0) __
  }
  @_Concurrency.MainActor @preconcurrency public func makeBody(configuration: NamiPairingFramework.NotificationButtonStyle.Configuration) -> some SwiftUICore.View
  
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework23NotificationButtonStyleV8makeBody13configurationQr7SwiftUI0eF13ConfigurationV_tF", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiAuthButtonStyle : SwiftUI.ButtonStyle {
  @_Concurrency.MainActor @preconcurrency public init(mode: NamiPairingFramework.NamiAuthButtonStyle.AppearanceColorMode = .light)
  @_Concurrency.MainActor @preconcurrency public struct NamiAuthButton : SwiftUICore.View {
    @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
      get
    }
    public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A15AuthButtonStyleV0adE0V4bodyQrvp", 0) __
  }
  public enum AppearanceColorMode {
    case light
    case dark
    public static func == (a: NamiPairingFramework.NamiAuthButtonStyle.AppearanceColorMode, b: NamiPairingFramework.NamiAuthButtonStyle.AppearanceColorMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public func makeBody(configuration: NamiPairingFramework.NamiAuthButtonStyle.Configuration) -> some SwiftUICore.View
  
  public struct ConstraintLayout {
    public static let LeadingToSuperView: CoreFoundation.CGFloat
    public static let TrailingToSuperView: CoreFoundation.CGFloat
    public static let BottomToSuperView: CoreFoundation.CGFloat
    public static let BottomToNextButton: CoreFoundation.CGFloat
    public static let BottomTokeyboard: CoreFoundation.CGFloat
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A15AuthButtonStyleV8makeBody13configurationQr7SwiftUI0eF13ConfigurationV_tF", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct NamiActionButtonStyle : SwiftUI.ButtonStyle {
  @_Concurrency.MainActor @preconcurrency public init(rank: NamiPairingFramework.NamiActionButtonStyle.AppearanceHierarchyRank = .primary, sharpCorner: UIKit.UIRectCorner = .topRight)
  @_Concurrency.MainActor @preconcurrency public struct NamiActionButton : SwiftUICore.View {
    @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
      get
    }
    public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A17ActionButtonStyleV0adE0V4bodyQrvp", 0) __
  }
  public enum AppearanceHierarchyRank {
    case primary
    case secondary
    case tertiary
    case destructive
    public static func == (a: NamiPairingFramework.NamiActionButtonStyle.AppearanceHierarchyRank, b: NamiPairingFramework.NamiActionButtonStyle.AppearanceHierarchyRank) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public func makeBody(configuration: NamiPairingFramework.NamiActionButtonStyle.Configuration) -> some SwiftUICore.View
  
  public struct ConstraintLayout {
    public static let LeadingToSuperView: CoreFoundation.CGFloat
    public static let TrailingToSuperView: CoreFoundation.CGFloat
    public static let BottomToSuperView: CoreFoundation.CGFloat
    public static let BottomToNextButton: CoreFoundation.CGFloat
    public static let BottomTokeyboard: CoreFoundation.CGFloat
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework0A17ActionButtonStyleV8makeBody13configurationQr7SwiftUI0eF13ConfigurationV_tF", 0) __
}
@_Concurrency.MainActor @preconcurrency public struct ScrollViewWithOnScrollAction<Subviews> : SwiftUICore.View where Subviews : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(onScroll action: @escaping (CoreFoundation.CGFloat) -> Swift.Void = { _ in }, @SwiftUICore.ViewBuilder subviews: () -> Subviews)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework016ScrollViewWithOnD6ActionV4bodyQrvp", 0) __<Subviews>
}
public struct RemoteTemplateEntrypointHelper {
  public init(config: any NamiPairingFramework.RemoteTemplateUIConfigProtocol)
}
extension NamiPairingFramework.NamiDeviceType : @unchecked @retroactive Swift.Sendable {
}
public typealias ZoneBSSID = Foundation.Data
@_hasMissingDesignatedInitializers public class SetupGuideInputs : Swift.Encodable, @unchecked Swift.Sendable {
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public struct SetupGuideState : Swift.Encodable, @unchecked Swift.Sendable, Swift.Equatable {
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.SetupGuideState, b: NamiPairingFramework.SetupGuideState) -> Swift.Bool
}
public enum SetupGuideError : Swift.Error, NamiPairingFramework.RemoteTemplatesUIControllerError {
  case api(any Swift.Error)
  case storage(any Swift.Error)
  case deviceConnections(any Swift.Error)
  case divKit(any Swift.Error)
  case invalidState((any Swift.Error)?)
}
public typealias OnPairingFinishedCallback = (NamiPairingFramework.PairingResultStatus) -> Swift.Void
public enum SetupGuideEvent : NamiPairingFramework.RemoteTemplatesUIControllerEvent {
  case gotUrl(Foundation.URL)
  case variableUpdated(Swift.String, Swift.AnyHashable)
  case viewDismissed
  case pairingRequested(NamiPairingFramework.PlaceID, NamiPairingFramework.PlaceZoneID, NamiPairingFramework.RoomID, NamiPairingFramework.NamiDeviceType, Swift.String, NamiPairingFramework.OnPairingFinishedCallback)
  case updateWiFiCredsRequested(NamiPairingFramework.PlaceID, NamiPairingFramework.PlaceZoneID, NamiPairingFramework.RoomID, NamiPairingFramework.NamiDeviceType, NamiPairingFramework.CountryCode, NamiPairingFramework.ZoneBSSID?, Swift.String?, NamiPairingFramework.OnPairingFinishedCallback)
  case warning(NamiPairingFramework.SetupGuideError)
}
public enum PairingResultStatus {
  case succeeded(deviceId: NamiPairingFramework.DeviceID, bssid: [Swift.UInt8]?)
  case cancelled(NamiPairingFramework.DeviceID?)
}
public protocol StringIdentifiableCode {
  static func canonicalize(_ s: Swift.String) -> Swift.String
  static func isValid(_ s: Swift.String) -> Swift.Bool
}
public struct Code<Spec> : Swift.RawRepresentable, Swift.Hashable, Swift.Sendable, Swift.Codable, Swift.CustomStringConvertible, Swift.LosslessStringConvertible where Spec : NamiPairingFramework.StringIdentifiableCode {
  public let rawValue: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ description: Swift.String)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ value: Swift.String?)
  #endif
  public var description: Swift.String {
    get
  }
  public var isValid: Swift.Bool {
    get
  }
  public typealias RawValue = Swift.String
}
public func == <S>(lhs: NamiPairingFramework.Code<S>, rhs: Swift.String) -> Swift.Bool where S : NamiPairingFramework.StringIdentifiableCode
public func == <S>(lhs: Swift.String, rhs: NamiPairingFramework.Code<S>) -> Swift.Bool where S : NamiPairingFramework.StringIdentifiableCode
public enum CountryStringIdentifiableCode : NamiPairingFramework.StringIdentifiableCode {
  public static func canonicalize(_ s: Swift.String) -> Swift.String
  public static func isValid(_ s: Swift.String) -> Swift.Bool
}
public typealias CountryCode = NamiPairingFramework.Code<NamiPairingFramework.CountryStringIdentifiableCode>
public enum LanguageStringIdentifiableCode : NamiPairingFramework.StringIdentifiableCode {
  public static func canonicalize(_ s: Swift.String) -> Swift.String
  public static func isValid(_ s: Swift.String) -> Swift.Bool
}
public typealias LanguageCode = NamiPairingFramework.Code<NamiPairingFramework.LanguageStringIdentifiableCode>
public struct RemoteTemplateUI_Place : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: NamiPairingFramework.PlaceID, urn: Swift.String, name: Swift.String, timeZone: Swift.String? = nil, createdAt: Foundation.Date, updatedAt: Foundation.Date, alertMode: Swift.String, entryDelay: NamiPairingFramework.EntryDelay, exitDelay: NamiPairingFramework.ExitDelay, placeSensitivity: Swift.Int = 0)
  #endif
  public var id: NamiPairingFramework.PlaceID
  public var urn: Swift.String
  public var name: Swift.String
  public var timeZone: Swift.String?
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var alertMode: Swift.String?
  public var entryDelay: NamiPairingFramework.EntryDelay
  public var exitDelay: NamiPairingFramework.ExitDelay
  public var placeSensitivity: Swift.Int
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_Place, b: NamiPairingFramework.RemoteTemplateUI_Place) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PlaceUser : Swift.Codable, Swift.Equatable {
  public var id: NamiPairingFramework.PlaceUserID
  public var userId: NamiPairingFramework.UserID
  public var name: Swift.String
  public var urn: Swift.String
  public var roleId: Swift.String
  public var roleName: Swift.String
  public var iconId: NamiPairingFramework.UserIconID
  public var themeId: NamiPairingFramework.ThemeID
  public var placeId: NamiPairingFramework.PlaceID
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PlaceUser, b: NamiPairingFramework.RemoteTemplateUI_PlaceUser) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_InviteLink : Swift.Codable, Swift.Equatable {
  public var code: NamiPairingFramework.InviteCode
  public var name: Swift.String
  public var roleId: Swift.String
  public var roleName: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var placeName: Swift.String?
  public var state: Swift.String
  public var inviteUrl: Foundation.URL
  public var expiresAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_InviteLink, b: NamiPairingFramework.RemoteTemplateUI_InviteLink) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PlaceUsageLimits : Swift.Codable, Swift.Equatable {
  public var urn: NamiPairingFramework.URN
  public var membership: Swift.UInt
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PlaceUsageLimits, b: NamiPairingFramework.RemoteTemplateUI_PlaceUsageLimits) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_Zone : Swift.Codable, Swift.Equatable {
  public init(id: NamiPairingFramework.PlaceZoneID, urn: Swift.String, name: Swift.String, alertMode: Swift.String, createdAt: Foundation.Date, updatedAt: Foundation.Date, rooms: [NamiPairingFramework.RemoteTemplateUI_Room], devices: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory, engineConfig: NamiPairingFramework.RemoteTemplateUI_EngineConfig)
  public var id: NamiPairingFramework.PlaceZoneID
  public var urn: Swift.String
  public var name: Swift.String
  public var alertMode: Swift.String
  public var rooms: [NamiPairingFramework.RemoteTemplateUI_Room]
  public var devices: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var engineConfig: NamiPairingFramework.RemoteTemplateUI_EngineConfig
  public var hasBr: Swift.Bool
  public var threadDevicesCount: Swift.Int
  public static func hasBr(devices: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory) -> Swift.Bool
  public static func threadDevicesCount(devices: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory) -> Swift.Int
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_Zone, b: NamiPairingFramework.RemoteTemplateUI_Zone) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_Room : Swift.Codable, Swift.Equatable {
  public init(id: NamiPairingFramework.RoomID, urn: Swift.String, name: Swift.String, zoneId: NamiPairingFramework.PlaceZoneID, iconId: NamiPairingFramework.IconID, createdAt: Foundation.Date, updatedAt: Foundation.Date, devices: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory)
  public var id: NamiPairingFramework.RoomID
  public var urn: Swift.String
  public var name: Swift.String
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var iconId: NamiPairingFramework.IconID
  public var devices: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_Room, b: NamiPairingFramework.RemoteTemplateUI_Room) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesByCategory : Swift.Codable, Swift.Equatable {
  public init(activitySensors: [NamiPairingFramework.RemoteTemplateUI_Device], accessories: [NamiPairingFramework.RemoteTemplateUI_Device])
  public var activitySensors: [NamiPairingFramework.RemoteTemplateUI_Device]
  public var accessories: [NamiPairingFramework.RemoteTemplateUI_Device]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory, b: NamiPairingFramework.RemoteTemplateUI_DevicesByCategory) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DeviceState : Swift.Codable, Swift.Equatable, Swift.Hashable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(cloudAccessible: Swift.Bool? = nil, lastCloudAccess: Foundation.Date? = nil, seqTime: Swift.UInt64, state: Foundation.Data, stateUpdatedAt: Foundation.Date)
  #endif
  public var cloudAccessible: Swift.Bool?
  public var lastCloudAccess: Foundation.Date?
  public var seqTime: Swift.UInt64
  public var state: Foundation.Data
  public var stateUpdatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DeviceState, b: NamiPairingFramework.RemoteTemplateUI_DeviceState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_Device : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public init(id: NamiPairingFramework.DeviceID, uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, name: Swift.String, codeName: Swift.String, productId: NamiPairingFramework.DeviceProductID, createdAt: Foundation.Date, updatedAt: Foundation.Date, isBr: Swift.Bool, state: NamiPairingFramework.RemoteTemplateUI_DeviceState, roomId: NamiPairingFramework.RoomID, deviceType: NamiPairingFramework.RemoteTemplateUI_DeviceType)
  public var id: NamiPairingFramework.DeviceID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var name: Swift.String
  public var codeName: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public var isBr: Swift.Bool
  public var isCloudConnected: Swift.Bool
  public var state: NamiPairingFramework.RemoteTemplateUI_DeviceState?
  public var roomId: NamiPairingFramework.RoomID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var deviceType: NamiPairingFramework.RemoteTemplateUI_DeviceType
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_Device, b: NamiPairingFramework.RemoteTemplateUI_Device) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DeviceType : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public init(name: Swift.String, localizedName: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(_ deviceType: NamiPairingFramework.NamiDeviceType)
  public var localizedName: Swift.String
  public var name: Swift.String
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DeviceType, b: NamiPairingFramework.RemoteTemplateUI_DeviceType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesKit : Swift.Codable, Swift.Equatable {
  public init(name: Swift.String, kitId: Swift.UInt64, firstInZone: Swift.Bool, includedDevices: [NamiPairingFramework.RemoteTemplateUI_DeviceType], pairedDevices: [NamiPairingFramework.DeviceUniversalID])
  public var name: Swift.String
  public var kitId: Swift.UInt64
  public var firstInZone: Swift.Bool
  public var includedDevices: [NamiPairingFramework.RemoteTemplateUI_DeviceType]
  public var pairedDevices: [NamiPairingFramework.DeviceUniversalID]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesKit, b: NamiPairingFramework.RemoteTemplateUI_DevicesKit) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_AutomationAction : Swift.Codable, Swift.Equatable {
  public init(type: Swift.String, mode: NamiPairingFramework.NamiAlertMode)
  public var type: Swift.String
  public var mode: NamiPairingFramework.NamiAlertMode
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_AutomationAction, b: NamiPairingFramework.RemoteTemplateUI_AutomationAction) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_AutomationReaction : Swift.Codable, Swift.Equatable {
  public init(uuid: Swift.String, targetType: Swift.String, targetIds: [NamiPairingFramework.PlaceZoneID], action: NamiPairingFramework.RemoteTemplateUI_AutomationAction)
  public var uuid: Swift.String
  public var targetType: Swift.String
  public var targetIds: [NamiPairingFramework.PlaceZoneID]
  public var action: NamiPairingFramework.RemoteTemplateUI_AutomationAction
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_AutomationReaction, b: NamiPairingFramework.RemoteTemplateUI_AutomationReaction) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_AutomationTrigger : Swift.Codable, Swift.Equatable {
  public init(type: Swift.String, hour: Swift.Int, minute: Swift.Int, daysOfWeek: [Swift.String])
  public var type: Swift.String
  public var hour: Swift.Int
  public var minute: Swift.Int
  public var daysOfWeek: [Swift.String]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_AutomationTrigger, b: NamiPairingFramework.RemoteTemplateUI_AutomationTrigger) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_NamiAutomation : Swift.Codable, Swift.Equatable {
  public init(id: NamiPairingFramework.AutomationID, trigger: NamiPairingFramework.RemoteTemplateUI_AutomationTrigger, reactions: [NamiPairingFramework.RemoteTemplateUI_AutomationReaction], active: Swift.Bool)
  public var id: NamiPairingFramework.AutomationID
  public var trigger: NamiPairingFramework.RemoteTemplateUI_AutomationTrigger
  public var reactions: [NamiPairingFramework.RemoteTemplateUI_AutomationReaction]
  public var active: Swift.Bool
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_NamiAutomation, b: NamiPairingFramework.RemoteTemplateUI_NamiAutomation) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_MemebershipResponse : Swift.Codable, Swift.Equatable {
  public init(users: [NamiPairingFramework.RemoteTemplateUI_PlaceUser], invites: [NamiPairingFramework.RemoteTemplateUI_InviteLink])
  public var users: [NamiPairingFramework.RemoteTemplateUI_PlaceUser]
  public var invites: [NamiPairingFramework.RemoteTemplateUI_InviteLink]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_MemebershipResponse, b: NamiPairingFramework.RemoteTemplateUI_MemebershipResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_InvitePeek : Swift.Codable, Swift.Equatable {
  public init(code: NamiPairingFramework.InviteCode, name: Swift.String, roleId: Swift.String, roleName: Swift.String, placeId: NamiPairingFramework.PlaceID, placeName: Swift.String, placeIconId: NamiPairingFramework.IconID)
  public var code: NamiPairingFramework.InviteCode
  public var name: Swift.String
  public var roleId: Swift.String
  public var roleName: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var placeName: Swift.String
  public var placeIconId: NamiPairingFramework.IconID
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_InvitePeek, b: NamiPairingFramework.RemoteTemplateUI_InvitePeek) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesResponse : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(devices: [NamiPairingFramework.RemoteTemplateUI_Device], total: Swift.Int, pageSize: Swift.Int, cursor: Swift.String? = nil)
  #endif
  public var devices: [NamiPairingFramework.RemoteTemplateUI_Device]
  public var total: Swift.Int
  public var pageSize: Swift.Int
  public var cursor: Swift.String?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesResponse, b: NamiPairingFramework.RemoteTemplateUI_DevicesResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesCommandResponseResult : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(uid: NamiPairingFramework.DeviceUniversalID, success: Swift.Bool, errorMessage: Swift.String? = nil, errorCode: Swift.String? = nil)
  #endif
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var success: Swift.Bool
  public var errorMessage: Swift.String?
  public var errorCode: Swift.String?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponseResult, b: NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponseResult) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesCommandResponse : Swift.Codable, Swift.Equatable {
  public init(seqTime: Swift.UInt64, results: [NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponseResult])
  public var seqTime: Swift.UInt64
  public var results: [NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponseResult]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponse, b: NamiPairingFramework.RemoteTemplateUI_DevicesCommandResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DevicesQuery : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(placeIds: [NamiPairingFramework.PlaceID], zoneIds: [NamiPairingFramework.PlaceZoneID], roomIds: [NamiPairingFramework.RoomID], uids: [NamiPairingFramework.DeviceUniversalID], cursor: Swift.String? = nil)
  #endif
  public var placeIds: [NamiPairingFramework.PlaceID]
  public var zoneIds: [NamiPairingFramework.PlaceZoneID]
  public var roomIds: [NamiPairingFramework.RoomID]
  public var uids: [NamiPairingFramework.DeviceUniversalID]
  public var cursor: Swift.String?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DevicesQuery, b: NamiPairingFramework.RemoteTemplateUI_DevicesQuery) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_ActivityEvent : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(uuid: Foundation.UUID? = nil, startedAt: Foundation.Date, endedAt: Foundation.Date? = nil, detection: Swift.Bool, health: Swift.String)
  #endif
  public var uuid: Foundation.UUID?
  public var startedAt: Foundation.Date
  public var endedAt: Foundation.Date?
  public var detection: Swift.Bool
  public var health: Swift.String
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_ActivityEvent, b: NamiPairingFramework.RemoteTemplateUI_ActivityEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_ZoneMotionEvent : Swift.Codable, Swift.Equatable {
  public init(zoneId: NamiPairingFramework.PlaceZoneID, motionEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent], occupancyEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent])
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var motionEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent]
  public var occupancyEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_ZoneMotionEvent, b: NamiPairingFramework.RemoteTemplateUI_ZoneMotionEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_ZoneMotionStatus : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: NamiPairingFramework.PlaceZoneID, detection: Swift.Bool? = nil, startedAt: Foundation.Date? = nil, health: Swift.String)
  #endif
  public var id: NamiPairingFramework.PlaceZoneID
  public var detection: Swift.Bool?
  public var startedAt: Foundation.Date?
  public var health: Swift.String
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_ZoneMotionStatus, b: NamiPairingFramework.RemoteTemplateUI_ZoneMotionStatus) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PlaceMotionHistory : Swift.Codable, Swift.Equatable {
  public init(placeId: NamiPairingFramework.PlaceID, motionEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent], occupancyEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent])
  public var placeId: NamiPairingFramework.PlaceID
  public var motionEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent]
  public var occupancyEvents: [NamiPairingFramework.RemoteTemplateUI_ActivityEvent]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PlaceMotionHistory, b: NamiPairingFramework.RemoteTemplateUI_PlaceMotionHistory) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_MotionInterval : Swift.Codable, Swift.Equatable {
  public init(start: Foundation.Date, value: Swift.UInt8)
  public var start: Foundation.Date
  public var value: Swift.UInt8
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_MotionInterval, b: NamiPairingFramework.RemoteTemplateUI_MotionInterval) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_MotionAggregate : Swift.Codable, Swift.Equatable {
  public init(metric: Swift.String, resolution: Swift.String, intervalLength: Foundation.TimeInterval, intervals: [NamiPairingFramework.RemoteTemplateUI_MotionInterval])
  public var metric: Swift.String
  public var resolution: Swift.String
  public var intervalLength: Foundation.TimeInterval
  public var intervals: [NamiPairingFramework.RemoteTemplateUI_MotionInterval]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_MotionAggregate, b: NamiPairingFramework.RemoteTemplateUI_MotionAggregate) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_ZoneSparkline : Swift.Codable, Swift.Equatable {
  public init(zoneUrn: Swift.String, metric: Swift.String, resolution: Swift.String, intervalLength: Foundation.TimeInterval, intervals: [NamiPairingFramework.RemoteTemplateUI_MotionInterval])
  public var zoneUrn: Swift.String
  public var metric: Swift.String
  public var resolution: Swift.String
  public var intervalLength: Foundation.TimeInterval
  public var intervals: [NamiPairingFramework.RemoteTemplateUI_MotionInterval]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_ZoneSparkline, b: NamiPairingFramework.RemoteTemplateUI_ZoneSparkline) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PlaceMotionAggregates : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(placeId: NamiPairingFramework.PlaceID, aggregates: [NamiPairingFramework.RemoteTemplateUI_MotionAggregate], sparklines: [NamiPairingFramework.RemoteTemplateUI_ZoneSparkline]? = nil)
  #endif
  public var placeId: NamiPairingFramework.PlaceID
  public var aggregates: [NamiPairingFramework.RemoteTemplateUI_MotionAggregate]
  public var sparklines: [NamiPairingFramework.RemoteTemplateUI_ZoneSparkline]?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PlaceMotionAggregates, b: NamiPairingFramework.RemoteTemplateUI_PlaceMotionAggregates) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_ZoneMotionAggregates : Swift.Codable, Swift.Equatable {
  public init(zoneId: NamiPairingFramework.PlaceZoneID, aggregates: [NamiPairingFramework.RemoteTemplateUI_MotionAggregate])
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var aggregates: [NamiPairingFramework.RemoteTemplateUI_MotionAggregate]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_ZoneMotionAggregates, b: NamiPairingFramework.RemoteTemplateUI_ZoneMotionAggregates) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_MotionData : Swift.Codable, Swift.Equatable {
  public var connectedDevices: Swift.Int64
  public var motionStats: [Swift.Int64]
  public var isMovementDetected: Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_MotionData, b: NamiPairingFramework.RemoteTemplateUI_MotionData) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_SensingLinks : Swift.Codable, Swift.Equatable {
  public struct LinkStats : Swift.Codable, Swift.Equatable {
    public var rssi: Swift.Int32
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: NamiPairingFramework.RemoteTemplateUI_SensingLinks.LinkStats, b: NamiPairingFramework.RemoteTemplateUI_SensingLinks.LinkStats) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
  }
  public var sensingLink: [Swift.String : [Swift.String : NamiPairingFramework.RemoteTemplateUI_SensingLinks.LinkStats]]
  public init(_ sensingLinks: [NamiPairingFramework.DeviceUniversalID : [NamiPairingFramework.DeviceUniversalID : Swift.Int32]])
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_SensingLinks, b: NamiPairingFramework.RemoteTemplateUI_SensingLinks) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_RestEvent : Swift.Codable, Swift.Equatable {
  public init(deviceUid: NamiPairingFramework.DeviceUniversalID, startedAt: Foundation.Date, endedAt: Foundation.Date)
  public var deviceUid: NamiPairingFramework.DeviceUniversalID
  public var startedAt: Foundation.Date
  public var endedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_RestEvent, b: NamiPairingFramework.RemoteTemplateUI_RestEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_RestEventsResponse : Swift.Codable, Swift.Equatable {
  public init(restEvents: [NamiPairingFramework.RemoteTemplateUI_RestEvent])
  public var restEvents: [NamiPairingFramework.RemoteTemplateUI_RestEvent]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_RestEventsResponse, b: NamiPairingFramework.RemoteTemplateUI_RestEventsResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_RestInsight : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(deviceUid: NamiPairingFramework.DeviceUniversalID, totalRestTime: Swift.Int, numberOfInterruptions: Swift.Int, timeToBed: Foundation.Date? = nil, outOfBedAt: Foundation.Date? = nil)
  #endif
  public var deviceUid: NamiPairingFramework.DeviceUniversalID
  public var totalRestTime: Swift.Int
  public var numberOfInterruptions: Swift.Int
  public var timeToBed: Foundation.Date?
  public var outOfBedAt: Foundation.Date?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_RestInsight, b: NamiPairingFramework.RemoteTemplateUI_RestInsight) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_RestInsightsResponse : Swift.Codable, Swift.Equatable {
  public init(restInsights: [NamiPairingFramework.RemoteTemplateUI_RestInsight])
  public var restInsights: [NamiPairingFramework.RemoteTemplateUI_RestInsight]
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_RestInsightsResponse, b: NamiPairingFramework.RemoteTemplateUI_RestInsightsResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DeviceAttributeState : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(uid: NamiPairingFramework.DeviceUniversalID, endpoint: Swift.Int, path: Swift.String, value: Swift.String? = nil, updatedAt: Foundation.Date, isDeleted: Swift.Bool)
  #endif
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var endpoint: Swift.Int
  public var path: Swift.String
  public var value: Swift.String?
  public var updatedAt: Foundation.Date
  public var isDeleted: Swift.Bool
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DeviceAttributeState, b: NamiPairingFramework.RemoteTemplateUI_DeviceAttributeState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DeviceAttributeStateResponse : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(deviceAttributeStates: [NamiPairingFramework.RemoteTemplateUI_DeviceAttributeState], total: Swift.Int, pageSize: Swift.Int, cursor: Swift.String? = nil)
  #endif
  public var deviceAttributeStates: [NamiPairingFramework.RemoteTemplateUI_DeviceAttributeState]
  public var total: Swift.Int
  public var pageSize: Swift.Int
  public var cursor: Swift.String?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStateResponse, b: NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStateResponse) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_DeviceAttributeStatesQuery {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(placeIds: [NamiPairingFramework.PlaceID], zoneIds: [NamiPairingFramework.PlaceZoneID], roomIds: [NamiPairingFramework.RoomID], uids: [NamiPairingFramework.DeviceUniversalID], from: Foundation.Date? = nil, to: Foundation.Date? = nil, cursor: Swift.String? = nil)
  #endif
  public var placeIds: [NamiPairingFramework.PlaceID]
  public var zoneIds: [NamiPairingFramework.PlaceZoneID]
  public var roomIds: [NamiPairingFramework.RoomID]
  public var uids: [NamiPairingFramework.DeviceUniversalID]
  public var from: Foundation.Date?
  public var to: Foundation.Date?
  public var cursor: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  public static func parameters(placeIds: [NamiPairingFramework.PlaceID] = [], zoneIds: [NamiPairingFramework.PlaceZoneID] = [], roomIds: [NamiPairingFramework.RoomID] = [], uids: [NamiPairingFramework.DeviceUniversalID] = [], from: Foundation.Date? = nil, to: Foundation.Date? = nil, cursor: Swift.String? = nil) -> NamiPairingFramework.RemoteTemplateUI_DeviceAttributeStatesQuery
  #endif
  public func getQueryItems() -> [Foundation.URLQueryItem]
}
public struct RemoteTemplateUI_EngineConfig : Swift.Codable, Swift.Equatable {
  public init(zoneId: NamiPairingFramework.PlaceZoneID, engineType: Swift.String, sensitivityLevel: Swift.Int)
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var engineType: Swift.String
  public var sensitivityLevel: Swift.Int
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_EngineConfig, b: NamiPairingFramework.RemoteTemplateUI_EngineConfig) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PinVerificationResult : Swift.Codable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(success: Swift.Bool, error: NamiPairingFramework.RemoteTemplateUI_PinVerificationError? = nil)
  #endif
  public var success: Swift.Bool
  public var error: NamiPairingFramework.RemoteTemplateUI_PinVerificationError?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PinVerificationResult, b: NamiPairingFramework.RemoteTemplateUI_PinVerificationResult) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PinVerificationError : Swift.Codable, Swift.Equatable {
  public init(code: Swift.String, details: NamiPairingFramework.RemoteTemplateUI_PinVerificationErrorDetails)
  public var code: Swift.String
  public var details: NamiPairingFramework.RemoteTemplateUI_PinVerificationErrorDetails
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PinVerificationError, b: NamiPairingFramework.RemoteTemplateUI_PinVerificationError) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PinVerificationErrorDetails : Swift.Codable, Swift.Equatable {
  public init(attribute: Swift.String)
  public var attribute: Swift.String
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PinVerificationErrorDetails, b: NamiPairingFramework.RemoteTemplateUI_PinVerificationErrorDetails) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_PinVerificationFailure : Swift.Error, Swift.Equatable {
  public init(code: Swift.String, attribute: Swift.String, message: Swift.String)
  public let code: Swift.String
  public let attribute: Swift.String
  public let message: Swift.String
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PinVerificationFailure, b: NamiPairingFramework.RemoteTemplateUI_PinVerificationFailure) -> Swift.Bool
}
public struct RemoteTemplateUI_PinCredentialRecord : Swift.Codable, Swift.Equatable {
  public init(id: NamiPairingFramework.PinCredentialID, name: Swift.String)
  public var id: NamiPairingFramework.PinCredentialID
  public var name: Swift.String
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_PinCredentialRecord, b: NamiPairingFramework.RemoteTemplateUI_PinCredentialRecord) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_WiFiCredentialsSessionsResponse : Swift.Decodable {
  public init(sessions: [NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession])
  public var sessions: [NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession]
  public init(from decoder: any Swift.Decoder) throws
}
public enum RemoteTemplateUI_WiFiCredentialsUpdateStatus : Swift.String, Swift.Codable {
  case inProgress
  case completed
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct RemoteTemplateUI_UpdatedDevice : Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public init(uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, updatedBy: NamiPairingFramework.RemoteTemplateUI_UpdatedDeviceUser, updatedAt: Foundation.Date)
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var updatedBy: NamiPairingFramework.RemoteTemplateUI_UpdatedDeviceUser
  public var updatedAt: Foundation.Date
  public var id: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_UpdatedDevice, b: NamiPairingFramework.RemoteTemplateUI_UpdatedDevice) -> Swift.Bool
  public typealias ID = Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_WiFiCredentialsHoldingDevice : Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var id: NamiPairingFramework.DeviceUniversalID {
    get
  }
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsHoldingDevice, b: NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsHoldingDevice) -> Swift.Bool
  public typealias ID = NamiPairingFramework.DeviceUniversalID
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_UpdatedDeviceUser : Swift.Decodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(urn: Swift.String?, name: Swift.String, themeId: NamiPairingFramework.ThemeID, iconId: NamiPairingFramework.IconID)
  #endif
  public var urn: Swift.String?
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_UpdatedDeviceUser, b: NamiPairingFramework.RemoteTemplateUI_UpdatedDeviceUser) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct RemoteTemplateUI_WiFiCredentialsUpdateSession : Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public init(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID, urn: Swift.String, zoneId: NamiPairingFramework.PlaceZoneID, status: NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateStatus, updatedDevices: [NamiPairingFramework.RemoteTemplateUI_UpdatedDevice], wifiUpdateSessionDevices: [NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsHoldingDevice])
  public var id: NamiPairingFramework.WiFiCredentialsUpdateSessionID
  public var urn: Swift.String
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var status: NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateStatus
  public var updatedDevices: [NamiPairingFramework.RemoteTemplateUI_UpdatedDevice]?
  public var wifiUpdateSessionDevices: [NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsHoldingDevice]?
  public static func == (a: NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, b: NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession) -> Swift.Bool
  public typealias ID = NamiPairingFramework.WiFiCredentialsUpdateSessionID
  public init(from decoder: any Swift.Decoder) throws
}
extension NamiPairingFramework.StateMessage : @retroactive Swift.Equatable, @retroactive Swift.Hashable, @retroactive Swift.Encodable {
  public static func == (lhs: NamiPairingFramework.StateMessage, rhs: NamiPairingFramework.StateMessage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension NamiPairingFramework.SecureStorage : NamiPairingFramework.SecureStorageProtocol, @retroactive NamiPairingFramework.ThreadSecureStorageProtocol {
  public typealias SecureStorageError = NamiPairingFramework.KeychainError
  public typealias Thread_SecureStorageError = NamiPairingFramework.KeychainError
}
final public class RemoteTemplateUIController<Storage, ThreadSecureStorage> : @preconcurrency NamiPairingFramework.RemoteTemplatesUIControllerProtocol, @unchecked Swift.Sendable where Storage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol, Storage : NamiPairingFramework.RemoteTemplateStateRepositoryProtocol, Storage : Swift.Sendable, ThreadSecureStorage : NamiPairingFramework.ThreadSecureStorageProtocol, ThreadSecureStorage : Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public init(store: Storage, secureStorage: ThreadSecureStorage.Type, deviceConnectionsManager: any NamiPairingFramework.DeviceConnectionsManagerProtocol, placeId: NamiPairingFramework.PlaceID? = nil)
  #endif
  final public let eventsPublisher: Combine.PassthroughSubject<NamiPairingFramework.SetupGuideEvent, NamiPairingFramework.SetupGuideError>
  @_Concurrency.MainActor final public func present(entrypoint: some RemoteTemplateEntrypointProtocol, placeId: NamiPairingFramework.PlaceID, config: any NamiPairingFramework.RemoteTemplateUIConfigProtocol) -> SwiftUICore.AnyView
  public typealias Error = NamiPairingFramework.SetupGuideError
  public typealias Event = NamiPairingFramework.SetupGuideEvent
  public typealias TemplatesView = SwiftUICore.AnyView
  @objc deinit
}
public protocol RemoteTemplatesUIControllerEvent {
}
public protocol RemoteTemplatesUIControllerError : Swift.Error {
}
public protocol RemoteTemplateUIConfigProtocol {
  var baseURL: Foundation.URL { get set }
  var countryCode: Swift.String { get set }
  var measurementSystem: NamiPairingFramework.NamiMeasurementSystem { get set }
  var clientId: Swift.String { get set }
  var language: Swift.String { get set }
  var appearance: NamiPairingFramework.NamiAppearance { get set }
  var topologyRoomsSupported: Swift.Bool { get set }
}
public protocol RemoteTemplateUI_WebAPIProtocol {
  associatedtype RepresentablePlace : NamiPairingFramework.PlaceProtocol
  associatedtype RepresentableZone : NamiPairingFramework.ZoneProtocol
  associatedtype RepresentableRoom : NamiPairingFramework.RoomProtocol
  associatedtype RepresentableMembershipResponse : NamiPairingFramework.MembershipResponseProtocol
  associatedtype RepresentableInvitePeek : NamiPairingFramework.InvitePeekProtocol
  associatedtype RepresentableDevice : NamiPairingFramework.DeviceProtocol
  associatedtype RepresentableDevicesQuery : NamiPairingFramework.DevicesQueryProtocol
  associatedtype RepresentableDevicesResponse : NamiPairingFramework.DevicesResponseProtocol
  associatedtype RepresentableDevicesCommandResponse : NamiPairingFramework.DevicesCommandResponseProtocol
  associatedtype RepresentablePlaceAutomation : NamiPairingFramework.AutomationProtocol
  associatedtype RepresentableZoneMotionEvent : NamiPairingFramework.ZoneMotionEventProtocol
  associatedtype RepresentablePlaceMotionHistory : NamiPairingFramework.PlaceMotionHistoryProtocol
  associatedtype RepresentablePlaceMotionAggregates : NamiPairingFramework.PlaceMotionAggregatesProtocol
  associatedtype RepresentableZoneMotionAggregates : NamiPairingFramework.ZoneMotionAggregatesProtocol
  associatedtype RepresentableInviteLink : NamiPairingFramework.InviteLinkProtocol
  associatedtype RepresentableRestEventsResponse : NamiPairingFramework.RestEventsResponseProtocol
  associatedtype RepresentableRestInsightsResponse : NamiPairingFramework.RestInsightsResponseProtocol
  associatedtype RepresentableDeviceAttributeStateResponse : NamiPairingFramework.DeviceAttributeStateResponseProtocol
  associatedtype RepresentablePlacesResponse : NamiPairingFramework.PlacesResponseProtocol
  associatedtype RepresentableAlertMode : NamiPairingFramework.AlertModeProtocol
  associatedtype RepresentableWiFiCredentialsUpdateSession : NamiPairingFramework.WiFiCredentialsUpdateSessionProtocol
  associatedtype RepresentableWiFiCredentialsUpdateSessionResponse : NamiPairingFramework.WiFiCredentialsUpdateSessionResponseProtocol
  func leavePlace(id: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.RepresentablePlacesResponse, any Swift.Error>
  func deletePlace(id: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func deletePlaceZone(in placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<Self.RepresentablePlace, any Swift.Error>
  func deletePlaceRoom(in placeId: NamiPairingFramework.PlaceID, roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<Self.RepresentablePlace, any Swift.Error>
  func listPlaceMembers(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.RepresentableMembershipResponse, any Swift.Error>
  func deletePlaceUser(from placeId: NamiPairingFramework.PlaceID, user userId: NamiPairingFramework.UserID) -> Combine.AnyPublisher<Self.RepresentableMembershipResponse, any Swift.Error>
  func updatePlaceUser(for placeId: NamiPairingFramework.PlaceID, userId: NamiPairingFramework.UserID, roleId: Swift.String) -> Combine.AnyPublisher<Self.RepresentableMembershipResponse, any Swift.Error>
  func revokeInvite(code: NamiPairingFramework.InviteCode, from placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.RepresentableMembershipResponse, any Swift.Error>
  func invitationDetails(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<Self.RepresentableInvitePeek, any Swift.Error>
  func acceptInvitation(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<Self.RepresentablePlacesResponse, any Swift.Error>
  func declineInvitation(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func createZone(place: NamiPairingFramework.PlaceID, name: Swift.String) -> Combine.AnyPublisher<Self.RepresentableZone, any Swift.Error>
  func updateZone(id: NamiPairingFramework.PlaceZoneID, name: Swift.String) -> Combine.AnyPublisher<Self.RepresentableZone, any Swift.Error>
  func createRoom(zone: NamiPairingFramework.PlaceZoneID, name: Swift.String, icon: NamiPairingFramework.IconID) -> Combine.AnyPublisher<Self.RepresentableRoom, any Swift.Error>
  func updateRoom(id: NamiPairingFramework.RoomID, name: Swift.String, icon: NamiPairingFramework.IconID) -> Combine.AnyPublisher<Self.RepresentableRoom, any Swift.Error>
  func listDevices(query: Self.RepresentableDevicesQuery) -> Combine.AnyPublisher<Self.RepresentableDevicesResponse, any Swift.Error>
  func deleteDevice(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func moveDevices(deviceUIDs: [NamiPairingFramework.DeviceUniversalID], roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<[Self.RepresentableDevice], any Swift.Error>
  func renameDevice(id: NamiPairingFramework.DeviceID, name: Swift.String) -> Combine.AnyPublisher<Self.RepresentableDevice, any Swift.Error>
  func sendDeviceCommandRequests(in placeId: NamiPairingFramework.PlaceID, uids: [NamiPairingFramework.DeviceUniversalID], messages: [Foundation.Data]) -> Combine.AnyPublisher<Self.RepresentableDevicesCommandResponse, any Swift.Error>
  func listAutomation(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Self.RepresentablePlaceAutomation], any Swift.Error>
  func createAutomation(placeId: NamiPairingFramework.PlaceID, alertMode: Self.RepresentableAlertMode, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<Self.RepresentablePlaceAutomation, any Swift.Error>
  func updateAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, alertMode: Self.RepresentableAlertMode, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<Self.RepresentablePlaceAutomation, any Swift.Error>
  func changeAutomationActive(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, active: Swift.Bool) -> Combine.AnyPublisher<Self.RepresentablePlaceAutomation, any Swift.Error>
  func removeAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<Self.RepresentablePlaceAutomation, any Swift.Error>
  func getPlaceMotionHistory(for placeId: NamiPairingFramework.PlaceID, from: Foundation.Date) -> Combine.AnyPublisher<Self.RepresentablePlaceMotionHistory, any Swift.Error>
  func getZoneMotionHistory(for zoneIds: [NamiPairingFramework.PlaceZoneID], from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<[Self.RepresentableZoneMotionEvent], any Swift.Error>
  func getPlaceMotionDataAggregates(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Self.RepresentablePlaceMotionAggregates, any Swift.Error>
  func getZoneMotionDataAggregates(for zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<Self.RepresentableZoneMotionAggregates, any Swift.Error>
  func generateInvite(to place: NamiPairingFramework.PlaceID, invitee name: Swift.String, roleId: Swift.String) -> Combine.AnyPublisher<Self.RepresentableInviteLink, any Swift.Error>
  func getRestHistory(roomId: NamiPairingFramework.RoomID, from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<Self.RepresentableRestEventsResponse, any Swift.Error>
  func getRestInsights(roomId: NamiPairingFramework.RoomID, day: Foundation.Date) -> Combine.AnyPublisher<Self.RepresentableRestInsightsResponse, any Swift.Error>
  func createWiFiCredentialsUpdateSession(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<Self.RepresentableWiFiCredentialsUpdateSession, any Swift.Error>
  func getAllWiFiCredentialsUpdateSessions() -> Combine.AnyPublisher<Self.RepresentableWiFiCredentialsUpdateSessionResponse, any Swift.Error>
  func getWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<Self.RepresentableWiFiCredentialsUpdateSession, any Swift.Error>
  func deleteDeviceFromSession(uid: NamiPairingFramework.DeviceUniversalID, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<Self.RepresentableWiFiCredentialsUpdateSession, any Swift.Error>
  func resetWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<Self.RepresentableWiFiCredentialsUpdateSession, any Swift.Error>
  func createOrResetWiFiCredentialsUpdateSession(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<Self.RepresentableWiFiCredentialsUpdateSession, any Swift.Error>
}
public protocol RemoteTemplatesUIControllerProtocol {
  associatedtype Storage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol, NamiPairingFramework.RemoteTemplateStateRepositoryProtocol
  associatedtype ThreadSecureStorage : NamiPairingFramework.ThreadSecureStorageProtocol
  associatedtype Event : NamiPairingFramework.RemoteTemplatesUIControllerEvent
  associatedtype Error : NamiPairingFramework.RemoteTemplatesUIControllerError
  associatedtype TemplatesView : SwiftUICore.View
  #if compiler(>=5.3) && $NonescapableTypes
  init(store: Self.Storage, secureStorage: Self.ThreadSecureStorage.Type, deviceConnectionsManager: any NamiPairingFramework.DeviceConnectionsManagerProtocol, placeId: NamiPairingFramework.PlaceID?)
  #endif
  @_Concurrency.MainActor func present(entrypoint: some RemoteTemplateEntrypointProtocol, placeId: NamiPairingFramework.PlaceID, config: any NamiPairingFramework.RemoteTemplateUIConfigProtocol) -> Self.TemplatesView
  var eventsPublisher: Combine.PassthroughSubject<Self.Event, Self.Error> { get }
}
public protocol RemoteTemplateStateRepositoryProtocol {
  func place(id placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Place, Swift.Never>
  func zones(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Zone], Swift.Never>
  func rooms(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Room], Swift.Never>
  func rooms(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Room], Swift.Never>
  #if compiler(>=5.3) && $NonescapableTypes
  func device(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func device(urn: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func device(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Device?, Swift.Never>
  #endif
  func devices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  func devices(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  func devices(roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_Device], Swift.Never>
  func devicesPerZone(in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZoneID : [NamiPairingFramework.RemoteTemplateUI_Device]], Swift.Never>
  func deviceModel(productId: NamiPairingFramework.DeviceProductID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDeviceModel, Swift.Never>
  func deviceModel(codeName: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.NamiDeviceModel, Swift.Never>
  #if compiler(>=5.3) && $NonescapableTypes
  func deviceState(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_DeviceState?, Swift.Never>
  #endif
  func deviceStates(uids: [NamiPairingFramework.DeviceUniversalID]) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_DeviceState], Swift.Never>
  func refreshPlace(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func refreshDevices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func createZone(placeId: NamiPairingFramework.PlaceID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZoneID, any Swift.Error>
  func createRoom(placeZoneId: NamiPairingFramework.PlaceZoneID, name: Swift.String, iconId: NamiPairingFramework.IconID) -> Combine.AnyPublisher<NamiPairingFramework.RoomID, any Swift.Error>
  func deleteDevice(uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func deleteZone(_ zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func deleteRoom(_ roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Place, any Swift.Error>
  func listPins(in place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.RemoteTemplateUI_PinCredentialRecord], any Swift.Error>
  func verifyPin(for place: NamiPairingFramework.PlaceID, pinNamed name: Swift.String, pinValue: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_PinVerificationResult, any Swift.Error>
  func createPin(for place: NamiPairingFramework.PlaceID, pinNamed name: Swift.String, pinValue: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_PinCredentialRecord, any Swift.Error>
  func deletePin(from place: NamiPairingFramework.PlaceID, pinId: NamiPairingFramework.PinCredentialID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_PinCredentialRecord, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  func updatePin(in place: NamiPairingFramework.PlaceID, pinId: NamiPairingFramework.PinCredentialID, newName: Swift.String?, newValue: Swift.String?) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_PinCredentialRecord, any Swift.Error>
  #endif
  func updateEntryExitDelay(_ placeId: NamiPairingFramework.PlaceID, entryDelay: NamiPairingFramework.EntryDelay, exitDelay: NamiPairingFramework.ExitDelay) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_Place, any Swift.Error>
  func updateSensitivity(_ placeId: NamiPairingFramework.PlaceID, sensitivity: Swift.Int) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func createWiFiCredentialsUpdateSession(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, any Swift.Error>
  func getAllWiFiCredentialsUpdateSessions() -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsSessionsResponse, any Swift.Error>
  func getWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, any Swift.Error>
  func deleteDeviceFromSession(uid: NamiPairingFramework.DeviceUniversalID, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, any Swift.Error>
  func resetWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, any Swift.Error>
  func createOrResetWiFiCredentialsUpdateSession(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateSession, any Swift.Error>
}
public class Animations {
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  public var lookout24Logo: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var emptyPlaceState: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var widarPositioningRec: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var widarPositioningExample: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var widarPositioningOptimised: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var widarPositioningDone: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var alarmPodPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var sensePodPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var sensePlugDEPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var sensePlugFRPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var sensePlugUKPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var sensePlugUSPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var sensePlugJPPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var widarPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var wifiSensorDEPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var wifiSensorFRPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var wifiSensorJPPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var wifiSensorUKPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var wifiSensorUSPulseDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var contactSensorPulsingDarkBlue: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var doorSensorPulseWhite: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var keypadPulseWhite: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var motionSensorPulseWhite: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var zoneGuide1ExpandZone: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var zoneGuide2CreateNewZone: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var zoneGuide3Secure2ndFloor: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var bssFirstKitZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var bssNonFirstKitOneFloorZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var bssNonFirstKitMultiFloorZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var hmsFirstKitZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var hmsNonFirstKitOneFloorZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var hmsNonFirstKitMultiFloorZoneIntroduction: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var planDevicePlacementNonFirstHasBRMetric: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var planDevicePlacementNonFirstHasBRImperial: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var bssFirstKitSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var bssNonFirstKitNoBRSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var bssNonFirstKitHasBRSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var hmsFirstKitSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var hmsNonFirstKitNoBRSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var hmsNonFirstKitHasBRSetupMotionSensing: Lottie.LottieAnimation! {
    get
  }
  #endif
  @objc deinit
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func applyingAppearance() -> some SwiftUICore.View
  
}
public struct AppearanceKey : SwiftUICore.EnvironmentKey {
  public static let defaultValue: NamiPairingFramework.NamiAppearance
  public typealias Value = NamiPairingFramework.NamiAppearance
}
extension SwiftUICore.EnvironmentValues {
  public var appearance: NamiPairingFramework.NamiAppearance {
    get
    set
  }
}
extension SwiftUICore.Color {
  public init(hex: Swift.UInt, alpha: Swift.Double = 1.0)
  public static var namiColors: NamiPairingFramework.Colors
  public static var systemBackground: SwiftUICore.Color {
    get
  }
  public static var textLabel: SwiftUICore.Color {
    get
  }
  public static var invertedTextLabel: SwiftUICore.Color {
    get
  }
  public static var tint: SwiftUICore.Color {
    get
  }
}
public struct ColorsKey : SwiftUICore.EnvironmentKey {
  public static let defaultValue: NamiPairingFramework.Colors
  public typealias Value = NamiPairingFramework.Colors
}
extension SwiftUICore.EnvironmentValues {
  public var colors: NamiPairingFramework.Colors {
    get
    set
  }
}
extension UIKit.UIImage {
  public enum AnimatableImageFormat : Swift.String {
    case gif
    case webP
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    @available(iOS 2.0, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public enum DeviceImages {
  public static func image(for codeName: Swift.String) -> NamiPairingFramework.AnimatableImageView
  public static func image(for model: NamiPairingFramework.NamiDeviceModel) -> NamiPairingFramework.AnimatableImageView
}
public enum DeviceQRCodeLocationImages {
  public static func qrCodeLocationImage(for name: Swift.String) -> NamiPairingFramework.AnimatableImageView
}
extension SwiftUICore.Image {
  public static func webp(_ name: Swift.String) -> SwiftUICore.Image
  public static func webp(_ name: Swift.String, in bundle: Foundation.Bundle) -> SwiftUICore.Image
}
@_Concurrency.MainActor @preconcurrency public struct AnimatableImageView : SwiftUI.UIViewRepresentable {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init?(webP: Swift.String, in bundle: Foundation.Bundle)
  #endif
  @_Concurrency.MainActor @preconcurrency public init(uiImage: UIKit.UIImage)
  @_Concurrency.MainActor @preconcurrency public func makeUIView(context: NamiPairingFramework.AnimatableImageView.Context) -> UIKit.UIImageView
  @_Concurrency.MainActor @preconcurrency public func updateUIView(_ uiView: UIKit.UIImageView, context: NamiPairingFramework.AnimatableImageView.Context)
  @_Concurrency.MainActor @preconcurrency public func resizable() -> some SwiftUICore.View
  
  public typealias Body = Swift.Never
  public typealias Coordinator = Swift.Void
  public typealias UIViewType = UIKit.UIImageView
}
public struct Icons {
  public static let bluetooth: SwiftUICore.Image
  public static let camera: SwiftUICore.Image
  public static let checkmark: SwiftUICore.Image
  public static let chevronleft: SwiftUICore.Image
  public static let errorindicator: SwiftUICore.Image
  public static let eyeclosed: SwiftUICore.Image
  public static let eyeopen: SwiftUICore.Image
  public static let question: SwiftUICore.Image
  public static let warning: SwiftUICore.Image
  public static let warningPurple: SwiftUICore.Image
  public static let wifi: SwiftUICore.Image
  public static let wifierror: SwiftUICore.Image
  public static let wifimedium: SwiftUICore.Image
  public static let wifiweak: SwiftUICore.Image
  public static let greenTick: SwiftUICore.Image
  public static let xmark: SwiftUICore.Image
  public static let expand: SwiftUICore.Image
  public static let info: SwiftUICore.Image
  public static let infoBlue: SwiftUICore.Image
  public static let redCross: SwiftUICore.Image
}
extension SwiftUICore.Color {
  public init(rgba: Swift.UInt)
}
public enum ColorPrimitive : Swift.String, Swift.CaseIterable {
  case brand400
  case brand500
  case white300
  case white500
  case white700
  case white900
  case black100
  case black150
  case black200
  case black400
  case black500
  case black700
  case black800
  case black900
  case red100
  case red300
  case red700
  case red900
  case green100
  case green300
  case green700
  case green900
  case yellow100
  case yellow300
  case yellow700
  case yellow900
  case blue100
  case blue300
  case blue700
  case blue900
  case maroon100
  case maroon300
  case maroon700
  case maroon900
  case purple100
  case purple300
  case purple700
  case purple900
  case arctic300
  case arctic700
  case sunset300
  case sky300
  case lavender300
  case pine300
  case securityModeBlue
  case securityModeOrange
  case securityModeGreen
  case securityModeRed
  public var color: SwiftUICore.Color {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias AllCases = [NamiPairingFramework.ColorPrimitive]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [NamiPairingFramework.ColorPrimitive] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public class Colors : Foundation.ObservableObject {
  public init(appearance: NamiPairingFramework.NamiAppearance = .system)
  final public let appearance: NamiPairingFramework.NamiAppearance
  public var backgroundDefaultPrimary: SwiftUICore.Color {
    get
  }
  public var backgroundDefaultSecondary: SwiftUICore.Color {
    get
  }
  public var backgroundDefaultTertiary: SwiftUICore.Color {
    get
  }
  public var backgroundBrandPrimary: SwiftUICore.Color {
    get
  }
  public var backgroundDefaultInvert: SwiftUICore.Color {
    get
  }
  public var backgroundBrandSecondary: SwiftUICore.Color {
    get
  }
  public var backgroundDangerPrimary: SwiftUICore.Color {
    get
  }
  public var backgroundDangerSecondary: SwiftUICore.Color {
    get
  }
  public var backgroundDangerHover: SwiftUICore.Color {
    get
  }
  public var backgroundWarningPrimary: SwiftUICore.Color {
    get
  }
  public var backgroundAlertPrimary: SwiftUICore.Color {
    get
  }
  public var backgroundPositivePrimary: SwiftUICore.Color {
    get
  }
  public var backgroundPositiveSecondary: SwiftUICore.Color {
    get
  }
  public var backgroundPlaceArctic: SwiftUICore.Color {
    get
  }
  public var backgroundSecuritymodeBlue: SwiftUICore.Color {
    get
  }
  public var backgroundSecuritymodeOrange: SwiftUICore.Color {
    get
  }
  public var backgroundSecuritymodeGreen: SwiftUICore.Color {
    get
  }
  public var backgroundSecurityModeRed: SwiftUICore.Color {
    get
  }
  public var backgroundPlaceSunset: SwiftUICore.Color {
    get
  }
  public var backgroundPlaceSky: SwiftUICore.Color {
    get
  }
  public var backgroundPlaceLavender: SwiftUICore.Color {
    get
  }
  public var backgroundPlacePine: SwiftUICore.Color {
    get
  }
  public var backgroundGraphNomotion: SwiftUICore.Color {
    get
  }
  public var backgroundGraphMotion: SwiftUICore.Color {
    get
  }
  public var backgroundGraphNopresence: SwiftUICore.Color {
    get
  }
  public var backgroundGraphPresence: SwiftUICore.Color {
    get
  }
  public var backgroundGraphAwake: SwiftUICore.Color {
    get
  }
  public var backgroundGraphRest: SwiftUICore.Color {
    get
  }
  public var iconBrandPrimary: SwiftUICore.Color {
    get
  }
  public var iconDefaultPrimary: SwiftUICore.Color {
    get
  }
  public var iconDefaultSecondary: SwiftUICore.Color {
    get
  }
  public var iconDefaultTertiary: SwiftUICore.Color {
    get
  }
  public var iconDefaultInvert: SwiftUICore.Color {
    get
  }
  public var iconDisabledPrimary: SwiftUICore.Color {
    get
  }
  public var iconDisabledSecondary: SwiftUICore.Color {
    get
  }
  public var iconDangerPrimary: SwiftUICore.Color {
    get
  }
  public var iconDangerContrast: SwiftUICore.Color {
    get
  }
  public var iconWarningPrimary: SwiftUICore.Color {
    get
  }
  public var iconAlertPrimary: SwiftUICore.Color {
    get
  }
  public var iconPositivePrimary: SwiftUICore.Color {
    get
  }
  public var iconSecuritymodeBlue: SwiftUICore.Color {
    get
  }
  public var iconSecuritymodeOrange: SwiftUICore.Color {
    get
  }
  public var iconSecuritymodeGreen: SwiftUICore.Color {
    get
  }
  public var iconSecurityModeRed: SwiftUICore.Color {
    get
  }
  public var textDefaultPrimary: SwiftUICore.Color {
    get
  }
  public var textDefaultSecondary: SwiftUICore.Color {
    get
  }
  public var textDefaultTertiary: SwiftUICore.Color {
    get
  }
  public var textDefaultContrast: SwiftUICore.Color {
    get
  }
  public var textBrandPrimary: SwiftUICore.Color {
    get
  }
  public var textDisabledPrimary: SwiftUICore.Color {
    get
  }
  public var textDisabledSecondary: SwiftUICore.Color {
    get
  }
  public var textDangerPrimary: SwiftUICore.Color {
    get
  }
  public var textDangerContrast: SwiftUICore.Color {
    get
  }
  public var textWarningPrimary: SwiftUICore.Color {
    get
  }
  public var textAlertPrimary: SwiftUICore.Color {
    get
  }
  public var textAlertSecondary: SwiftUICore.Color {
    get
  }
  public var textPositivePrimary: SwiftUICore.Color {
    get
  }
  public var textPositiveContrast: SwiftUICore.Color {
    get
  }
  public var textSecuritymodeOrange: SwiftUICore.Color {
    get
  }
  public var textSecuritymodeBlue: SwiftUICore.Color {
    get
  }
  public var textSecuritymodeGreen: SwiftUICore.Color {
    get
  }
  public var borderBrandPrimary: SwiftUICore.Color {
    get
  }
  public var borderBrandSecondary: SwiftUICore.Color {
    get
  }
  public var borderDefaultPrimary: SwiftUICore.Color {
    get
  }
  public var borderDefaultSecondary: SwiftUICore.Color {
    get
  }
  public var borderDefaultTertiary: SwiftUICore.Color {
    get
  }
  public var borderDangerPrimary: SwiftUICore.Color {
    get
  }
  public var borderWarningPrimary: SwiftUICore.Color {
    get
  }
  public var borderAlertPrimary: SwiftUICore.Color {
    get
  }
  public var borderPositivePrimary: SwiftUICore.Color {
    get
  }
  public enum ColorSaturation : Swift.String, Swift.CaseIterable {
    case lite, normal, saturated, striking
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [NamiPairingFramework.Colors.ColorSaturation]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [NamiPairingFramework.Colors.ColorSaturation] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let allThemes: [NamiPairingFramework.ThemeID]
  public func forTheme(_ base: NamiPairingFramework.ThemeID, saturation: NamiPairingFramework.Colors.ColorSaturation = .normal) -> SwiftUICore.Color
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
public struct URLLinks {
  public static let FAQNotPulsingBlue: Swift.String
  public static let FAQNamiThreadTopology: Swift.String
  public static let FAQNotConnectToThread: Swift.String
}
extension Lottie.LottieAnimation {
  final public func animationView(looping: Lottie.LottieLoopMode = .loop) -> some SwiftUICore.View
  
}
public enum BonjourBrowserStatus : Swift.Equatable {
  case ready
  case searching
  case failed(NamiPairingFramework.BonjourBrowserError)
  public static func == (a: NamiPairingFramework.BonjourBrowserStatus, b: NamiPairingFramework.BonjourBrowserStatus) -> Swift.Bool
}
public enum BonjourBrowserError : Swift.Error, Swift.Equatable {
  case permissionDenied
  case notPermitted
  case defunctConnection
  case other(Swift.String)
  public static func == (a: NamiPairingFramework.BonjourBrowserError, b: NamiPairingFramework.BonjourBrowserError) -> Swift.Bool
}
public struct NamiDevicesEndpoint : Swift.Hashable {
  public init(uid: NamiPairingFramework.DeviceUniversalID, endpoint: Network.NWEndpoint, isAccessible: Swift.Bool = true)
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(browserResult: Network.NWBrowser.Result, isAccessible: Swift.Bool = true)
  #endif
  public let uid: NamiPairingFramework.DeviceUniversalID
  public let endpoint: Network.NWEndpoint
  public let isAccessible: Swift.Bool
  public static func == (a: NamiPairingFramework.NamiDevicesEndpoint, b: NamiPairingFramework.NamiDevicesEndpoint) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol BonjourServiceDiscoveryProtocol : AnyObject {
  static func subscribeOnResults(for service: Swift.String) -> NamiPairingFramework.BonjourPublisher
  static func subscribeOnStatus(for service: Swift.String) -> NamiPairingFramework.BonjourStatusPublisher
}
@_hasMissingDesignatedInitializers final public class BonjourServiceDiscovery : NamiPairingFramework.BonjourServiceDiscoveryProtocol {
  public static func subscribeOnResults(for service: Swift.String) -> NamiPairingFramework.BonjourPublisher
  public static func subscribeOnStatus(for service: Swift.String) -> NamiPairingFramework.BonjourStatusPublisher
  @objc deinit
}
public typealias BonjourPublisher = Combine.AnyPublisher<Swift.Set<NamiPairingFramework.NamiDevicesEndpoint>, any Swift.Error>
public typealias BonjourStatusPublisher = Combine.AnyPublisher<NamiPairingFramework.BonjourBrowserStatus, Swift.Never>
extension Combine.AnyPublisher where Output == Swift.Set<NamiPairingFramework.NamiDevicesEndpoint>, Failure == any Swift.Error {
  #if compiler(>=5.3) && $NonescapableTypes
  public func endpoint(for uid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<NamiPairingFramework.NamiDevicesEndpoint?, any Swift.Error>
  #endif
}
extension Combine.AnyCancellable {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  final public func store(in set: inout NamiPairingFramework.SyncSet<Combine.AnyCancellable>)
}
extension Combine.PassthroughSubject where Output == NamiPairingFramework.NamiDeviceObservation, Failure == Swift.Never {
  final public func deviceObservations(for deviceUid: NamiPairingFramework.DeviceUniversalID) -> Combine.AnyPublisher<Output, Failure>
  final public func deviceObservations(for deviceUids: [NamiPairingFramework.DeviceUniversalID]) -> Combine.AnyPublisher<Output, Failure>
}
public class DeviceConnectionsManager<Storage, API> : NamiPairingFramework.DeviceConnectionsManagerProtocol where Storage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol, API : NamiPairingFramework.DeviceConnectionsManagerWebAPIProtocol {
  required convenience public init(storage: Storage, api: API)
  public init(storage: Storage, api: API, bonjourPublisher: NamiPairingFramework.BonjourPublisher, coapInitializer: @escaping ([any NamiPairingFramework.PlaceKeyProtocol]) -> any NamiPairingFramework.CoAPConnectionsProtocol)
  convenience public init(storage: Storage, bonjourPublisher: NamiPairingFramework.BonjourPublisher, api: API, coapInitializer: @escaping ([any NamiPairingFramework.PlaceKeyProtocol]) -> any NamiPairingFramework.CoAPConnectionsProtocol = CoAPConnections.init)
  @objc deinit
  public static var logging: Swift.Bool {
    get
  }
  final public let publisher: Combine.PassthroughSubject<NamiPairingFramework.NamiDeviceObservation, Swift.Never>
  public func deviceStateRequest(to device: NamiPairingFramework.DeviceUniversalID, connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Foundation.Data, any Swift.Error>
  public func devicesStateRequest(connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Foundation.Data], any Swift.Error>
  public enum PlaceThreadCredentialsAcquisitionError : Swift.Error {
    case allChecksFailed([any Swift.Error])
  }
  public func threadCredentialsRequest(to deviceUid: NamiPairingFramework.DeviceUniversalID, connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<any NamiPairingFramework.ThreadCredentialsMessageProtocol, any Swift.Error>
  public func threadCredentialsRequest(connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[any NamiPairingFramework.ThreadCredentialsMessageProtocol], any Swift.Error>
  public func sendControlMessage(_ controlMessage: any NamiPairingFramework.DeviceControlMessageProtocol, for capability: NamiPairingFramework.NamiDeviceCapability, uid: NamiPairingFramework.DeviceUniversalID, in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<any NamiPairingFramework.DevicesCommandResponseProtocol, any Swift.Error>
  public func sendCloudControlMessage(_ controlMessage: any NamiPairingFramework.DeviceControlMessageProtocol, for capability: NamiPairingFramework.NamiDeviceCapability, uid: NamiPairingFramework.DeviceUniversalID, in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<any NamiPairingFramework.DevicesCommandResponseProtocol, any Swift.Error>
  public func addToCloudObserved(placeId: NamiPairingFramework.PlaceID)
  public func removeFromCloudObserved(placeId: NamiPairingFramework.PlaceID)
}
public enum DeviceConnectionsManagerCommunicationError : Swift.RawRepresentable {
  case emptyPayload(NamiPairingFramework.SCMessage)
  case missingEndpoint
  case missingObservationManager
  case coapInitFailed
  case localControlSendTimeout
  case localStateRequestTimeout
  case localObservationTimeout
  case cloudStatePayloadMalformed
  case cloudMessageSendFailed(any Swift.Error)
  case cloudControlResponseMissing(NamiPairingFramework.DeviceUniversalID)
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue _: Foundation.NSError)
  #endif
  public typealias RawValue = Foundation.NSError
  public var rawValue: NamiPairingFramework.DeviceConnectionsManagerCommunicationError.RawValue {
    get
  }
  public static func errorThrowingPublisher<Output>(for error: NamiPairingFramework.DeviceConnectionsManagerCommunicationError) -> Combine.AnyPublisher<Output, any Swift.Error>
}
public typealias DoorSensorState = NamiPairingFramework.StateMessage.EndpointState.DoorSensorState
public typealias PowerSupplyInfo = NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo
public struct DeviceConnectionsManager_DevicesQuery : NamiPairingFramework.DevicesQueryProtocol {
  public var placeIds: [NamiPairingFramework.PlaceID]
  public var zoneIds: [NamiPairingFramework.PlaceZoneID]
  public var roomIds: [NamiPairingFramework.RoomID]
  public var uids: [NamiPairingFramework.DeviceUniversalID]
  public var cursor: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(placeIds: [NamiPairingFramework.PlaceID] = [], zoneIds: [NamiPairingFramework.PlaceZoneID] = [], roomIds: [NamiPairingFramework.RoomID] = [], uids: [NamiPairingFramework.DeviceUniversalID] = [], cursor: Swift.String? = nil)
  #endif
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension NamiPairingFramework.DeviceConnectionsManager_DevicesQuery {
  public static func forPlace(_ placeId: NamiPairingFramework.PlaceID, deviceUIDs: [NamiPairingFramework.DeviceUniversalID] = []) -> NamiPairingFramework.DeviceConnectionsManager_DevicesQuery
  public static func forDevices(_ deviceUIDs: [NamiPairingFramework.DeviceUniversalID]) -> NamiPairingFramework.DeviceConnectionsManager_DevicesQuery
}
public struct NamiDeviceObservation {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(uid: NamiPairingFramework.DeviceUniversalID, seqTime: Swift.UInt64, activity: [Swift.Int32]? = nil, peers: [NamiPairingFramework.DevicePeerInfo]? = nil, state: NamiPairingFramework.StateMessage? = nil, error: (any Swift.Error)? = nil)
  #endif
  public let uid: NamiPairingFramework.DeviceUniversalID
  public let seqTime: Swift.UInt64
  public let activity: [Swift.Int32]?
  public let peers: [NamiPairingFramework.DevicePeerInfo]?
  public let state: NamiPairingFramework.StateMessage?
  public let error: (any Swift.Error)?
  public let data: Foundation.Data
  public let receivedAt: Foundation.Date
}
extension NamiPairingFramework.NamiDeviceModel {
  public func controlMessageType(for capability: NamiPairingFramework.NamiDeviceCapability) throws -> any NamiPairingFramework.DeviceControlMessageProtocol.Type
}
extension NamiPairingFramework.NamiDeviceCapability {
  public func controlMessageType() throws -> any NamiPairingFramework.DeviceControlMessageProtocol.Type
  public enum ControlMessgeError : Swift.Error {
    case noMessageType
    public static func == (a: NamiPairingFramework.NamiDeviceCapability.ControlMessgeError, b: NamiPairingFramework.NamiDeviceCapability.ControlMessgeError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct RelayOnOffMessage : NamiPairingFramework.DeviceControlMessageProtocol {
  public init(isOn: Swift.Bool)
  public var messageType: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public func encode() throws -> Foundation.Data
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SirenOnOffMessage : NamiPairingFramework.DeviceControlMessageProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(isOn: Swift.Bool, duration: Swift.UInt16? = nil)
  #endif
  public var messageType: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public func encode() throws -> Foundation.Data
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DevkitLEDControlMessage : NamiPairingFramework.DeviceControlMessageProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(isOn: Swift.Bool? = nil, lightingLevel: Swift.UInt8? = nil, onLevel: Swift.UInt8? = nil, levelTransitionTime: Swift.UInt16? = nil, colorTemperature: Swift.UInt16? = nil, colorTransitionTime: Swift.UInt16? = nil)
  #endif
  public var messageType: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public func encode() throws -> Foundation.Data
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WiDarControlMessage : NamiPairingFramework.DeviceControlMessageProtocol {
  public init(isPositioning: Swift.Bool)
  public var messageType: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public func encode() throws -> Foundation.Data
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WifiSensingControlMessage : NamiPairingFramework.DeviceControlMessageProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(reportCsi: Swift.Bool? = nil, motionReportingMode: NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.MotionReportingMode? = nil, sensingPeers: NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.SensingPeers? = nil)
  #endif
  public var messageType: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public func encode() throws -> Foundation.Data
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ThreadCredentialsMessage : Swift.Codable, Swift.Equatable, NamiPairingFramework.ThreadCredentialsMessageProtocol {
  public var panId: Swift.UInt16
  public var extendedPanId: Foundation.Data
  public var networkName: Swift.String
  public var channel: Swift.UInt8
  public var borderAgentID: Foundation.Data
  public var operationalDataset: Foundation.Data
  public var pskc: Foundation.Data
  public var masterKey: Foundation.Data
  public var meshLocalPrefix: Foundation.Data
  public var panID: Swift.UInt32 {
    get
  }
  public var extendedPanID: Swift.UInt64 {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
  public init(anyMessage: any NamiPairingFramework.ThreadCredentialsMessageProtocol)
  public static func == (a: NamiPairingFramework.ThreadCredentialsMessage, b: NamiPairingFramework.ThreadCredentialsMessage) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct StateMessage {
  public struct EndpointState {
    public enum OnOff {
      case unknown
      case on
      case off
      public static func == (a: NamiPairingFramework.StateMessage.EndpointState.OnOff, b: NamiPairingFramework.StateMessage.EndpointState.OnOff) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Warning {
      case unknown
      case inactive
      case intrusion
      public static func == (a: NamiPairingFramework.StateMessage.EndpointState.Warning, b: NamiPairingFramework.StateMessage.EndpointState.Warning) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct ColorControl {
      public var colorTemperatureMireds: Swift.UInt32
    }
    public struct LightingLevel {
      public var current: Swift.UInt32
      public var on: Swift.UInt32
    }
    public struct DeviceInfo {
      public var appVersion: Swift.String
    }
    public struct WiFiInfo {
      public var ssid: Foundation.Data
      public var bssid: Foundation.Data
      public var rssi: Swift.Int32
      public var channel: Swift.UInt32
    }
    public struct ThreadInfo {
      public var panId: Swift.UInt32
    }
    public struct WiDarInfo {
      public enum PositioningQuality {
        case unknown
        case good
        case degraded
        case poor
        public static func == (a: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningQuality, b: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningQuality) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      public enum PositioningProcessState {
        case unknown
        case started
        case stopped
        public static func == (a: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningProcessState, b: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningProcessState) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      public var positioningQuality: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningQuality
      public var positioningProcess: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningProcessState
    }
    public enum DoorSensorState {
      case open
      case closed
      public static func == (a: NamiPairingFramework.StateMessage.EndpointState.DoorSensorState, b: NamiPairingFramework.StateMessage.EndpointState.DoorSensorState) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct PowerSupplyInfo {
      public enum BatteryState {
        case unspecified
        case normal
        case low
        public static func == (a: NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo.BatteryState, b: NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo.BatteryState) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      public var batteryState: NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo.BatteryState
      public var batteryValue: Swift.UInt32
    }
    public struct MotionSensingConfig {
      public struct SensingPeers : Swift.Codable {
        public struct Peer : Swift.Codable {
          public enum Config : Swift.Codable {
            case AerialEngineV1(NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.SensingPeers.Peer.AEMotionV1Config)
            public func encode(to encoder: any Swift.Encoder) throws
            public init(from decoder: any Swift.Decoder) throws
          }
          public struct AEMotionV1Config : Swift.Codable {
            public var reportActivityLevels: Swift.Bool
            public init(reportActivityLevels: Swift.Bool)
            public func encode(to encoder: any Swift.Encoder) throws
            public init(from decoder: any Swift.Decoder) throws
          }
          public var conf: NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.SensingPeers.Peer.Config
          public var wifiMac: Swift.UInt64
          public init(conf: NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.SensingPeers.Peer.Config, wifiMac: Swift.UInt64)
          public func encode(to encoder: any Swift.Encoder) throws
          public init(from decoder: any Swift.Decoder) throws
        }
        public var peers: [NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.SensingPeers.Peer]
        public init(peers: [NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.SensingPeers.Peer])
        public func encode(to encoder: any Swift.Encoder) throws
        public init(from decoder: any Swift.Decoder) throws
      }
      public enum MotionReportingMode : Swift.CaseIterable, Swift.Hashable, Swift.Codable {
        case unspecified
        case mode1s
        case mode20s
        public static func == (a: NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.MotionReportingMode, b: NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.MotionReportingMode) -> Swift.Bool
        public typealias AllCases = [NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.MotionReportingMode]
        nonisolated public static var allCases: [NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.MotionReportingMode] {
          get
        }
        public func encode(to encoder: any Swift.Encoder) throws
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
        public init(from decoder: any Swift.Decoder) throws
      }
      public var reportCsi: Swift.Bool
      public var motionReportingMode: NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.MotionReportingMode
      public var sensingPeers: NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig.SensingPeers
    }
    public var onOff: NamiPairingFramework.StateMessage.EndpointState.OnOff
    public var warning: NamiPairingFramework.StateMessage.EndpointState.Warning
    public var colorControl: NamiPairingFramework.StateMessage.EndpointState.ColorControl?
    public var lightingLevel: NamiPairingFramework.StateMessage.EndpointState.LightingLevel?
    public var deviceInfo: NamiPairingFramework.StateMessage.EndpointState.DeviceInfo?
    public var wiFiInfo: NamiPairingFramework.StateMessage.EndpointState.WiFiInfo?
    public var threadInfo: NamiPairingFramework.StateMessage.EndpointState.ThreadInfo?
    public var widarInfo: NamiPairingFramework.StateMessage.EndpointState.WiDarInfo?
    public var doorSensorState: NamiPairingFramework.StateMessage.EndpointState.DoorSensorState?
    public var doorSensorTemprered: Swift.Bool?
    public var powerSupplyInfo: NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo?
    public var motionSensingConfig: NamiPairingFramework.StateMessage.EndpointState.MotionSensingConfig?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(serializedData: Foundation.Data)
  #endif
  public func stateForModel(_ deviceModel: NamiPairingFramework.NamiDeviceModel) -> [NamiPairingFramework.StateMessage.EndpointState]
  public func stateForEndpoints(_ modelEndpoints: [NamiPairingFramework.NamiDeviceEndpoint]) -> [NamiPairingFramework.StateMessage.EndpointState]
  public func diagnosticsState() -> [NamiPairingFramework.StateMessage.EndpointState]
  public var connectedWithThread: Swift.Bool {
    get
  }
  public var connectedWithWiFi: Swift.Bool {
    get
  }
  public var isBorderRouter: Swift.Bool {
    get
  }
  public var requiresPositioning: Swift.Bool {
    get
  }
  public func jsonData() throws -> Foundation.Data
}
public struct DeviceStateAnalyzer : NamiPairingFramework.StorableDeviceStateAnalyzerProtocol {
  public init()
  public func isBorderRouter(from stateData: Foundation.Data) -> Swift.Bool
}
public struct ControlResponseContent : Swift.Codable, NamiPairingFramework.DeviceCommandResponseContentProtocol {
  public typealias DeviceConnections_DeviceCommandResponseError = NamiPairingFramework.ControlResponseError
  public var success: Swift.Bool
  public var error: NamiPairingFramework.ControlResponseError?
  public var seqTime: Swift.UInt64
  public var state: Foundation.Data
  #if compiler(>=5.3) && $NonescapableTypes
  public init(success: Swift.Bool, error: NamiPairingFramework.ControlResponseError? = nil, seqTime: Swift.UInt64, state: Foundation.Data)
  #endif
  public init(seqTime: Swift.UInt64, state: Foundation.Data)
  public init(error: NamiPairingFramework.ControlResponseError)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias DeviceCommandResponseError = NamiPairingFramework.ControlResponseError
}
public struct ControlResponseError : Swift.Codable, NamiPairingFramework.DeviceCommandResponseErrorProtocol, Swift.Error {
  public var error: Swift.String
  public var errorCode: Swift.String
  public var code: Swift.String {
    get
  }
  public var message: Swift.String {
    get
  }
  public init(error: Swift.String, errorCode: Swift.String)
  public init(code: Swift.String, message: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ControlResponseResult : Swift.Codable, NamiPairingFramework.DevicesCommandResponseResultProtocol {
  public var devices: [NamiPairingFramework.DeviceUniversalID : NamiPairingFramework.ControlResponseContent]
  public var isCloudResponse: Swift.Bool
  public typealias DeviceConnections_DeviceCommandResponseContent = NamiPairingFramework.ControlResponseContent
  public init(devices: [NamiPairingFramework.DeviceUniversalID : NamiPairingFramework.ControlResponseContent], isCloudResponse: Swift.Bool)
  public typealias DeviceCommandResponseContent = NamiPairingFramework.ControlResponseContent
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiDeviceControlResponse : NamiPairingFramework.DevicesCommandResponseProtocol {
  public typealias Result = NamiPairingFramework.ControlResponseResult
  public var results: [NamiPairingFramework.ControlResponseResult]
  public var seqTime: Swift.UInt64
  public init(results: [NamiPairingFramework.ControlResponseResult], seqTime: Swift.UInt64)
  public init(from decoder: any Swift.Decoder) throws
}
final public class SyncSet<E> : NamiPairingFramework.SyncSetProtocol where E : Swift.Hashable {
  required public init()
  public init(_ wrappedValue: Swift.Set<E>)
  required public init<S>(_ elements: S) where E == S.Element, S : Swift.Sequence
  public init(minimumCapacity: Swift.Int)
  public typealias Element = E
  public typealias Index = Swift.Set<E>.Index
  final public var startIndex: NamiPairingFramework.SyncSet<E>.Index {
    get
  }
  final public var endIndex: NamiPairingFramework.SyncSet<E>.Index {
    get
  }
  final public var count: Swift.Int {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
  final public var capacity: Swift.Int {
    get
  }
  final public var customMirror: Swift.Mirror {
    get
  }
  final public var underestimatedCount: Swift.Int {
    get
  }
  final public var lazy: Swift.LazySequence<Swift.Set<E>> {
    get
  }
  public static func == (lhs: NamiPairingFramework.SyncSet<E>, rhs: NamiPairingFramework.SyncSet<E>) -> Swift.Bool
  final public func index(after i: NamiPairingFramework.SyncSet<E>.Index) -> NamiPairingFramework.SyncSet<E>.Index
  final public func index(_ i: NamiPairingFramework.SyncSet<E>.Index, offsetBy distance: Swift.Int) -> NamiPairingFramework.SyncSet<E>.Index
  #if compiler(>=5.3) && $NonescapableTypes
  final public func index(_ i: NamiPairingFramework.SyncSet<E>.Index, offsetBy distance: Swift.Int, limitedBy limit: NamiPairingFramework.SyncSet<E>.Index) -> NamiPairingFramework.SyncSet<E>.Index?
  #endif
  final public func formIndex(_ i: inout NamiPairingFramework.SyncSet<E>.Index, offsetBy distance: Swift.Int)
  final public func formIndex(_ i: inout NamiPairingFramework.SyncSet<E>.Index, offsetBy distance: Swift.Int, limitedBy limit: NamiPairingFramework.SyncSet<E>.Index) -> Swift.Bool
  final public func distance(from start: NamiPairingFramework.SyncSet<E>.Index, to end: NamiPairingFramework.SyncSet<E>.Index) -> Swift.Int
  @available(swift 4.0)
  final public func filter(_ isIncluded: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> Swift.Set<NamiPairingFramework.SyncSet<E>.Element>
  final public func subtract(_ other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>)
  final public func isSubset(of other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Bool
  final public func isSuperset(of other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Bool
  final public func isDisjoint(with other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Bool
  final public func subtracting(_ other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Set<NamiPairingFramework.SyncSet<E>.Element>
  final public func isStrictSuperset(of other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Bool
  final public func isStrictSubset(of other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Bool
  final public func intersection(_ other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>) -> Swift.Set<NamiPairingFramework.SyncSet<E>.Element>
  final public func formSymmetricDifference(_ other: Swift.Set<NamiPairingFramework.SyncSet<E>.Element>)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func popFirst() -> NamiPairingFramework.SyncSet<E>.Element?
  #endif
  final public func reserveCapacity(_ minimumCapacity: Swift.Int)
  final public func map<T>(_ transform: (NamiPairingFramework.SyncSet<E>.Element) throws -> T) rethrows -> [T]
  final public func dropFirst(_ k: Swift.Int = 1) -> Swift.Slice<Swift.Set<NamiPairingFramework.SyncSet<E>.Element>>
  final public func split(maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true, whereSeparator isSeparator: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> [Swift.Slice<Swift.Set<NamiPairingFramework.SyncSet<E>.Element>>]
  final public func split(separator: NamiPairingFramework.SyncSet<E>.Element, maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true) -> [Swift.Slice<Swift.Set<NamiPairingFramework.SyncSet<E>.Element>>]
  final public subscript(position: NamiPairingFramework.SyncSet<E>.Index) -> E {
    get
  }
  final public func formIndex(after i: inout NamiPairingFramework.SyncSet<E>.Index)
  final public func union(_ other: NamiPairingFramework.SyncSet<E>) -> NamiPairingFramework.SyncSet<E>
  final public func hash(into hasher: inout Swift.Hasher)
  final public func intersection(_ other: NamiPairingFramework.SyncSet<E>) -> Self
  final public func symmetricDifference(_ other: __owned NamiPairingFramework.SyncSet<E>) -> Self
  final public func insert(_ newMember: __owned E) -> (inserted: Swift.Bool, memberAfterInsert: E)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func remove(_ member: E) -> E?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func update(with newMember: __owned E) -> E?
  #endif
  final public func formUnion(_ other: __owned NamiPairingFramework.SyncSet<E>)
  final public func formIntersection(_ other: NamiPairingFramework.SyncSet<E>)
  final public func formSymmetricDifference(_ other: __owned NamiPairingFramework.SyncSet<E>)
  final public func removeAll()
  final public func makeIterator() -> Swift.Set<E>.Iterator
  #if compiler(>=5.3) && $NonescapableTypes
  final public func withContiguousStorageIfAvailable<R>(_ body: (_ buffer: Swift.UnsafeBufferPointer<NamiPairingFramework.SyncSet<E>.Element>) throws -> R) rethrows -> R?
  #endif
  final public func shuffled(using generator: inout some RandomNumberGenerator) -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func shuffled() -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func filter(_ isIncluded: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func forEach(_ body: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Void) rethrows
  #if compiler(>=5.3) && $NonescapableTypes
  final public func first(where predicate: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> NamiPairingFramework.SyncSet<E>.Element?
  #endif
  final public func split(maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true, whereSeparator isSeparator: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> [Swift.ArraySlice<NamiPairingFramework.SyncSet<E>.Element>]
  final public func suffix(_ maxLength: Swift.Int) -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func dropLast(_ k: Swift.Int = 1) -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func drop(while predicate: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> Swift.DropWhileSequence<Swift.Set<E>>
  final public func prefix(_ maxLength: Swift.Int) -> Swift.PrefixSequence<Swift.Set<E>>
  final public func prefix(while predicate: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func enumerated() -> Swift.EnumeratedSequence<Swift.Set<E>>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func min(by areInIncreasingOrder: (NamiPairingFramework.SyncSet<E>.Element, NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> NamiPairingFramework.SyncSet<E>.Element?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func max(by areInIncreasingOrder: (NamiPairingFramework.SyncSet<E>.Element, NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> NamiPairingFramework.SyncSet<E>.Element?
  #endif
  final public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (NamiPairingFramework.SyncSet<E>.Element, PossiblePrefix.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where PossiblePrefix : Swift.Sequence
  final public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (NamiPairingFramework.SyncSet<E>.Element, OtherSequence.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where OtherSequence : Swift.Sequence
  final public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (NamiPairingFramework.SyncSet<E>.Element, NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> Swift.Bool where E == OtherSequence.Element, OtherSequence : Swift.Sequence
  final public func contains(where predicate: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> Swift.Bool
  final public func allSatisfy(_ predicate: (NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> Swift.Bool
  final public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, NamiPairingFramework.SyncSet<E>.Element) throws -> Result) rethrows -> Result
  final public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (_ partialResult: inout Result, NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Void) rethrows -> Result
  final public func reversed() -> [NamiPairingFramework.SyncSet<E>.Element]
  final public func flatMap(_: (NamiPairingFramework.SyncSet<E>.Element) throws -> E) rethrows -> [E] where E : Swift.Sequence
  #if compiler(>=5.3) && $NonescapableTypes
  final public func compactMap(_ transform: (NamiPairingFramework.SyncSet<E>.Element) throws -> E?) rethrows -> [E]
  #endif
  final public func sorted(by areInIncreasingOrder: (NamiPairingFramework.SyncSet<E>.Element, NamiPairingFramework.SyncSet<E>.Element) throws -> Swift.Bool) rethrows -> [NamiPairingFramework.SyncSet<E>.Element]
  public typealias ArrayLiteralElement = NamiPairingFramework.SyncSet<E>.Element
  public typealias Indices = Swift.DefaultIndices<NamiPairingFramework.SyncSet<E>>
  public typealias Iterator = Swift.Set<E>.Iterator
  public typealias SubSequence = Swift.Slice<NamiPairingFramework.SyncSet<E>>
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
extension NamiPairingFramework.SyncSet where E : Swift.Sequence {
  final public func joined() -> Swift.FlattenSequence<Swift.Set<NamiPairingFramework.SyncSet<E>.Element>>
  final public func joined(separator: some Sequence<Element.Element>) -> Swift.JoinedSequence<Swift.Set<NamiPairingFramework.SyncSet<E>.Element>>
}
extension NamiPairingFramework.SyncSet {
  final public func split(separator: NamiPairingFramework.SyncSet<E>.Element, maxSplits: Swift.Int = Int.max, omittingEmptySubsequences: Swift.Bool = true) -> [Swift.ArraySlice<NamiPairingFramework.SyncSet<E>.Element>]
  final public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Swift.Bool where E == PossiblePrefix.Element, PossiblePrefix : Swift.Sequence
  final public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Swift.Bool where E == OtherSequence.Element, OtherSequence : Swift.Sequence
  final public func contains(_ element: NamiPairingFramework.SyncSet<E>.Element) -> Swift.Bool
}
extension NamiPairingFramework.SyncSet where E : Swift.Comparable {
  #if compiler(>=5.3) && $NonescapableTypes
  @warn_unqualified_access
  final public func min() -> NamiPairingFramework.SyncSet<E>.Element?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @warn_unqualified_access
  final public func max() -> NamiPairingFramework.SyncSet<E>.Element?
  #endif
  final public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Swift.Bool where E == OtherSequence.Element, OtherSequence : Swift.Sequence
  final public func sorted() -> [NamiPairingFramework.SyncSet<E>.Element]
}
extension NamiPairingFramework.SyncSet where E : Swift.StringProtocol {
  final public func joined(separator: Swift.String = "") -> Swift.String
}
public protocol SyncSetProtocol : Swift.Collection, Swift.CustomDebugStringConvertible, Swift.CustomReflectable, Swift.CustomStringConvertible, Swift.Hashable, Swift.SetAlgebra where Self.Element : Swift.Hashable {
}
extension Swift.Set : NamiPairingFramework.SyncSetProtocol {
}
public protocol CoAPConnectionsProtocol : AnyObject {
  init()
  init(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol])
  init(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol], date: Foundation.Date)
  func areSamePresahedKeys(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol]) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  func getRequest(to endpoint: Network.NWEndpoint, path: Swift.String?) -> NamiPairingFramework.CoAPMessagePublisher
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func postMessage(_ message: Foundation.Data, to endpoint: Network.NWEndpoint, path: Swift.String?) -> NamiPairingFramework.CoAPMessagePublisher
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func subscribeObserver(at endpoint: Network.NWEndpoint, path: Swift.String?, timeout: Swift.Int?) -> NamiPairingFramework.CoAPMessagePublisher
  #endif
  func unsubscribeFromAll()
  static func endpoint(forHost host: Swift.String, port: Swift.UInt16) -> Network.NWEndpoint
}
extension NamiPairingFramework.CoAPConnectionsProtocol {
  public static func endpoint(forHost host: Swift.String, port: Swift.UInt16) -> Network.NWEndpoint
}
public enum CoAPConnectionsErrors {
  public static let timeoutError: Foundation.NSError
}
public typealias CoAPMessagePublisher = Combine.AnyPublisher<NamiPairingFramework.SCMessage, any Swift.Error>
final public class CoAPConnections : NamiPairingFramework.CoAPConnectionsProtocol {
  public init()
  convenience public init(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol])
  public init(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol], date: Foundation.Date)
  final public func areSamePresahedKeys(placeKeys: [any NamiPairingFramework.PlaceKeyProtocol]) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getRequest(to endpoint: Network.NWEndpoint, path: Swift.String? = nil) -> NamiPairingFramework.CoAPMessagePublisher
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func postMessage(_ message: Foundation.Data, to endpoint: Network.NWEndpoint, path: Swift.String? = nil) -> NamiPairingFramework.CoAPMessagePublisher
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func subscribeObserver(at endpoint: Network.NWEndpoint, path: Swift.String? = nil, timeout: Swift.Int?) -> NamiPairingFramework.CoAPMessagePublisher
  #endif
  final public func unsubscribeFromAll()
  @objc deinit
}
extension NamiPairingFramework.CoAPConnections {
  public enum MessageSubscriptionType {
    case observing
    case oneoffGet
    case oneoffPost(message: Foundation.Data)
  }
  @_hasMissingDesignatedInitializers public class MessageSubscription<S> : NamiPairingFramework.SCClientDelegate, Combine.Subscription where S : Combine.Subscriber, S.Failure == any Swift.Error, S.Input == NamiPairingFramework.SCMessage {
    public func swiftCoapClient(_ client: NamiPairingFramework.SCClient, didReceiveMessage message: NamiPairingFramework.SCMessage)
    public func swiftCoapClient(_ client: NamiPairingFramework.SCClient, didFailWithError error: Foundation.NSError)
    public func swiftCoapClient(_: NamiPairingFramework.SCClient, didSendMessage _: NamiPairingFramework.SCMessage, number _: Swift.Int)
    public func request(_: Combine.Subscribers.Demand)
    public func cancel()
    @objc deinit
  }
  public struct MessagePublisher : Combine.Publisher {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(withTransport transport: any NamiPairingFramework.SCCoAPTransportLayerProtocol, endpoint: Network.NWEndpoint, path: Swift.String? = nil, type: NamiPairingFramework.CoAPConnections.MessageSubscriptionType = .observing)
    #endif
    public typealias Output = NamiPairingFramework.SCMessage
    public typealias Failure = Swift.Error
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == any Swift.Error, S.Input == NamiPairingFramework.SCMessage
  }
}
public protocol DeviceConnectionsManagerProtocol {
  associatedtype Storage : NamiPairingFramework.DeviceConnectionsManagerStorageProtocol
  associatedtype API : NamiPairingFramework.DeviceConnectionsManagerWebAPIProtocol
  init(storage: Self.Storage, api: Self.API)
  var publisher: Combine.PassthroughSubject<NamiPairingFramework.NamiDeviceObservation, Swift.Never> { get }
  func sendControlMessage(_ controlMessage: any NamiPairingFramework.DeviceControlMessageProtocol, for capability: NamiPairingFramework.NamiDeviceCapability, uid: NamiPairingFramework.DeviceUniversalID, in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<any NamiPairingFramework.DevicesCommandResponseProtocol, any Swift.Error>
  func sendCloudControlMessage(_ controlMessage: any NamiPairingFramework.DeviceControlMessageProtocol, for capability: NamiPairingFramework.NamiDeviceCapability, uid: NamiPairingFramework.DeviceUniversalID, in placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<any NamiPairingFramework.DevicesCommandResponseProtocol, any Swift.Error>
  func deviceStateRequest(to device: NamiPairingFramework.DeviceUniversalID, connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Foundation.Data, any Swift.Error>
  func devicesStateRequest(connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[Foundation.Data], any Swift.Error>
  func threadCredentialsRequest(to device: NamiPairingFramework.DeviceUniversalID, connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<any NamiPairingFramework.ThreadCredentialsMessageProtocol, any Swift.Error>
  func threadCredentialsRequest(connectedIn placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[any NamiPairingFramework.ThreadCredentialsMessageProtocol], any Swift.Error>
}
public protocol DeviceConnectionsManagerWebAPIProtocol {
  associatedtype DCM_DevicesQuery : NamiPairingFramework.DevicesQueryProtocol
  associatedtype DCM_DevicesResponse : NamiPairingFramework.DevicesResponseProtocol
  associatedtype DCM_DevicesCommandResponse : NamiPairingFramework.DevicesCommandResponseProtocol
  associatedtype DCM_CloudPlaceKey : NamiPairingFramework.CloudPlaceKeyProtocol
  func listDevices(query: Self.DCM_DevicesQuery) -> Combine.AnyPublisher<Self.DCM_DevicesResponse, any Swift.Error>
  func sendDeviceCommandRequests(in placeId: NamiPairingFramework.PlaceID, uids: [NamiPairingFramework.DeviceUniversalID], messages: [Foundation.Data]) -> Combine.AnyPublisher<Self.DCM_DevicesCommandResponse, any Swift.Error>
  func listPlaceKeys() -> Combine.AnyPublisher<[Self.DCM_CloudPlaceKey], any Swift.Error>
}
public protocol DeviceConnectionsManagerStorageProtocol {
  associatedtype DeviceConnectionsManager_PlaceKey : NamiPairingFramework.PlaceKeyProtocol
  func placeIds() -> Combine.AnyPublisher<[NamiPairingFramework.PlaceID], Swift.Never>
  func placeKeys() -> Combine.AnyPublisher<[Self.DeviceConnectionsManager_PlaceKey], Swift.Never>
  func deviceUids(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.DeviceUniversalID], Swift.Never>
  func updateDeviceState(uid: NamiPairingFramework.DeviceUniversalID, state: Foundation.Data, seqTime: Swift.UInt64) throws
  func refreshPlaceKeys() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func refreshDevices(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
}
public struct StorablePlaceKey : Swift.Codable, Swift.Equatable {
  public init(id: Swift.String, key: Swift.String)
  public var id: Swift.String
  public var key: Swift.String
  public static func == (a: NamiPairingFramework.StorablePlaceKey, b: NamiPairingFramework.StorablePlaceKey) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias StoredPlaceKeys = [NamiPairingFramework.PlaceID : [NamiPairingFramework.StorablePlaceKey]]
final public class PlaceKeysStorage {
  public init()
  final public var publisher: Combine.AnyPublisher<NamiPairingFramework.StoredPlaceKeys, Swift.Never> {
    get
  }
  final public func storeKeys(_ keys: NamiPairingFramework.StoredPlaceKeys)
  final public func storeKeys(_ keys: [NamiPairingFramework.StorablePlaceKey], forPlace placeId: NamiPairingFramework.PlaceID)
  final public func getKeys() -> NamiPairingFramework.StoredPlaceKeys
  final public func getKeys(forPlace placeId: NamiPairingFramework.PlaceID) -> [NamiPairingFramework.StorablePlaceKey]
  final public func removeAll()
  @objc deinit
}
public enum SCCoAPTransportLayerError : Swift.Error {
  case setupError(errorDescription: Swift.String), sendError(errorDescription: Swift.String), encodeError, pingTimeoutError
}
public protocol SCCoAPTransportLayerDelegate {
  func transportLayerObject(_ transportLayerObject: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didReceiveData data: Foundation.Data, fromHost host: Swift.String, port: Swift.UInt16)
  func transportLayerObject(_ transportLayerObject: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didReceiveData data: Foundation.Data, fromEndpoint endpoint: Network.NWEndpoint)
  func transportLayerObject(_ transportLayerObject: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didFailWithError error: Foundation.NSError)
}
extension NamiPairingFramework.SCCoAPTransportLayerDelegate {
  public func transportLayerObject(_ transportLayerObject: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didReceiveData data: Foundation.Data, fromHost host: Swift.String, port: Swift.UInt16)
}
public protocol SCCoAPTransportLayerProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  func sendCoAPMessage(_ message: NamiPairingFramework.SCMessage, toEndpoint endpoint: Network.NWEndpoint, token: Swift.UInt64?, delegate: (any NamiPairingFramework.SCCoAPTransportLayerDelegate)?) throws
  #endif
  func getMessageId(for endpoint: Network.NWEndpoint) -> Swift.UInt16
  func cancelMessageTransmission(to endpoint: Network.NWEndpoint, withToken: Swift.UInt64)
  func cancelConnection(to endpoint: Network.NWEndpoint)
  func closeAllTransmissions()
}
public struct MessageTransportIdentifier : Swift.Equatable, Swift.Hashable {
  public static func == (a: NamiPairingFramework.MessageTransportIdentifier, b: NamiPairingFramework.MessageTransportIdentifier) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct MessageTransportDelegate {
}
public struct CoAPConnection {
}
final public class SCCoAPUDPTransportLayer {
  required public init()
  @objc deinit
}
extension NamiPairingFramework.SCCoAPUDPTransportLayer : NamiPairingFramework.SCCoAPTransportLayerProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?(psk: Swift.String, suite: Security.SSLCipherSuite = TLS_PSK_WITH_AES_128_GCM_SHA256)
  #endif
  convenience public init(psk: Foundation.Data, suite: Security.SSLCipherSuite = TLS_PSK_WITH_AES_128_GCM_SHA256)
  convenience public init(networkParameters: Network.NWParameters)
  final public func getMessageId(for endpoint: Network.NWEndpoint) -> Swift.UInt16
  #if compiler(>=5.3) && $NonescapableTypes
  final public func sendCoAPMessage(_ message: NamiPairingFramework.SCMessage, toEndpoint endpoint: Network.NWEndpoint, token: Swift.UInt64?, delegate: (any NamiPairingFramework.SCCoAPTransportLayerDelegate)?) throws
  #endif
  final public func cancelMessageTransmission(to endpoint: Network.NWEndpoint, withToken token: Swift.UInt64)
  final public func closeAllTransmissions()
  final public func cancelConnection(to endpoint: Network.NWEndpoint)
}
public enum SCType : Swift.Int {
  case confirmable, nonConfirmable, acknowledgement, reset
  public func shortString() -> Swift.String
  public func longString() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public static func fromShortString(_ string: Swift.String) -> NamiPairingFramework.SCType?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum SCOption : Swift.Int {
  case ifMatch
  case uriHost
  case etag
  case ifNoneMatch
  case observe
  case uriPort
  case locationPath
  case uriPath
  case contentFormat
  case maxAge
  case uriQuery
  case accept
  case locationQuery
  case block2
  case block1
  case size2
  case proxyUri
  case proxyScheme
  case size1
  public enum Format : Swift.Int {
    case empty, opaque, uInt, string
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func toString() -> Swift.String
  public static func isNumberCritical(_ optionNo: Swift.Int) -> Swift.Bool
  public func isCritical() -> Swift.Bool
  public static func isNumberUnsafe(_ optionNo: Swift.Int) -> Swift.Bool
  public func isUnsafe() -> Swift.Bool
  public static func isNumberNoCacheKey(_ optionNo: Swift.Int) -> Swift.Bool
  public func isNoCacheKey() -> Swift.Bool
  public static func isNumberRepeatable(_ optionNo: Swift.Int) -> Swift.Bool
  public func isRepeatable() -> Swift.Bool
  public func format() -> NamiPairingFramework.SCOption.Format
  #if compiler(>=5.3) && $NonescapableTypes
  public func dataForValueString(_ valueString: Swift.String) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func dataForOptionValueString(_ valueString: Swift.String, format: NamiPairingFramework.SCOption.Format) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func displayStringForData(_ data: Foundation.Data?) -> Swift.String
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func displayStringForFormat(_ format: NamiPairingFramework.SCOption.Format, data: Foundation.Data?) -> Swift.String
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum SCCodeSample : Swift.Int {
  case empty
  case get
  case post
  case put
  case delete
  case created
  case deleted
  case valid
  case changed
  case content
  case `continue`
  case badRequest
  case unauthorized
  case badOption
  case forbidden
  case notFound
  case methodNotAllowed
  case notAcceptable
  case requestEntityIncomplete
  case preconditionFailed
  case requestEntityTooLarge
  case unsupportedContentFormat
  case internalServerError
  case notImplemented
  case badGateway
  case serviceUnavailable
  case gatewayTimeout
  case proxyingNotSupported
  #if compiler(>=5.3) && $NonescapableTypes
  public func codeValue() -> NamiPairingFramework.SCCodeValue!
  #endif
  public func toString() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public static func stringFromCodeValue(_ codeValue: NamiPairingFramework.SCCodeValue) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum SCContentFormat : Swift.UInt {
  case plain
  case linkFormat
  case xml
  case octetStream
  case exi
  case json
  case cbor
  public func needsStringUTF8Conversion() -> Swift.Bool
  public func toString() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt)
  #endif
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public struct SCCodeValue : Swift.Equatable {
  public init(rawValue: Swift.UInt8)
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(classValue: Swift.UInt8, detailValue: Swift.UInt8)
  #endif
  public func toRawValue() -> Swift.UInt8
  #if compiler(>=5.3) && $NonescapableTypes
  public func toCodeSample() -> NamiPairingFramework.SCCodeSample?
  #endif
  public static func fromCodeSample(_ code: NamiPairingFramework.SCCodeSample) -> NamiPairingFramework.SCCodeValue
  public func toString() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public func requestString() -> Swift.String?
  #endif
}
public func == (lhs: NamiPairingFramework.SCCodeValue, rhs: NamiPairingFramework.SCCodeValue) -> Swift.Bool
extension Swift.UInt {
  public func toByteArray() -> [Swift.UInt8]
  public static func fromData(_ data: Foundation.Data) -> Swift.UInt
}
public enum SCAllowedRoute : Swift.UInt {
  case get
  case post
  case put
  case delete
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(codeValue: NamiPairingFramework.SCCodeValue)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt)
  #endif
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
@objc open class SCResourceModel : ObjectiveC.NSObject {
  final public let name: Swift.String
  final public let allowedRoutes: Swift.UInt
  public var maxAgeValue: Swift.UInt!
  public var dataRepresentation: Foundation.Data! {
    get
    set
  }
  public var observable: Swift.Bool
  public init(name: Swift.String, allowedRoutes: Swift.UInt)
  open func willHandleDataAsynchronouslyForRoute(_: NamiPairingFramework.SCAllowedRoute, queryDictionary _: [Swift.String : Swift.String], options _: [Swift.Int : [Foundation.Data]], originalMessage _: NamiPairingFramework.SCMessage) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  open func dataForGet(queryDictionary _: [Swift.String : Swift.String], options _: [Swift.Int : [Foundation.Data]]) -> (statusCode: NamiPairingFramework.SCCodeValue, payloadData: Foundation.Data?, contentFormat: NamiPairingFramework.SCContentFormat?)?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func dataForPost(queryDictionary _: [Swift.String : Swift.String], options _: [Swift.Int : [Foundation.Data]], requestData _: Foundation.Data?) -> (statusCode: NamiPairingFramework.SCCodeValue, payloadData: Foundation.Data?, contentFormat: NamiPairingFramework.SCContentFormat?, locationUri: Swift.String?)?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func dataForPut(queryDictionary _: [Swift.String : Swift.String], options _: [Swift.Int : [Foundation.Data]], requestData _: Foundation.Data?) -> (statusCode: NamiPairingFramework.SCCodeValue, payloadData: Foundation.Data?, contentFormat: NamiPairingFramework.SCContentFormat?, locationUri: Swift.String?)?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func dataForDelete(queryDictionary _: [Swift.String : Swift.String], options _: [Swift.Int : [Foundation.Data]]) -> (statusCode: NamiPairingFramework.SCCodeValue, payloadData: Foundation.Data?, contentFormat: NamiPairingFramework.SCContentFormat?)?
  #endif
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class SCMessage : ObjectiveC.NSObject {
  public static let kCoapErrorDomain: Swift.String
  public var code: NamiPairingFramework.SCCodeValue
  public var type: NamiPairingFramework.SCType
  public var payload: Foundation.Data?
  public var options: [Swift.Int : [Foundation.Data]] {
    get
    set
  }
  public var blockBody: Foundation.Data? {
    get
  }
  public var endpoint: Network.NWEndpoint? {
    get
  }
  public var resourceForConfirmableResponse: NamiPairingFramework.SCResourceModel? {
    get
  }
  public var messageId: Swift.UInt16! {
    get
  }
  public var token: Swift.UInt64 {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(code: NamiPairingFramework.SCCodeValue, type: NamiPairingFramework.SCType, payload: Foundation.Data?)
  #endif
  public func equalForCachingWithMessage(_ message: NamiPairingFramework.SCMessage) -> Swift.Bool
  public static func compareOptionValueArrays(_ first: [Foundation.Data], second: [Foundation.Data]) -> Swift.Bool
  public static func copyFromMessage(_ message: NamiPairingFramework.SCMessage) -> NamiPairingFramework.SCMessage
  public func isFresh() -> Swift.Bool
  public func addOption(_ option: Swift.Int, data: Foundation.Data)
  #if compiler(>=5.3) && $NonescapableTypes
  public func toData() -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func fromData(_ data: Foundation.Data) -> NamiPairingFramework.SCMessage?
  #endif
  public func toHttpUrlRequestWithUrl() -> Foundation.NSMutableURLRequest
  #if compiler(>=5.3) && $NonescapableTypes
  public static func fromHttpUrlResponse(_ urlResponse: Foundation.HTTPURLResponse, data: Foundation.Data!) -> NamiPairingFramework.SCMessage
  #endif
  public func completeUriPath() -> Swift.String
  public func uriQueryDictionary() -> [Swift.String : Swift.String]
  #if compiler(>=5.3) && $NonescapableTypes
  public static func getPathAndQueryDataArrayFromUriString(_ uriString: Swift.String) -> (pathDataArray: [Foundation.Data], queryDataArray: [Foundation.Data])?
  #endif
  public func inferredContentFormat() -> NamiPairingFramework.SCContentFormat
  public func payloadRepresentationString() -> Swift.String
  public static func payloadRepresentationStringForData(_ data: Foundation.Data, contentFormat: NamiPairingFramework.SCContentFormat) -> Swift.String
  public func isObservation() -> Swift.Bool
  public func toString() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public protocol SCClientDelegate {
  func swiftCoapClient(_ client: NamiPairingFramework.SCClient, didReceiveMessage message: NamiPairingFramework.SCMessage)
  func swiftCoapClient(_ client: NamiPairingFramework.SCClient, didFailWithError error: Foundation.NSError)
  func swiftCoapClient(_ client: NamiPairingFramework.SCClient, didSendMessage message: NamiPairingFramework.SCMessage, number: Swift.Int)
}
public enum SCClientErrorCode : Swift.Int {
  case transportLayerSendError, messageInvalidForSendingError, receivedInvalidMessageError, noResponseExpectedError, proxyingError
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public class SCClient {
  public var delegate: (any NamiPairingFramework.SCClientDelegate)?
  public var autoBlock1SZX: Swift.UInt? {
    get
    set
  }
  public var httpProxyingData: (hostName: Swift.String, port: Swift.UInt16)?
  public var cachingActive: Swift.Bool
  public var disableRetransmissions: Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public init(delegate: (any NamiPairingFramework.SCClientDelegate)?, transportLayerObject: any NamiPairingFramework.SCCoAPTransportLayerProtocol)
  #endif
  public func sendCoAPMessage(_ message: NamiPairingFramework.SCMessage, endpoint: Network.NWEndpoint)
  public func cancelObserve()
  public func closeTransmission()
  @objc deinit
}
extension NamiPairingFramework.SCClient : NamiPairingFramework.SCCoAPTransportLayerDelegate {
  public func transportLayerObject(_: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didReceiveData data: Foundation.Data, fromEndpoint endpoint: Network.NWEndpoint)
  public func transportLayerObject(_: any NamiPairingFramework.SCCoAPTransportLayerProtocol, didFailWithError error: Foundation.NSError)
}
public struct AccessToken : Swift.Equatable, Swift.Codable {
  public init(accessToken: NamiPairingFramework.TokenString, expiresAt: Foundation.Date)
  public var accessToken: NamiPairingFramework.TokenString
  public var expiresAt: Foundation.Date
  public func isValid() -> Swift.Bool
  public static func == (a: NamiPairingFramework.AccessToken, b: NamiPairingFramework.AccessToken) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AuthorizationDetails : Swift.Equatable, Swift.Codable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(idToken: NamiPairingFramework.TokenString, authCode: Swift.String? = nil, provider: NamiPairingFramework.OAuthProvider? = nil)
  #endif
  public var idToken: NamiPairingFramework.TokenString
  public var authCode: Swift.String?
  public var provider: NamiPairingFramework.OAuthProvider?
  public static func == (a: NamiPairingFramework.AuthorizationDetails, b: NamiPairingFramework.AuthorizationDetails) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AnonymousUser : Swift.Equatable, Swift.Decodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: NamiPairingFramework.UserID, username: Swift.String, recoveryKey: NamiPairingFramework.TokenString, featureFlags: [NamiPairingFramework.FeatureFlag]? = nil)
  #endif
  public var id: NamiPairingFramework.UserID
  public var username: Swift.String
  public var recoveryKey: NamiPairingFramework.TokenString
  public var featureFlags: [NamiPairingFramework.FeatureFlag]?
  public static func == (a: NamiPairingFramework.AnonymousUser, b: NamiPairingFramework.AnonymousUser) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct UpdateUserProfileRequest : Swift.Equatable, Swift.Encodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(username: Swift.String, iconId: NamiPairingFramework.UserIconID? = nil, themeId: NamiPairingFramework.IconID? = nil)
  #endif
  public var username: Swift.String
  public var iconId: NamiPairingFramework.UserIconID?
  public var themeId: NamiPairingFramework.IconID?
  public static func == (a: NamiPairingFramework.UpdateUserProfileRequest, b: NamiPairingFramework.UpdateUserProfileRequest) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct RecoveryKey : Swift.Equatable, Swift.Encodable {
  public init(recoveryKey: Swift.String)
  public var recoveryKey: Swift.String
  public static func == (a: NamiPairingFramework.RecoveryKey, b: NamiPairingFramework.RecoveryKey) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct FeatureFlag : NamiPairingFramework.FeatureFlagProtocol, Swift.Equatable, Swift.Codable {
  public init(name: Swift.String, resource: Swift.String)
  public var name: Swift.String
  public var resource: Swift.String
  public static func == (a: NamiPairingFramework.FeatureFlag, b: NamiPairingFramework.FeatureFlag) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct UserIdentity : NamiPairingFramework.UserIdentityProtocol, Swift.Equatable, Swift.Decodable {
  public init(provider: Swift.String, providerUserId: Swift.String)
  public var provider: Swift.String
  public var providerUserId: Swift.String
  public static func == (a: NamiPairingFramework.UserIdentity, b: NamiPairingFramework.UserIdentity) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct UnlinkRequest : Swift.Codable {
  public init(providerUserId: Swift.String)
  public var providerUserId: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct User : Swift.Equatable, Swift.Codable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: NamiPairingFramework.UserID, username: Swift.String, featureFlags: [NamiPairingFramework.FeatureFlag]? = nil, externalUserIdentities: [NamiPairingFramework.UserIdentity]? = nil, lastSeen: Foundation.Date? = nil, lastSeenPlace: NamiPairingFramework.PlaceID? = nil, icon: NamiPairingFramework.UserIconID? = nil, themeId: NamiPairingFramework.IconID? = nil)
  #endif
  public var id: NamiPairingFramework.UserID
  public var username: Swift.String
  public var featureFlags: [NamiPairingFramework.FeatureFlag]?
  public var externalUserIdentities: [NamiPairingFramework.UserIdentity]?
  public var lastSeen: Foundation.Date?
  public var lastSeenPlace: NamiPairingFramework.PlaceID?
  public var icon: NamiPairingFramework.UserIconID?
  public var themeId: NamiPairingFramework.IconID?
  public var urn: NamiPairingFramework.URN {
    get
  }
  public static func == (a: NamiPairingFramework.User, b: NamiPairingFramework.User) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AnonymousUserResponse : Swift.Decodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(user: NamiPairingFramework.AnonymousUser, accessToken: NamiPairingFramework.AccessToken, refreshToken: NamiPairingFramework.TokenString, newUser: Swift.Bool? = nil)
  #endif
  public var user: NamiPairingFramework.AnonymousUser
  public var accessToken: NamiPairingFramework.AccessToken
  public var refreshToken: NamiPairingFramework.TokenString
  public var newUser: Swift.Bool?
  public init(from decoder: any Swift.Decoder) throws
}
public struct UserResponse : Swift.Decodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(user: NamiPairingFramework.User, accessToken: NamiPairingFramework.AccessToken, refreshToken: NamiPairingFramework.TokenString, newUser: Swift.Bool? = nil)
  #endif
  public var user: NamiPairingFramework.User
  public var accessToken: NamiPairingFramework.AccessToken
  public var refreshToken: NamiPairingFramework.TokenString
  public var newUser: Swift.Bool?
  public init(from decoder: any Swift.Decoder) throws
}
public enum OAuthProvider : Swift.String, Swift.Equatable, Swift.Codable, Swift.Comparable {
  case unkown
  case apple
  case google
  public static func < (lhs: NamiPairingFramework.OAuthProvider, rhs: NamiPairingFramework.OAuthProvider) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct PlaceKeyRequest : Swift.Encodable {
  public init(publicKey: Swift.String)
  public var publicKey: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct WiredPlaceKeys : NamiPairingFramework.WiredPlaceKeysProtocol, Swift.Decodable, Swift.Equatable {
  public init(ciphertext: Swift.String, iv: Swift.String, authTag: Swift.String, serverKey: Swift.String)
  public var ciphertext: Swift.String
  public var iv: Swift.String
  public var authTag: Swift.String
  public var serverKey: Swift.String
  public static func == (a: NamiPairingFramework.WiredPlaceKeys, b: NamiPairingFramework.WiredPlaceKeys) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CloudPlaceKey : NamiPairingFramework.CloudPlaceKeyProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public init(id: Swift.String, key: Swift.String)
  public var id: Swift.String
  public var key: Swift.String
  public static func == (a: NamiPairingFramework.CloudPlaceKey, b: NamiPairingFramework.CloudPlaceKey) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DecodedPlaceKeys : Swift.Decodable {
  public init(keys: [NamiPairingFramework.CloudPlaceKey])
  public var keys: [NamiPairingFramework.CloudPlaceKey]
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlacesResponse : NamiPairingFramework.PlacesResponseProtocol, Swift.Decodable {
  public init(places: [NamiPairingFramework.Place], permissions: [NamiPairingFramework.URN : NamiPairingFramework.UserPermissionsSet], roles: [NamiPairingFramework.URN : [NamiPairingFramework.PlaceUserRole]])
  public var places: [NamiPairingFramework.Place]
  public var permissions: [NamiPairingFramework.URN : NamiPairingFramework.UserPermissionsSet]
  public var roles: [NamiPairingFramework.URN : [NamiPairingFramework.PlaceUserRole]]
  public typealias Place = NamiPairingFramework.Place
  public typealias PlaceUserRole = NamiPairingFramework.PlaceUserRole
  public typealias UserPermissionsSet = NamiPairingFramework.UserPermissionsSet
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Place : NamiPairingFramework.PlaceProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: NamiPairingFramework.PlaceID, urn: Swift.String, name: Swift.String, createdAt: Foundation.Date, updatedAt: Foundation.Date, themeId: NamiPairingFramework.ThemeID, iconId: NamiPairingFramework.IconID, timeZone: Swift.String? = nil, propertyTypeId: NamiPairingFramework.PropertyTypeID?, propertyElevationId: NamiPairingFramework.PropertyElevationID?, propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID?, petTypeId: NamiPairingFramework.PetTypeID?, zones: [NamiPairingFramework.PlaceZone], limits: NamiPairingFramework.PlaceUsageLimits, placeKeys: NamiPairingFramework.WiredPlaceKeys? = nil, decodedPlaceKeys: [NamiPairingFramework.CloudPlaceKey]? = nil, entryDelay: NamiPairingFramework.EntryDelay?, exitDelay: NamiPairingFramework.ExitDelay?)
  #endif
  public var id: NamiPairingFramework.PlaceID
  public var urn: Swift.String
  public var name: Swift.String
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var timeZone: Swift.String?
  public var propertyTypeId: NamiPairingFramework.PropertyTypeID?
  public var propertyElevationId: NamiPairingFramework.PropertyElevationID?
  public var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID?
  public var petTypeId: NamiPairingFramework.PetTypeID?
  public var zones: [NamiPairingFramework.PlaceZone]
  public var limits: NamiPairingFramework.PlaceUsageLimits
  public var placeKeys: NamiPairingFramework.WiredPlaceKeys?
  public var decodedPlaceKeys: [NamiPairingFramework.CloudPlaceKey]?
  public var entryDelay: NamiPairingFramework.EntryDelay?
  public var exitDelay: NamiPairingFramework.ExitDelay?
  public static func == (a: NamiPairingFramework.Place, b: NamiPairingFramework.Place) -> Swift.Bool
  public typealias CloudPlaceKey = NamiPairingFramework.CloudPlaceKey
  public typealias ID = NamiPairingFramework.PlaceID
  public typealias UsageLimits = NamiPairingFramework.PlaceUsageLimits
  public typealias WiredPlaceKeys = NamiPairingFramework.WiredPlaceKeys
  public typealias Zone = NamiPairingFramework.PlaceZone
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlaceUsageLimits : NamiPairingFramework.PlaceUsageLimitsProtocol, Swift.Decodable, Swift.Equatable {
  public init(membership: Swift.UInt)
  public var membership: Swift.UInt
  public static func == (a: NamiPairingFramework.PlaceUsageLimits, b: NamiPairingFramework.PlaceUsageLimits) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CreatePlaceRequestZone : Swift.Encodable {
  public init(name: Swift.String)
  public var name: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct CreatePlaceRequest : Swift.Encodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(name: Swift.String, themeId: NamiPairingFramework.ThemeID, iconId: NamiPairingFramework.IconID, timeZone: Swift.String? = nil, propertyTypeId: NamiPairingFramework.PropertyTypeID, propertyElevationId: NamiPairingFramework.PropertyElevationID, propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID, petTypeId: NamiPairingFramework.PetTypeID, zone: NamiPairingFramework.CreatePlaceRequestZone? = nil, publicKey: Swift.String? = nil, engineType: Swift.String? = nil)
  #endif
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var timeZone: Swift.String?
  public var propertyTypeId: NamiPairingFramework.PropertyTypeID
  public var propertyElevationId: NamiPairingFramework.PropertyElevationID
  public var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID
  public var petTypeId: NamiPairingFramework.PetTypeID
  public var zone: NamiPairingFramework.CreatePlaceRequestZone?
  public var publicKey: Swift.String?
  public var engineType: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct UpdatePlaceRequest : Swift.Encodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(name: Swift.String, themeId: NamiPairingFramework.ThemeID, iconId: NamiPairingFramework.IconID, timeZone: Swift.String? = nil, zone: NamiPairingFramework.CreatePlaceRequestZone? = nil, publicKey: Swift.String? = nil, petTypeId: NamiPairingFramework.PetTypeID? = nil, engineType: Swift.String? = nil, entryDelay: NamiPairingFramework.EntryDelay? = nil, exitDelay: NamiPairingFramework.ExitDelay? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(name: Swift.String, themeId: NamiPairingFramework.ThemeID, iconId: NamiPairingFramework.IconID, timeZone: Swift.String? = nil, propertyTypeId: NamiPairingFramework.PropertyTypeID, propertyElevationId: NamiPairingFramework.PropertyElevationID, propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID, petTypeId: NamiPairingFramework.PetTypeID, zone: NamiPairingFramework.CreatePlaceRequestZone? = nil, publicKey: Swift.String? = nil, engineType: Swift.String? = nil, entryDelay: NamiPairingFramework.EntryDelay? = nil, exitDelay: NamiPairingFramework.ExitDelay? = nil)
  #endif
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public var timeZone: Swift.String?
  public var propertyTypeId: NamiPairingFramework.PropertyTypeID?
  public var propertyElevationId: NamiPairingFramework.PropertyElevationID?
  public var propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID?
  public var petTypeId: NamiPairingFramework.PetTypeID?
  public var zone: NamiPairingFramework.CreatePlaceRequestZone?
  public var publicKey: Swift.String?
  public var engineType: Swift.String?
  public var entryDelay: NamiPairingFramework.EntryDelay?
  public var exitDelay: NamiPairingFramework.ExitDelay?
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PlaceZone : NamiPairingFramework.ZoneProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public init(id: NamiPairingFramework.PlaceZoneID, externalId: Swift.String, urn: Swift.String, name: Swift.String, placeId: NamiPairingFramework.PlaceID, rooms: [NamiPairingFramework.Room] = [], alertMode: NamiPairingFramework.AlertMode, engineConfig: NamiPairingFramework.EngineConfig, motionStatus: NamiPairingFramework.ZoneMotionStatus, createdAt: Foundation.Date, updatedAt: Foundation.Date)
  public var id: NamiPairingFramework.PlaceZoneID
  public var externalId: Swift.String
  public var urn: Swift.String
  public var name: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var rooms: [NamiPairingFramework.Room]
  public var alertMode: NamiPairingFramework.AlertMode
  public var engineConfig: NamiPairingFramework.EngineConfig
  public var motionStatus: NamiPairingFramework.ZoneMotionStatus
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.PlaceZone, b: NamiPairingFramework.PlaceZone) -> Swift.Bool
  public typealias AlertMode = NamiPairingFramework.AlertMode
  public typealias EngineConfig = NamiPairingFramework.EngineConfig
  public typealias ID = NamiPairingFramework.PlaceZoneID
  public typealias MotionStatus = NamiPairingFramework.ZoneMotionStatus
  public typealias Room = NamiPairingFramework.Room
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZoneMotionStatus : NamiPairingFramework.ZoneMotionStatusProtocol, Swift.Decodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(detection: Swift.Bool? = nil, startedAt: Foundation.Date? = nil, health: NamiPairingFramework.ZoneHealth)
  #endif
  public var detection: Swift.Bool?
  public var startedAt: Foundation.Date?
  public var health: NamiPairingFramework.ZoneHealth
  public static func == (a: NamiPairingFramework.ZoneMotionStatus, b: NamiPairingFramework.ZoneMotionStatus) -> Swift.Bool
  public typealias ZoneHealth = NamiPairingFramework.ZoneHealth
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum ZoneHealth : Swift.String, NamiPairingFramework.ZoneHealthProtocol, Swift.Decodable {
  case healthy
  case degraded
  case unhealthy
  case unknown
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct CreateZoneRequest : Swift.Encodable {
  public init(name: Swift.String)
  public var name: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct WiFiCredentialsSessionsResponse : NamiPairingFramework.WiFiCredentialsUpdateSessionResponseProtocol, Swift.Decodable {
  public init(sessions: [NamiPairingFramework.WiFiCredentialsUpdateSession])
  public var sessions: [NamiPairingFramework.WiFiCredentialsUpdateSession]
  public typealias WiFiCredentialsUpdateSession = NamiPairingFramework.WiFiCredentialsUpdateSession
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum WiFiCredentialsUpdateStatus : Swift.String, NamiPairingFramework.WiFiCredentialsUpdateStatusProtocol, Swift.Codable {
  case inProgress
  case completed
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct UpdatedDevice : NamiPairingFramework.UpdatedDeviceProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public init(uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, updatedBy: NamiPairingFramework.UpdatedDeviceUser, updatedAt: Foundation.Date)
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var updatedBy: NamiPairingFramework.UpdatedDeviceUser
  public var updatedAt: Foundation.Date
  public var id: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.UpdatedDevice, b: NamiPairingFramework.UpdatedDevice) -> Swift.Bool
  public typealias ID = Swift.String
  public typealias UpdatedBy = NamiPairingFramework.UpdatedDeviceUser
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct UpdatedDeviceUser : NamiPairingFramework.UpdatedDeviceUserProtocol, Swift.Decodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(urn: Swift.String?, name: Swift.String, themeId: NamiPairingFramework.ThemeID, iconId: NamiPairingFramework.IconID)
  #endif
  public var urn: Swift.String?
  public var name: Swift.String
  public var themeId: NamiPairingFramework.ThemeID
  public var iconId: NamiPairingFramework.IconID
  public static func == (a: NamiPairingFramework.UpdatedDeviceUser, b: NamiPairingFramework.UpdatedDeviceUser) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WiFiCredentialsUpdateSession : NamiPairingFramework.WiFiCredentialsUpdateSessionProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public init(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID, urn: Swift.String, zoneId: NamiPairingFramework.PlaceZoneID, status: NamiPairingFramework.WiFiCredentialsUpdateStatus, updatedDevices: [NamiPairingFramework.UpdatedDevice], wifiUpdateSessionDevices: [NamiPairingFramework.WiFiCredentialsHoldingDevice])
  public var id: NamiPairingFramework.WiFiCredentialsUpdateSessionID
  public var urn: Swift.String
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var status: NamiPairingFramework.WiFiCredentialsUpdateStatus
  public var updatedDevices: [NamiPairingFramework.UpdatedDevice]?
  public var wifiUpdateSessionDevices: [NamiPairingFramework.WiFiCredentialsHoldingDevice]?
  public static func == (a: NamiPairingFramework.WiFiCredentialsUpdateSession, b: NamiPairingFramework.WiFiCredentialsUpdateSession) -> Swift.Bool
  public typealias ID = NamiPairingFramework.WiFiCredentialsUpdateSessionID
  public typealias Status = NamiPairingFramework.WiFiCredentialsUpdateStatus
  public typealias UpdatedDevice = NamiPairingFramework.UpdatedDevice
  public typealias WiFiCredentialsHoldingDevice = NamiPairingFramework.WiFiCredentialsHoldingDevice
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WiFiCredentialsHoldingDevice : NamiPairingFramework.WiFiCredentialsHoldingDeviceProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var id: NamiPairingFramework.DeviceUniversalID {
    get
  }
  public static func == (a: NamiPairingFramework.WiFiCredentialsHoldingDevice, b: NamiPairingFramework.WiFiCredentialsHoldingDevice) -> Swift.Bool
  public typealias ID = NamiPairingFramework.DeviceUniversalID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum MotionDataResolution : Swift.String, NamiPairingFramework.MotionDataResolutionProtocol, Swift.Codable {
  case thirtySec
  case thirtyMin
  case fourHr
  case twelveHr
  case day
  case week
  case month
  case year
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct PlaceMotionAggregates : NamiPairingFramework.PlaceMotionAggregatesProtocol, Swift.Decodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(placeId: NamiPairingFramework.PlaceID, aggregates: [NamiPairingFramework.MotionAggregate], sparklines: [Swift.String : NamiPairingFramework.MotionAggregate]? = nil)
  #endif
  public var placeId: NamiPairingFramework.PlaceID
  public var aggregates: [NamiPairingFramework.MotionAggregate]
  public var sparklines: [Swift.String : NamiPairingFramework.MotionAggregate]?
  #if compiler(>=5.3) && $NonescapableTypes
  public func sparklineFor(zone id: NamiPairingFramework.PlaceZoneID) -> NamiPairingFramework.MotionAggregate?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func sparklineFor(zone urn: Swift.String) -> NamiPairingFramework.MotionAggregate?
  #endif
  public func availableSparklineZones() -> [NamiPairingFramework.PlaceZoneID]
  public typealias Aggregate = NamiPairingFramework.MotionAggregate
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZoneMotionAggregates : NamiPairingFramework.ZoneMotionAggregatesProtocol, Swift.Decodable {
  public init(zoneId: NamiPairingFramework.PlaceZoneID, aggregates: [NamiPairingFramework.MotionAggregate])
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var aggregates: [NamiPairingFramework.MotionAggregate]
  public typealias Aggregate = NamiPairingFramework.MotionAggregate
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZoneMotionHistoryRequest : Swift.Codable {
  public init(zoneIds: [NamiPairingFramework.PlaceZoneID], from: Foundation.Date, to: Foundation.Date)
  public init(from decoder: any Swift.Decoder) throws
  public var zoneIds: [NamiPairingFramework.PlaceZoneID]
  public var from: Foundation.Date
  public var to: Foundation.Date
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PlaceMotionHistory : NamiPairingFramework.PlaceMotionHistoryProtocol, Swift.Decodable {
  public init(placeId: NamiPairingFramework.PlaceID, motionEvents: [NamiPairingFramework.ActivityEvent], occupancyEvents: [NamiPairingFramework.ActivityEvent])
  public init(from decoder: any Swift.Decoder) throws
  public var placeId: NamiPairingFramework.PlaceID
  public var motionEvents: [NamiPairingFramework.ActivityEvent]
  public var occupancyEvents: [NamiPairingFramework.ActivityEvent]
  public typealias Event = NamiPairingFramework.ActivityEvent
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ZoneMotionHistory : NamiPairingFramework.ZoneMotionHistoryProtocol, Swift.Decodable, Swift.Equatable {
  public init(zoneMotionEvents: [Swift.String : NamiPairingFramework.ZoneMotionEvents])
  public init(from decoder: any Swift.Decoder) throws
  public var zoneMotionEvents: [Swift.String : NamiPairingFramework.ZoneMotionEvents]
  #if compiler(>=5.3) && $NonescapableTypes
  public func motionEventsFor(zone id: NamiPairingFramework.PlaceZoneID) -> NamiPairingFramework.ZoneMotionEvents?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func motionEventsFor(zone urn: Swift.String) -> NamiPairingFramework.ZoneMotionEvents?
  #endif
  public func availableMotionEventZones() -> [NamiPairingFramework.PlaceZoneID]
  public static func == (a: NamiPairingFramework.ZoneMotionHistory, b: NamiPairingFramework.ZoneMotionHistory) -> Swift.Bool
  public typealias ZoneMotionEvent = NamiPairingFramework.ZoneMotionEvents
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ZoneMotionEvents : NamiPairingFramework.ZoneMotionEventProtocol, Swift.Decodable, Swift.Equatable {
  public init(motionEvents: [NamiPairingFramework.ActivityEvent], occupancyEvents: [NamiPairingFramework.ActivityEvent])
  public init(from decoder: any Swift.Decoder) throws
  public var motionEvents: [NamiPairingFramework.ActivityEvent]
  public var occupancyEvents: [NamiPairingFramework.ActivityEvent]
  public static func == (a: NamiPairingFramework.ZoneMotionEvents, b: NamiPairingFramework.ZoneMotionEvents) -> Swift.Bool
  public typealias Event = NamiPairingFramework.ActivityEvent
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ActivityEvent : NamiPairingFramework.ActivityEventProtocol, Swift.Decodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(uuid: Swift.String?, startedAt: Foundation.Date, endedAt: Foundation.Date?, detection: Swift.Bool, health: NamiPairingFramework.ZoneHealth)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(uuid: Foundation.UUID?, startedAt: Foundation.Date, endedAt: Foundation.Date?, detection: Swift.Bool, health: NamiPairingFramework.ZoneHealth)
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public var uuid: Foundation.UUID?
  public var startedAt: Foundation.Date
  public var endedAt: Foundation.Date?
  public var detection: Swift.Bool
  public var health: NamiPairingFramework.ZoneHealth
  public static func == (a: NamiPairingFramework.ActivityEvent, b: NamiPairingFramework.ActivityEvent) -> Swift.Bool
  public typealias ZoneHealth = NamiPairingFramework.ZoneHealth
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct MotionAggregate : NamiPairingFramework.MotionAggregateProtocol, Swift.Decodable {
  public init(metric: Swift.String, resolution: NamiPairingFramework.MotionDataResolution, intervalLength: Foundation.TimeInterval, intervals: [NamiPairingFramework.MotionInterval])
  public var metric: Swift.String
  public var resolution: NamiPairingFramework.MotionDataResolution
  public var intervalLength: Foundation.TimeInterval
  public var intervals: [NamiPairingFramework.MotionInterval]
  public typealias Interval = NamiPairingFramework.MotionInterval
  public typealias Resolution = NamiPairingFramework.MotionDataResolution
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct MotionInterval : NamiPairingFramework.MotionIntervalProtocol, Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
  public init(start: Foundation.Date, value: Swift.UInt8)
  public var start: Foundation.Date
  public var value: Swift.UInt8
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PlaceUserRole : NamiPairingFramework.PlaceUserRoleProtocol, Swift.Codable, Swift.Equatable, Swift.Hashable {
  public init(id: Swift.String, name: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public static var unknown: NamiPairingFramework.PlaceUserRole
  public var id: Swift.String
  public var name: Swift.String
  public static func == (a: NamiPairingFramework.PlaceUserRole, b: NamiPairingFramework.PlaceUserRole) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct PlaceUser : NamiPairingFramework.PlaceUserProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(urn: Swift.String? = nil, id: NamiPairingFramework.PlaceUserID, userId: NamiPairingFramework.UserID, iconId: NamiPairingFramework.UserIconID, themeId: NamiPairingFramework.ThemeID, role: NamiPairingFramework.PlaceUserRole, placeId: NamiPairingFramework.PlaceID, name: Swift.String)
  #endif
  public var urn: Swift.String?
  public var id: NamiPairingFramework.PlaceUserID
  public var userId: NamiPairingFramework.UserID
  public var iconId: NamiPairingFramework.UserIconID
  public var themeId: NamiPairingFramework.ThemeID
  public var role: NamiPairingFramework.PlaceUserRole
  public var placeId: NamiPairingFramework.PlaceID
  public var name: Swift.String
  public static func == (a: NamiPairingFramework.PlaceUser, b: NamiPairingFramework.PlaceUser) -> Swift.Bool
  public typealias ID = NamiPairingFramework.PlaceUserID
  public typealias Role = NamiPairingFramework.PlaceUserRole
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Room : NamiPairingFramework.RoomProtocol, Swift.Codable, Swift.Equatable, Swift.Identifiable {
  public init(id: NamiPairingFramework.RoomID, externalId: Swift.String, urn: Swift.String, name: Swift.String, placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID, iconId: NamiPairingFramework.IconID, createdAt: Foundation.Date, updatedAt: Foundation.Date)
  public var id: NamiPairingFramework.RoomID
  public var externalId: Swift.String
  public var urn: Swift.String
  public var name: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var iconId: NamiPairingFramework.IconID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.Room, b: NamiPairingFramework.Room) -> Swift.Bool
  public typealias ID = NamiPairingFramework.RoomID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CreateRoomRequest : Swift.Encodable {
  public init(name: Swift.String, iconId: NamiPairingFramework.IconID)
  public var name: Swift.String
  public var iconId: NamiPairingFramework.IconID
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct RoomUpdateResponse : Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public init(id: NamiPairingFramework.RoomID, urn: Swift.String, name: Swift.String, placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID, iconId: NamiPairingFramework.IconID, createdAt: Foundation.Date, updatedAt: Foundation.Date)
  public var id: NamiPairingFramework.RoomID
  public var urn: Swift.String
  public var name: Swift.String
  public var placeId: NamiPairingFramework.PlaceID
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var iconId: NamiPairingFramework.IconID
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.RoomUpdateResponse, b: NamiPairingFramework.RoomUpdateResponse) -> Swift.Bool
  public typealias ID = NamiPairingFramework.RoomID
  public init(from decoder: any Swift.Decoder) throws
}
public struct Device : NamiPairingFramework.DeviceProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: NamiPairingFramework.DeviceID, uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, roomId: NamiPairingFramework.RoomID, bleDiscriminator: Swift.Int32?, name: Swift.String, createdAt: Foundation.Date, updatedAt: Foundation.Date, model: NamiPairingFramework.DeviceModel, cloudConnection: NamiPairingFramework.DeviceCloudConnectionStatus? = nil, deviceState: NamiPairingFramework.DeviceCloudState? = nil)
  #endif
  public init(id: NamiPairingFramework.DeviceID, uid: NamiPairingFramework.DeviceUniversalID, urn: Swift.String, roomId: NamiPairingFramework.RoomID, name: Swift.String, createdAt: Foundation.Date, updatedAt: Foundation.Date, model: NamiPairingFramework.DeviceModel)
  public init(from decoder: any Swift.Decoder) throws
  public var id: NamiPairingFramework.DeviceID
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var urn: Swift.String
  public var roomId: NamiPairingFramework.RoomID
  public var bleDiscriminator: Swift.Int32?
  public var name: Swift.String
  public var createdAt: Foundation.Date
  public var updatedAt: Foundation.Date
  public var model: NamiPairingFramework.DeviceModel
  public var cloudConnection: NamiPairingFramework.DeviceCloudConnectionStatus?
  public var deviceState: NamiPairingFramework.DeviceCloudState?
  public static func == (a: NamiPairingFramework.Device, b: NamiPairingFramework.Device) -> Swift.Bool
  public typealias CloudConnection = NamiPairingFramework.DeviceCloudConnectionStatus
  public typealias ID = NamiPairingFramework.DeviceID
  public typealias Model = NamiPairingFramework.DeviceModel
  public typealias State = NamiPairingFramework.DeviceCloudState
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct DeviceCloudConnectionStatus : NamiPairingFramework.DeviceCloudConnectionStatusProtocol, Swift.Decodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(isConnected: Swift.Bool, updatedAt: Foundation.Date? = nil)
  #endif
  public var isConnected: Swift.Bool
  public var updatedAt: Foundation.Date?
  public static func == (a: NamiPairingFramework.DeviceCloudConnectionStatus, b: NamiPairingFramework.DeviceCloudConnectionStatus) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DeviceCloudState : NamiPairingFramework.DeviceCloudStateProtocol, Swift.Decodable, Swift.Equatable {
  public init(payload: Foundation.Data, seqTime: Swift.UInt64, updatedAt: Foundation.Date)
  public init(from decoder: any Swift.Decoder) throws
  public var payload: Foundation.Data
  public var seqTime: Swift.UInt64
  public var updatedAt: Foundation.Date
  public static func == (a: NamiPairingFramework.DeviceCloudState, b: NamiPairingFramework.DeviceCloudState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct DevicesQuery : NamiPairingFramework.DevicesQueryProtocol {
  public init(placeIds: [NamiPairingFramework.PlaceID] = [], zoneIds: [NamiPairingFramework.PlaceZoneID] = [], roomIds: [NamiPairingFramework.RoomID] = [], uids: [NamiPairingFramework.DeviceUniversalID] = [])
  public init(cursor: Swift.String)
  public var placeIds: [NamiPairingFramework.PlaceID]
  public var zoneIds: [NamiPairingFramework.PlaceZoneID]
  public var roomIds: [NamiPairingFramework.RoomID]
  public var uids: [NamiPairingFramework.DeviceUniversalID]
  public var cursor: Swift.String?
  public static func parameters(placeIds: [NamiPairingFramework.PlaceID] = [], zoneIds: [NamiPairingFramework.PlaceZoneID] = [], roomIds: [NamiPairingFramework.RoomID] = [], uids: [NamiPairingFramework.DeviceUniversalID] = []) -> NamiPairingFramework.DevicesQuery
  public static func cursor(_ cursor: Swift.String) -> NamiPairingFramework.DevicesQuery
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DevicesResponse : NamiPairingFramework.DevicesResponseProtocol, Swift.Decodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(devices: [NamiPairingFramework.Device], total: Swift.Int, pageSize: Swift.Int, cursor: Swift.String? = nil)
  #endif
  public var devices: [NamiPairingFramework.Device]
  public var total: Swift.Int
  public var pageSize: Swift.Int
  public var cursor: Swift.String?
  public typealias Device = NamiPairingFramework.Device
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DeviceModel : NamiPairingFramework.DeviceModelProtocol, Swift.Decodable, Swift.Equatable {
  public init(codeName: Swift.String, productLabel: Swift.String, productId: NamiPairingFramework.DeviceProductID)
  public var codeName: Swift.String
  public var productLabel: Swift.String
  public var productId: NamiPairingFramework.DeviceProductID
  public static func == (a: NamiPairingFramework.DeviceModel, b: NamiPairingFramework.DeviceModel) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DevicesCommandRequest : Swift.Encodable, Swift.Equatable {
  public init(seqTime: Swift.UInt64, commands: [NamiPairingFramework.DevicesCommand])
  public var seqTime: Swift.UInt64
  public var commands: [NamiPairingFramework.DevicesCommand]
  public static func == (a: NamiPairingFramework.DevicesCommandRequest, b: NamiPairingFramework.DevicesCommandRequest) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct DevicesCommand : Swift.Encodable, Swift.Equatable {
  public init(devicesUids: [NamiPairingFramework.DeviceUniversalID], messages: [Foundation.Data])
  public var devicesUids: [NamiPairingFramework.DeviceUniversalID]
  public var messages: [Foundation.Data]
  public static func == (a: NamiPairingFramework.DevicesCommand, b: NamiPairingFramework.DevicesCommand) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct DevicesCommandResponse : NamiPairingFramework.DevicesCommandResponseProtocol, Swift.Decodable {
  public init(seqTime: Swift.UInt64, results: [NamiPairingFramework.DeviceCommandResponseResult])
  public var seqTime: Swift.UInt64
  public var results: [NamiPairingFramework.DeviceCommandResponseResult]
  public typealias Result = NamiPairingFramework.DeviceCommandResponseResult
  public init(from decoder: any Swift.Decoder) throws
}
public struct DeviceCommandResponseResult : NamiPairingFramework.DevicesCommandResponseResultProtocol, Swift.Decodable {
  public init(devices: [NamiPairingFramework.DeviceUniversalID : NamiPairingFramework.DeviceCommandResponseContent])
  public init(from decoder: any Swift.Decoder) throws
  public var devices: [NamiPairingFramework.DeviceUniversalID : NamiPairingFramework.DeviceCommandResponseContent]
  public typealias DeviceCommandResponseContent = NamiPairingFramework.DeviceCommandResponseContent
}
public struct DeviceCommandResponseContent : NamiPairingFramework.DeviceCommandResponseContentProtocol, Swift.Decodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(success: Swift.Bool, error: NamiPairingFramework.DeviceCommandResponseContent.DeviceCommandResponseError? = nil)
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public struct DeviceCommandResponseError : Swift.Error, NamiPairingFramework.DeviceCommandResponseErrorProtocol {
    public var error: Swift.String
    public var errorCode: Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public var success: Swift.Bool
  public var error: NamiPairingFramework.DeviceCommandResponseContent.DeviceCommandResponseError?
}
public struct ListAutomationResponse : Swift.Decodable {
  public init(placeId: NamiPairingFramework.PlaceID, automations: [NamiPairingFramework.Automation])
  public init(from decoder: any Swift.Decoder) throws
  public var placeId: NamiPairingFramework.PlaceID
  public var automations: [NamiPairingFramework.Automation]
}
public struct Automation : NamiPairingFramework.AutomationProtocol, Swift.Decodable, Swift.Identifiable {
  public init(id: NamiPairingFramework.AutomationID, urn: Swift.String, trigger: NamiPairingFramework.AutomationTrigger, reactions: [NamiPairingFramework.AutomationReaction], active: Swift.Bool)
  public init(from decoder: any Swift.Decoder) throws
  public var id: NamiPairingFramework.AutomationID
  public var urn: Swift.String
  public var trigger: NamiPairingFramework.AutomationTrigger
  public var reactions: [NamiPairingFramework.AutomationReaction]
  public var active: Swift.Bool
  public typealias ID = NamiPairingFramework.AutomationID
  public typealias Reaction = NamiPairingFramework.AutomationReaction
  public typealias Trigger = NamiPairingFramework.AutomationTrigger
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct AutomationTrigger : NamiPairingFramework.AutomationTriggerProtocol, Swift.Decodable, Swift.Encodable {
  public init(type: Swift.String, hour: Swift.Int, minute: Swift.Int, daysOfWeek: [Swift.String])
  public init(from decoder: any Swift.Decoder) throws
  public var type: Swift.String
  public var hour: Swift.Int
  public var minute: Swift.Int
  public var daysOfWeek: [Swift.String]
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct AutomationReaction : NamiPairingFramework.AutomationReactionProtocol, Swift.Codable {
  public init(uuid: Swift.String, targetType: Swift.String, targetIds: [NamiPairingFramework.PlaceZoneID], action: NamiPairingFramework.AutomationAction)
  public init(from decoder: any Swift.Decoder) throws
  public var uuid: Swift.String
  public var targetType: Swift.String
  public var targetIds: [NamiPairingFramework.PlaceZoneID]
  public var action: NamiPairingFramework.AutomationAction
  public typealias Action = NamiPairingFramework.AutomationAction
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct AutomationAction : NamiPairingFramework.AutomationActionProtocol, Swift.Decodable, Swift.Encodable {
  public init(type: Swift.String, mode: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public var type: Swift.String
  public var mode: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct CreateAutomationRequest : Swift.Encodable {
  public init(alertMode: NamiPairingFramework.AlertMode, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct UpdateAutomationRequest : Swift.Encodable {
  public init(alertMode: NamiPairingFramework.AlertMode, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct EnableAutomationRequest : Swift.Encodable {
  public init(enable: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ChangeAutomationActiveRequest : Swift.Encodable {
  public init(enable: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct AutomationResponse : Swift.Decodable {
  public init(automation: NamiPairingFramework.Automation)
  public init(from decoder: any Swift.Decoder) throws
  public var automation: NamiPairingFramework.Automation
}
public struct PairingChallengeRequest : Swift.Encodable {
  public init(certificate: Swift.String)
  public var certificate: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PairingChallengeResponse : NamiPairingFramework.PairingChallengeResponseProtocol, Swift.Decodable {
  public init(challenge: Swift.String, model: NamiPairingFramework.DeviceModel)
  public var challenge: Swift.String
  public var model: NamiPairingFramework.DeviceModel
  public typealias DeviceModel = NamiPairingFramework.DeviceModel
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairDeviceRequest : Swift.Encodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(deviceName: Swift.String, cloudChallenge: Swift.String, deviceResponse: Swift.String, deviceCertificate: Swift.String, intent: Swift.String?)
  #endif
  public var deviceName: Swift.String
  public var cloudChallenge: Swift.String
  public var deviceResponse: Swift.String
  public var deviceCertificate: Swift.String
  public var intent: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PairDeviceResponse : NamiPairingFramework.PairDeviceResponseProtocol, Swift.Decodable {
  public init(payload: NamiPairingFramework.WiredPlaceKeys, device: NamiPairingFramework.Device)
  public var payload: NamiPairingFramework.WiredPlaceKeys
  public var device: NamiPairingFramework.Device
  public typealias Device = NamiPairingFramework.Device
  public typealias WiredPlaceKeys = NamiPairingFramework.WiredPlaceKeys
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct MoveDevicesRequest : Swift.Encodable {
  public init(devices: [NamiPairingFramework.DeviceUniversalID])
  public var devices: [NamiPairingFramework.DeviceUniversalID]
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct MoveDevicesResponse : NamiPairingFramework.MoveDevicesResponseProtocol, Swift.Decodable {
  public init(devices: [NamiPairingFramework.Device])
  public var devices: [NamiPairingFramework.Device]
  public typealias Device = NamiPairingFramework.Device
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NamiPushRegistrationRequest : Swift.Encodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(token: Swift.String, os: Swift.String, osVersion: Swift.String, languages: [Swift.String], bundleName: Swift.String, bundleVersion: Swift.String, build: Swift.String, utcOffset: Swift.Int, apnEnvDevelopment: Swift.Bool? = nil)
  #endif
  public var token: Swift.String
  public var os: Swift.String
  public var osVersion: Swift.String
  public var languages: [Swift.String]
  public var bundleName: Swift.String
  public var bundleVersion: Swift.String
  public var build: Swift.String
  public var utcOffset: Swift.Int
  public var apnEnvDevelopment: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum AlertMode : Swift.String, NamiPairingFramework.AlertModeProtocol, Swift.Codable {
  case relaxed
  case aware
  case armed
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct EngineConfig : NamiPairingFramework.EngineConfigProtocol, Swift.Decodable, Swift.Encodable, Swift.Equatable {
  public init(type: NamiPairingFramework.EngineType, sensitivityLevel: Swift.Int)
  public var type: NamiPairingFramework.EngineType
  public var sensitivityLevel: Swift.Int
  public static func == (a: NamiPairingFramework.EngineConfig, b: NamiPairingFramework.EngineConfig) -> Swift.Bool
  public typealias EngineType = NamiPairingFramework.EngineType
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum EngineType : Swift.String, NamiPairingFramework.EngineTypeProtocol, Swift.Codable {
  case motion
  case security
  case aerialMotionV1
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct EngineConfigRequest : Swift.Encodable, Swift.Equatable {
  public init(type: NamiPairingFramework.EngineType.RawValue, sensitivityLevel: Swift.Int)
  public init(type: NamiPairingFramework.EngineType, sensitivityLevel: Swift.Int)
  public var type: NamiPairingFramework.EngineType.RawValue
  public var sensitivityLevel: Swift.Int
  public static func == (a: NamiPairingFramework.EngineConfigRequest, b: NamiPairingFramework.EngineConfigRequest) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
public typealias SetSensitivityLevelResponse = NamiPairingFramework.Place
public typealias PlaceUpdateResponse = NamiPairingFramework.Place
public struct AlertNotification : Swift.Decodable, Swift.Identifiable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: NamiPairingFramework.NamiAlertID, placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID, cause: Swift.String, startTime: Foundation.Date, reason: NamiPairingFramework.AlertReason, uid: NamiPairingFramework.DeviceUniversalID?)
  #endif
  public var id: NamiPairingFramework.NamiAlertID
  public var placeId: NamiPairingFramework.PlaceID
  public var zoneId: NamiPairingFramework.PlaceZoneID
  public var cause: Swift.String
  public var startTime: Foundation.Date
  public var reason: NamiPairingFramework.AlertReason
  public var uid: NamiPairingFramework.DeviceUniversalID?
  public typealias ID = NamiPairingFramework.NamiAlertID
  public init(from decoder: any Swift.Decoder) throws
}
public enum AlertReason : Swift.String, Swift.Codable {
  case motion
  case device
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct PlaceEventActor : Swift.Decodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(urn: NamiPairingFramework.URN? = nil, name: Swift.String, themeId: NamiPairingFramework.ThemeID = 0, iconId: NamiPairingFramework.IconID = 0)
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public var urn: NamiPairingFramework.URN?
  public var name: Swift.String
  public var themeId: NamiPairingFramework.IconID
  public var iconId: NamiPairingFramework.UserIconID
  #if compiler(>=5.3) && $NonescapableTypes
  public var userId: NamiPairingFramework.UserID? {
    get
  }
  #endif
  public static func == (a: NamiPairingFramework.PlaceEventActor, b: NamiPairingFramework.PlaceEventActor) -> Swift.Bool
}
public enum PlaceEventCause : Swift.String, Swift.Decodable, Swift.Equatable {
  case intrusion
  case userJoined
  case userLeft
  case userRemoved
  case unknown
  public init(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public protocol EventPayload : Swift.Decodable {
}
public struct RenderableEventsResponse : Swift.Decodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(placeId: NamiPairingFramework.PlaceID, timeCalculation: NamiPairingFramework.TimeCalculation?, events: [NamiPairingFramework.RenderableEvent], total: Swift.Int, pageSize: Swift.Int, cursor: Swift.String? = nil)
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public var placeId: NamiPairingFramework.PlaceID
  public var timeCalculation: NamiPairingFramework.TimeCalculation?
  public var events: [NamiPairingFramework.RenderableEvent]
  public var total: Swift.Int
  public var pageSize: Swift.Int
  public var cursor: Swift.String?
}
public enum TimeCalculation : Swift.Decodable {
  case timeZone
  case utcOffset
  case unknown(Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: NamiPairingFramework.TimeCalculation.RawValue)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: NamiPairingFramework.TimeCalculation.RawValue {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct RenderableEvent : Swift.Decodable, Swift.Equatable {
  public init(id: NamiPairingFramework.EventID, cause: NamiPairingFramework.PlaceEventCause, renders: [NamiPairingFramework.RenderableEventRenders])
  public init(from decoder: any Swift.Decoder) throws
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case id
    case cause
    case renders
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(stringValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(intValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public var intValue: Swift.Int? {
      get
    }
    #endif
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var id: NamiPairingFramework.EventID
  public var cause: NamiPairingFramework.PlaceEventCause
  public var renders: [NamiPairingFramework.RenderableEventRenders]
  public static func == (a: NamiPairingFramework.RenderableEvent, b: NamiPairingFramework.RenderableEvent) -> Swift.Bool
}
public struct RenderableEventRenders : Swift.Decodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(shape: NamiPairingFramework.RenderableEventShape, eventTime: Foundation.Date, eventStartTime: Foundation.Date? = nil, eventEndTime: Foundation.Date? = nil, subject: Swift.String, fields: [NamiPairingFramework.RenderableEventField], icon_ids: [Swift.String])
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case shape
    case eventTime
    case eventStartTime
    case eventEndTime
    case subject
    case fields
    case icon_ids
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(stringValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(intValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public var intValue: Swift.Int? {
      get
    }
    #endif
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var shape: NamiPairingFramework.RenderableEventShape
  public var eventTime: Foundation.Date
  public var eventStartTime: Foundation.Date?
  public var eventEndTime: Foundation.Date?
  public var subject: Swift.String
  public var fields: [NamiPairingFramework.RenderableEventField]
  public var icon_ids: [Swift.String]
  public static func == (a: NamiPairingFramework.RenderableEventRenders, b: NamiPairingFramework.RenderableEventRenders) -> Swift.Bool
}
public enum RenderableEventShape : Swift.String, Swift.Decodable, Swift.Equatable {
  case listOfFieldsV1
  case unknown
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: NamiPairingFramework.RenderableEventShape.RawValue)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct RenderableEventField : Swift.Decodable, Swift.Equatable {
  public init(type: NamiPairingFramework.RenderableEventType, values: [Swift.String])
  public init(from decoder: any Swift.Decoder) throws
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case type
    case values
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(stringValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(intValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public var intValue: Swift.Int? {
      get
    }
    #endif
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public var type: NamiPairingFramework.RenderableEventType
  public var values: [Swift.String]
  public static func == (a: NamiPairingFramework.RenderableEventField, b: NamiPairingFramework.RenderableEventField) -> Swift.Bool
}
public enum RenderableEventType : Swift.String, Swift.Decodable, Swift.Equatable {
  case duration
  case location
  case userWithText
  case setting
  case trigger
  case unknown
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: NamiPairingFramework.RenderableEventType.RawValue)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: NamiPairingFramework.RenderableEventType.RawValue {
    get
  }
}
public struct MembershipResponse : NamiPairingFramework.MembershipResponseProtocol, Swift.Decodable {
  public init(users: [NamiPairingFramework.PlaceUser], invites: [NamiPairingFramework.InviteLink])
  public var users: [NamiPairingFramework.PlaceUser]
  public var invites: [NamiPairingFramework.InviteLink]
  public typealias Invite = NamiPairingFramework.InviteLink
  public typealias User = NamiPairingFramework.PlaceUser
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct InvitePeek : NamiPairingFramework.InvitePeekProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public init(code: NamiPairingFramework.InviteCode, name: Swift.String, role: NamiPairingFramework.PlaceUserRole, placeId: NamiPairingFramework.PlaceID, placeName: Swift.String, placeIconId: NamiPairingFramework.IconID)
  public var code: NamiPairingFramework.InviteCode
  public var name: Swift.String
  public var role: NamiPairingFramework.PlaceUserRole
  public var placeId: NamiPairingFramework.PlaceID
  public var placeName: Swift.String
  public var placeIconId: NamiPairingFramework.IconID
  public var id: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.InvitePeek, b: NamiPairingFramework.InvitePeek) -> Swift.Bool
  public typealias ID = Swift.String
  public typealias Role = NamiPairingFramework.PlaceUserRole
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct InviteLink : NamiPairingFramework.InviteLinkProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(code: NamiPairingFramework.InviteCode, name: Swift.String, role: NamiPairingFramework.PlaceUserRole, placeId: NamiPairingFramework.PlaceID, placeName: Swift.String? = nil, state: Swift.String, inviteUrl: Foundation.URL, expiresAt: Foundation.Date)
  #endif
  public var code: NamiPairingFramework.InviteCode
  public var name: Swift.String
  public var role: NamiPairingFramework.PlaceUserRole
  public var placeId: NamiPairingFramework.PlaceID
  public var placeName: Swift.String?
  public var state: Swift.String
  public var inviteUrl: Foundation.URL
  public var expiresAt: Foundation.Date
  public var id: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.InviteLink, b: NamiPairingFramework.InviteLink) -> Swift.Bool
  public typealias ID = Swift.String
  public typealias Role = NamiPairingFramework.PlaceUserRole
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CodeSessionInfo : Swift.Decodable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(code: NamiPairingFramework.SessionCode, partnerName: Swift.String, partnerLogoUrl: Foundation.URL?, redirectUri: Foundation.URL, placeName: Swift.String, expiresAt: Foundation.Date)
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public var code: NamiPairingFramework.SessionCode
  public var partnerName: Swift.String
  public var partnerLogoUrl: Foundation.URL?
  public var redirectUri: Foundation.URL
  public var placeName: Swift.String
  public var expiresAt: Foundation.Date
  public static func == (a: NamiPairingFramework.CodeSessionInfo, b: NamiPairingFramework.CodeSessionInfo) -> Swift.Bool
}
public struct SessionCodeActivateResult : Swift.Decodable {
  public init(sessionParameters: NamiPairingFramework.SessionParameters, authentication: NamiPairingFramework.CompanionModeAuthentication, place: NamiPairingFramework.Place)
  public var sessionParameters: NamiPairingFramework.SessionParameters
  public var authentication: NamiPairingFramework.CompanionModeAuthentication
  public var place: NamiPairingFramework.Place
  public init(from decoder: any Swift.Decoder) throws
}
public struct SessionParameters : Swift.Codable, Swift.Equatable {
  public init(permissions: [Swift.String], mode: Swift.String, flatModeDefaults: [Swift.String : Swift.Int64], partnerName: Swift.String, partnerLogoUrl: Foundation.URL, redirectUri: Foundation.URL)
  public var permissions: [NamiPairingFramework.SessionPermission]
  public var mode: Swift.String
  public var flatModeDefaults: [Swift.String : Swift.Int64]
  public var partnerName: Swift.String
  public var partnerLogoUrl: Foundation.URL?
  public var redirectUri: Foundation.URL
  public static func == (a: NamiPairingFramework.SessionParameters, b: NamiPairingFramework.SessionParameters) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CompanionModeUser : Swift.Decodable {
  public init(id: NamiPairingFramework.UserID, username: Swift.String)
  public var id: NamiPairingFramework.UserID
  public var username: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public struct CompanionModeAuthentication : Swift.Decodable {
  public init(user: NamiPairingFramework.CompanionModeUser, accessToken: NamiPairingFramework.AccessToken, refreshToken: NamiPairingFramework.TokenString)
  public var user: NamiPairingFramework.CompanionModeUser
  public var accessToken: NamiPairingFramework.AccessToken
  public var refreshToken: NamiPairingFramework.TokenString
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlaceEventsQuery {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(placeId: NamiPairingFramework.PlaceID, cursor: Swift.String? = nil, preferredLanguages: [Swift.String], timeZone: Swift.String, utcOffset: Swift.String, fromDate: Foundation.Date? = nil, toDate: Foundation.Date? = nil)
  #endif
  public var placeId: NamiPairingFramework.PlaceID
  public var cursor: Swift.String?
  public var preferredLanguages: [Swift.String]
  public var timeZone: Swift.String
  public var utcOffset: Swift.String
  public var fromDate: Foundation.Date?
  public var toDate: Foundation.Date?
}
public struct RenderablePlaceEventsQuery {
  public var placeId: NamiPairingFramework.PlaceID
  public var preferredLanguages: [Swift.String]
  public var timeZone: Foundation.TimeZone
  public var cursor: Swift.String?
}
public struct RestEventsResponse : NamiPairingFramework.RestEventsResponseProtocol, Swift.Decodable {
  public init(restEvents: [NamiPairingFramework.RestEvent])
  public var restEvents: [NamiPairingFramework.RestEvent]
  public typealias RestEvent = NamiPairingFramework.RestEvent
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RestEvent : NamiPairingFramework.RestEventProtocol, Swift.Decodable {
  public var deviceUid: NamiPairingFramework.DeviceUniversalID
  public var startedAt: Foundation.Date
  public var endedAt: Foundation.Date
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RestInsight : NamiPairingFramework.RestInsightProtocol, Swift.Decodable {
  public var deviceUid: NamiPairingFramework.DeviceUniversalID
  public var totalRestTime: Swift.Int
  public var numberOfInterruptions: Swift.Int
  public var timeToBed: Foundation.Date?
  public var outOfBedAt: Foundation.Date?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RestInsightsResponse : NamiPairingFramework.RestInsightsResponseProtocol, Swift.Decodable {
  public init(restInsights: [NamiPairingFramework.RestInsight])
  public var restInsights: [NamiPairingFramework.RestInsight]
  public typealias RestInsight = NamiPairingFramework.RestInsight
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DeviceAttributeStateResponse : NamiPairingFramework.DeviceAttributeStateResponseProtocol, Swift.Decodable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(devices: [NamiPairingFramework.DeviceAttributeState], total: Swift.Int, pageSize: Swift.Int, cursor: Swift.String? = nil)
  #endif
  public var deviceAttributeStates: [NamiPairingFramework.DeviceAttributeState]
  public var total: Swift.Int
  public var pageSize: Swift.Int
  public var cursor: Swift.String?
  public init(from decoder: any Swift.Decoder) throws
  public typealias DeviceAttributeState = NamiPairingFramework.DeviceAttributeState
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct DeviceAttributeState : NamiPairingFramework.DeviceAttributeStateProtocol, Swift.Decodable {
  public var uid: NamiPairingFramework.DeviceUniversalID
  public var endpoint: Swift.Int
  public var path: Swift.String
  public var value: Swift.String?
  public var updatedAt: Foundation.Date
  public var isDeleted: Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct DeviceAttributeStatesQuery {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(placeIds: [NamiPairingFramework.PlaceID] = [], zoneIds: [NamiPairingFramework.PlaceZoneID] = [], roomIds: [NamiPairingFramework.RoomID] = [], uids: [NamiPairingFramework.DeviceUniversalID] = [], from: Foundation.Date? = nil, to: Foundation.Date? = nil, cursor: Swift.String? = nil)
  #endif
  public var placeIds: [NamiPairingFramework.PlaceID]
  public var zoneIds: [NamiPairingFramework.PlaceZoneID]
  public var roomIds: [NamiPairingFramework.RoomID]
  public var uids: [NamiPairingFramework.DeviceUniversalID]
  public var from: Foundation.Date?
  public var to: Foundation.Date?
  public var cursor: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  public static func parameters(placeIds: [NamiPairingFramework.PlaceID] = [], zoneIds: [NamiPairingFramework.PlaceZoneID] = [], roomIds: [NamiPairingFramework.RoomID] = [], uids: [NamiPairingFramework.DeviceUniversalID] = [], from: Foundation.Date? = nil, to: Foundation.Date? = nil, cursor: Swift.String? = nil) -> NamiPairingFramework.DeviceAttributeStatesQuery
  #endif
  public func getQueryItems() -> [Foundation.URLQueryItem]
}
public struct PinHashingParameters : Swift.Decodable {
  public var salt: Swift.String
  public var iterations: Swift.Int
  public var hashFunction: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public struct CreatePinCredentialRequest : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct UpdatePinCredentialRequest : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PinCredentialRecord : Swift.Decodable, Swift.Identifiable {
  public var id: NamiPairingFramework.PinCredentialID
  public var name: Swift.String
  public init(id: NamiPairingFramework.PinCredentialID, name: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public typealias ID = NamiPairingFramework.PinCredentialID
}
public struct PinVerificationRequest : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PinVerificationResult : Swift.Decodable, Swift.Error {
  public var errorCode: Swift.String
  public var error: Swift.String
  public var errorDetails: NamiPairingFramework.PinVerificationResultError
  public init(errorCode: Swift.String, error: Swift.String, errorDetails: NamiPairingFramework.PinVerificationResultError)
  public init(from decoder: any Swift.Decoder) throws
}
public struct PinVerificationResultError : Swift.Decodable {
  public var attribute: Swift.String
  public init(attribute: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
public protocol NetworkSession : AnyObject {
  #if compiler(>=5.3) && $NonescapableTypes
  func publisher(for request: Foundation.URLRequest, token: NamiPairingFramework.AccessToken?) -> Combine.AnyPublisher<Foundation.Data, any Swift.Error>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func publisher(for request: Foundation.URLRequest, token: NamiPairingFramework.AccessToken?, retries: Swift.Int, backoffBase: Swift.Double, jitter: NamiPairingFramework.JitterStrategy) -> Combine.AnyPublisher<Foundation.Data, any Swift.Error>
  #endif
}
extension NamiPairingFramework.NetworkSession {
  #if compiler(>=5.3) && $NonescapableTypes
  public func publisher(for request: Foundation.URLRequest, token: NamiPairingFramework.AccessToken?, retries: Swift.Int, backoffBase: Swift.Double, jitter: NamiPairingFramework.JitterStrategy = .none) -> Combine.AnyPublisher<Foundation.Data, any Swift.Error>
  #endif
}
public enum JitterStrategy {
  case none
  case full
  case equal
  case decorrelated
  public static func == (a: NamiPairingFramework.JitterStrategy, b: NamiPairingFramework.JitterStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URLSession : NamiPairingFramework.NetworkSession {
  #if compiler(>=5.3) && $NonescapableTypes
  public func publisher(for request: Foundation.URLRequest, token: NamiPairingFramework.AccessToken?) -> Combine.AnyPublisher<Foundation.Data, any Swift.Error>
  #endif
}
public enum ConflictErrorCode : Swift.String, Swift.Codable {
  case collisionInAutomation
  case malformedRequest
  case unexpectedTypeError
  case paramOutOfRange
  case notADay
  case sessionCodeAlreadyActivated
  case sessionCodeExpired
  case unknown
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct CollisionTrigger : Swift.Decodable {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case daysOfWeek
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(stringValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(intValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public var intValue: Swift.Int? {
      get
    }
    #endif
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(from decoder: any Swift.Decoder) throws
  public var daysOfWeek: [Swift.String]
}
public struct CollisionReaction : Swift.Decodable {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case uuid
    case targetIds
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(stringValue: Swift.String)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(intValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public var intValue: Swift.Int? {
      get
    }
    #endif
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(from decoder: any Swift.Decoder) throws
  public var uuid: Swift.String
  public var targetIds: [NamiPairingFramework.PlaceZoneID]
}
public struct CollisionsErrorBody : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
  public var trigger: NamiPairingFramework.CollisionTrigger
  public var reactions: [NamiPairingFramework.CollisionReaction]
}
public struct CollisionInAutomation : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
  public var errorCode: NamiPairingFramework.ConflictErrorCode
  public var collisions: NamiPairingFramework.CollisionsErrorBody
}
public struct NetworkError : Swift.Error {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(statusCode: Swift.Int, body: Foundation.Data? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(_ urlError: Foundation.URLError, body: Foundation.Data? = nil)
  #endif
  public static var unknown: NamiPairingFramework.NetworkError
  public let code: NamiPairingFramework.NetworkErrorCode
  public var isRecoverable: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var customErrorDescription: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func decodeBody<ErrorBody>(to type: ErrorBody.Type) -> ErrorBody? where ErrorBody : Swift.Decodable
  #endif
}
public enum NetworkErrorCode : Swift.Equatable {
  case unknown(Swift.Int)
  case connectionError(Foundation.URLError)
  case invalidParameters
  case unauthorized
  case notFound
  case conflict
  case serverError
  case forbidden
  public init(statusCode: Swift.Int)
  public init(urlError: Foundation.URLError)
  public var code: Swift.Int {
    get
  }
  public static func == (lhs: NamiPairingFramework.NetworkErrorCode, rhs: NamiPairingFramework.NetworkErrorCode) -> Swift.Bool
}
extension Foundation.URL {
  #if compiler(>=5.3) && $NonescapableTypes
  public func valueOf(_ queryParameterName: Swift.String) -> Swift.String?
  #endif
}
extension Foundation.URLRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(method: Swift.String = "GET", base: Foundation.URL, path: Swift.String, query: [Swift.String : Swift.String], headers: [Swift.String : Swift.String] = [:], body: Foundation.Data? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(method: Swift.String = "GET", base: Foundation.URL, path: Swift.String, query: [Foundation.URLQueryItem] = [], headers: [Swift.String : Swift.String] = [:], body: Foundation.Data? = nil)
  #endif
}
public protocol WebAPIProtocol {
  var errorPublisher: Combine.PassthroughSubject<any Swift.Error, Swift.Never> { get }
  func signUpAnonymously() -> Combine.AnyPublisher<NamiPairingFramework.AnonymousUserResponse, any Swift.Error>
  func signUp(with provider: NamiPairingFramework.OAuthProvider, signUpPath: Swift.String, callbackURLScheme: Swift.String, contextProvider: any AuthenticationServices.ASWebAuthenticationPresentationContextProviding) -> Combine.AnyPublisher<NamiPairingFramework.UserResponse, any Swift.Error>
  func connect(using provider: NamiPairingFramework.OAuthProvider, signUpPath: Swift.String, callbackURLScheme: Swift.String, contextProvider: any AuthenticationServices.ASWebAuthenticationPresentationContextProviding) -> Combine.AnyPublisher<NamiPairingFramework.User, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  func updateUserProfile(username: Swift.String, iconId: NamiPairingFramework.UserIconID?, themeId: NamiPairingFramework.IconID?) -> Combine.AnyPublisher<NamiPairingFramework.User, any Swift.Error>
  #endif
  func userProfile() -> Combine.AnyPublisher<NamiPairingFramework.User, any Swift.Error>
  func recoverUser(with key: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.AnonymousUserResponse, any Swift.Error>
  func deleteUser() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  func authorize(provider: NamiPairingFramework.OAuthProvider, idToken: Swift.String, authCode: Swift.String?) -> Combine.AnyPublisher<NamiPairingFramework.UserResponse, any Swift.Error>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func link(provider: NamiPairingFramework.OAuthProvider, idToken: Swift.String, authCode: Swift.String?) -> Combine.AnyPublisher<NamiPairingFramework.User, any Swift.Error>
  #endif
  func unlink(provider: Swift.String, providerUserId: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.User, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  func createPlace(name: Swift.String, theme: NamiPairingFramework.ThemeID, icon: NamiPairingFramework.IconID, timeZone: Swift.String?, propertyTypeId: NamiPairingFramework.PropertyTypeID, propertyElevationId: NamiPairingFramework.PropertyElevationID, propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID, petTypeId: NamiPairingFramework.PetTypeID, zoneName: Swift.String?, getPlaceKey: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  #endif
  func listPlaces() -> Combine.AnyPublisher<NamiPairingFramework.PlacesResponse, any Swift.Error>
  func getPlace(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  func updatePlace(id: NamiPairingFramework.PlaceID, name: Swift.String, theme: NamiPairingFramework.ThemeID, icon: NamiPairingFramework.IconID, timeZone: Swift.String?, propertyTypeId: NamiPairingFramework.PropertyTypeID?, propertyElevationId: NamiPairingFramework.PropertyElevationID?, propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID?, petTypeId: NamiPairingFramework.PetTypeID?, engineType: NamiPairingFramework.EngineType?, entryDelay: NamiPairingFramework.EntryDelay?, exitDelay: NamiPairingFramework.ExitDelay?) -> Combine.AnyPublisher<NamiPairingFramework.PlaceUpdateResponse, any Swift.Error>
  #endif
  func leavePlace(id: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.PlacesResponse, any Swift.Error>
  func deletePlace(id: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func deletePlaceZone(in placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  func deletePlaceRoom(in placeId: NamiPairingFramework.PlaceID, roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  func createWiFiCredentialsUpdateSession(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  func getAllWiFiCredentialsUpdateSessions() -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsSessionsResponse, any Swift.Error>
  func getWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  func deleteDeviceFromSession(uid: NamiPairingFramework.DeviceUniversalID, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  func resetWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  func createOrResetWiFiCredentialsUpdateSession(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  func listPlaceMembers(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  func deletePlaceUser(from placeId: NamiPairingFramework.PlaceID, user userId: NamiPairingFramework.UserID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  func updatePlaceUser(for placeId: NamiPairingFramework.PlaceID, userId: NamiPairingFramework.UserID, role: NamiPairingFramework.PlaceUserRole) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  func revokeInvite(code: NamiPairingFramework.InviteCode, from placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  func invitationDetails(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<NamiPairingFramework.InvitePeek, any Swift.Error>
  func acceptInvitation(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<NamiPairingFramework.PlacesResponse, any Swift.Error>
  func declineInvitation(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func listPlaceKeys() -> Combine.AnyPublisher<[NamiPairingFramework.CloudPlaceKey], any Swift.Error>
  func createZone(place: NamiPairingFramework.PlaceID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZone, any Swift.Error>
  func updateZone(id: NamiPairingFramework.PlaceZoneID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZone, any Swift.Error>
  func createRoom(zone: NamiPairingFramework.PlaceZoneID, name: Swift.String, icon: NamiPairingFramework.IconID) -> Combine.AnyPublisher<NamiPairingFramework.Room, any Swift.Error>
  func updateRoom(id: NamiPairingFramework.RoomID, name: Swift.String, icon: NamiPairingFramework.IconID) -> Combine.AnyPublisher<NamiPairingFramework.Room, any Swift.Error>
  func listDevices(query: NamiPairingFramework.DevicesQuery) -> Combine.AnyPublisher<NamiPairingFramework.DevicesResponse, any Swift.Error>
  func collectDevices(query: NamiPairingFramework.DevicesQuery) -> Combine.AnyPublisher<[NamiPairingFramework.Device], any Swift.Error>
  func deleteDevice(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func moveDevices(deviceUIDs: [NamiPairingFramework.DeviceUniversalID], roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.MoveDevicesResponse, any Swift.Error>
  func renameDevice(id: NamiPairingFramework.DeviceID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.Device, any Swift.Error>
  func sendDeviceCommandRequests(in placeId: NamiPairingFramework.PlaceID, uids: [NamiPairingFramework.DeviceUniversalID], messages: [Foundation.Data]) -> Combine.AnyPublisher<NamiPairingFramework.DevicesCommandResponse, any Swift.Error>
  func listAutomation(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.ListAutomationResponse, any Swift.Error>
  func createAutomation(placeId: NamiPairingFramework.PlaceID, alertMode: NamiPairingFramework.AlertMode, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  func updateAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, alertMode: NamiPairingFramework.AlertMode, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  func changeAutomationActive(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, active: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  func enableAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  func disableAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  func deleteAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  func requestPairingChallenge(roomId: NamiPairingFramework.RoomID, deviceCertificate: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PairingChallengeResponse, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  func pairDevice(roomId: NamiPairingFramework.RoomID, deviceName: Swift.String, cloudChallenge: Swift.String, deviceResponse: Swift.String, deviceCertificate: Swift.String, intent: Swift.String?) -> Combine.AnyPublisher<NamiPairingFramework.PairDeviceResponse, any Swift.Error>
  #endif
  func notifyPushesAllowed(pushRequest: NamiPairingFramework.NamiPushRegistrationRequest) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func sendTestPush() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func loadAlertNotifications() -> Combine.AnyPublisher<[NamiPairingFramework.AlertNotification], any Swift.Error>
  func loadEventsHistory(query: NamiPairingFramework.PlaceEventsQuery) -> Combine.AnyPublisher<NamiPairingFramework.RenderableEventsResponse, any Swift.Error>
  func getAllMotionData() -> Combine.AnyPublisher<[NamiPairingFramework.PlaceMotionAggregates], any Swift.Error>
  func getPlaceMotionHistory(for placeId: NamiPairingFramework.PlaceID, from: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.PlaceMotionHistory, any Swift.Error>
  func getZoneMotionHistory(for zoneIds: [NamiPairingFramework.PlaceZoneID], from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.ZoneMotionHistory, any Swift.Error>
  func getMotionDataAggregates(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.PlaceMotionAggregates, any Swift.Error>
  func getMotionDataAggregates(for zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.ZoneMotionAggregates, any Swift.Error>
  func changeEngineConfig(for placeId: NamiPairingFramework.PlaceID, to type: NamiPairingFramework.EngineType, level: Swift.Int) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZone], any Swift.Error>
  func setSensitivityLevel(for placeId: NamiPairingFramework.PlaceID, sensitivityLevel: Swift.Int) -> Combine.AnyPublisher<NamiPairingFramework.SetSensitivityLevelResponse, any Swift.Error>
  func setAlertMode(_ alertMode: NamiPairingFramework.AlertMode, inPlace place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  func setAlertMode(_ alertMode: NamiPairingFramework.AlertMode, inZone zone: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZone, any Swift.Error>
  func setAlertMode(inPlace place: NamiPairingFramework.PlaceID, zones: [NamiPairingFramework.PlaceZoneID : NamiPairingFramework.AlertMode]) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  func disarmAlarm(in place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  func generateInvite(to place: NamiPairingFramework.PlaceID, invitee name: Swift.String, role: NamiPairingFramework.PlaceUserRole) -> Combine.AnyPublisher<NamiPairingFramework.InviteLink, any Swift.Error>
  func requestWebToken() -> Combine.AnyPublisher<NamiPairingFramework.AccessToken, any Swift.Error>
  func linkingCodeInfo(for code: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.CodeLinkingInfo, any Swift.Error>
  func linkingCodeActivete(_ code: Swift.String) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func sessionCodeInfo(for code: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.CodeSessionInfo, any Swift.Error>
  func installerSessionActivate(with code: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.SessionCodeActivateResult, any Swift.Error>
  func testIntrusion(in zone: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.AlertNotification, any Swift.Error>
  func getZendeskToken() -> Combine.AnyPublisher<Swift.String, any Swift.Error>
  func getRestHistory(roomId: NamiPairingFramework.RoomID, from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.RestEventsResponse, any Swift.Error>
  func getRestInsights(roomId: NamiPairingFramework.RoomID, day: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.RestInsightsResponse, any Swift.Error>
  func getDeviceAttributeStatesHistory(query: NamiPairingFramework.DeviceAttributeStatesQuery) -> Combine.AnyPublisher<NamiPairingFramework.DeviceAttributeStateResponse, any Swift.Error>
  func collectDeviceAttributeStatesHistory(query: NamiPairingFramework.DeviceAttributeStatesQuery) -> Combine.AnyPublisher<[NamiPairingFramework.DeviceAttributeState], any Swift.Error>
  func getDeviceAttributeStatesRecent(query: NamiPairingFramework.DeviceAttributeStatesQuery) -> Combine.AnyPublisher<NamiPairingFramework.DeviceAttributeStateResponse, any Swift.Error>
  func collectDeviceAttributeStatesRecent(query: NamiPairingFramework.DeviceAttributeStatesQuery) -> Combine.AnyPublisher<[NamiPairingFramework.DeviceAttributeState], any Swift.Error>
  func getPinHashingParameters(for place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.PinHashingParameters, any Swift.Error>
  func verifyPinCredentials(for place: NamiPairingFramework.PlaceID, pinName: Swift.String, hashedPin: Foundation.Data) -> Combine.AnyPublisher<Swift.Void, NamiPairingFramework.PinVerificationResult>
  func createPinCredentials(for place: NamiPairingFramework.PlaceID, pinName: Swift.String, hashedPin: Foundation.Data) -> Combine.AnyPublisher<NamiPairingFramework.PinCredentialRecord, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  func updatePinCredentials(for place: NamiPairingFramework.PlaceID, pinId: NamiPairingFramework.PinCredentialID, pinName: Swift.String?, hashedPin: Foundation.Data?) -> Combine.AnyPublisher<NamiPairingFramework.PinCredentialRecord, any Swift.Error>
  #endif
  func deletePinCredentials(for place: NamiPairingFramework.PlaceID, id: NamiPairingFramework.PinCredentialID) -> Combine.AnyPublisher<NamiPairingFramework.PinCredentialRecord, any Swift.Error>
  func listPinCredentials(for place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PinCredentialRecord], any Swift.Error>
}
final public class WebAPI : NamiPairingFramework.WebAPIProtocol {
  final public var errorPublisher: Combine.PassthroughSubject<any Swift.Error, Swift.Never>
  required public init(base: Foundation.URL, signUpBase: Foundation.URL, session: any NamiPairingFramework.NetworkSession, tokenStore: any NamiPairingFramework.TokenStore)
  public init(baseUrl: Foundation.URL, session: any NamiPairingFramework.NetworkSession, authentication: NamiPairingFramework.CompanionModeAuthentication)
  final public func signUpAnonymously() -> Combine.AnyPublisher<NamiPairingFramework.AnonymousUserResponse, any Swift.Error>
  final public func signUp(with provider: NamiPairingFramework.OAuthProvider, signUpPath: Swift.String, callbackURLScheme: Swift.String, contextProvider: any AuthenticationServices.ASWebAuthenticationPresentationContextProviding) -> Combine.AnyPublisher<NamiPairingFramework.UserResponse, any Swift.Error>
  final public func connect(using provider: NamiPairingFramework.OAuthProvider, signUpPath: Swift.String, callbackURLScheme: Swift.String, contextProvider: any AuthenticationServices.ASWebAuthenticationPresentationContextProviding) -> Combine.AnyPublisher<NamiPairingFramework.User, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func updateUserProfile(username: Swift.String, iconId: NamiPairingFramework.UserIconID?, themeId: NamiPairingFramework.IconID?) -> Combine.AnyPublisher<NamiPairingFramework.User, any Swift.Error>
  #endif
  final public func userProfile() -> Combine.AnyPublisher<NamiPairingFramework.User, any Swift.Error>
  final public func recoverUser(with key: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.AnonymousUserResponse, any Swift.Error>
  final public func deleteUser() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func authorize(provider: NamiPairingFramework.OAuthProvider, idToken: Swift.String, authCode: Swift.String?) -> Combine.AnyPublisher<NamiPairingFramework.UserResponse, any Swift.Error>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func link(provider: NamiPairingFramework.OAuthProvider, idToken: Swift.String, authCode: Swift.String?) -> Combine.AnyPublisher<NamiPairingFramework.User, any Swift.Error>
  #endif
  final public func unlink(provider: Swift.String, providerUserId: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.User, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func createPlace(name: Swift.String, theme: NamiPairingFramework.ThemeID, icon: NamiPairingFramework.IconID, timeZone: Swift.String?, propertyTypeId: NamiPairingFramework.PropertyTypeID, propertyElevationId: NamiPairingFramework.PropertyElevationID, propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID, petTypeId: NamiPairingFramework.PetTypeID, zoneName: Swift.String?, getPlaceKey: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  #endif
  final public func listPlaces() -> Combine.AnyPublisher<NamiPairingFramework.PlacesResponse, any Swift.Error>
  final public func getPlace(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func updatePlace(id: NamiPairingFramework.PlaceID, name: Swift.String, theme: NamiPairingFramework.ThemeID, icon: NamiPairingFramework.IconID, timeZone: Swift.String?, propertyTypeId: NamiPairingFramework.PropertyTypeID?, propertyElevationId: NamiPairingFramework.PropertyElevationID?, propertyAvgFloorAreaId: NamiPairingFramework.PropertyAvgFloorAreaID?, petTypeId: NamiPairingFramework.PetTypeID?, engineType: NamiPairingFramework.EngineType?, entryDelay: NamiPairingFramework.EntryDelay?, exitDelay: NamiPairingFramework.ExitDelay?) -> Combine.AnyPublisher<NamiPairingFramework.PlaceUpdateResponse, any Swift.Error>
  #endif
  final public func leavePlace(id: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.PlacesResponse, any Swift.Error>
  final public func deletePlace(id: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func deletePlaceZone(in placeId: NamiPairingFramework.PlaceID, zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  final public func deletePlaceRoom(in placeId: NamiPairingFramework.PlaceID, roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  final public func createWiFiCredentialsUpdateSession(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  final public func getAllWiFiCredentialsUpdateSessions() -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsSessionsResponse, any Swift.Error>
  final public func getWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  final public func deleteDeviceFromSession(uid: NamiPairingFramework.DeviceUniversalID, sessionId: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  final public func resetWiFiCredentialsUpdateSession(id: NamiPairingFramework.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  final public func createOrResetWiFiCredentialsUpdateSession(zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.WiFiCredentialsUpdateSession, any Swift.Error>
  final public func listPlaceMembers(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func deletePlaceUser(from placeId: NamiPairingFramework.PlaceID, user userId: NamiPairingFramework.UserID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func updatePlaceUser(for placeId: NamiPairingFramework.PlaceID, userId: NamiPairingFramework.UserID, role: NamiPairingFramework.PlaceUserRole) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func revokeInvite(code: NamiPairingFramework.InviteCode, from placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.MembershipResponse, any Swift.Error>
  final public func invitationDetails(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<NamiPairingFramework.InvitePeek, any Swift.Error>
  final public func acceptInvitation(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<NamiPairingFramework.PlacesResponse, any Swift.Error>
  final public func declineInvitation(code: NamiPairingFramework.InviteCode) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func listPlaceKeys() -> Combine.AnyPublisher<[NamiPairingFramework.CloudPlaceKey], any Swift.Error>
  final public func createZone(place: NamiPairingFramework.PlaceID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZone, any Swift.Error>
  final public func updateZone(id: NamiPairingFramework.PlaceZoneID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZone, any Swift.Error>
  final public func createRoom(zone: NamiPairingFramework.PlaceZoneID, name: Swift.String, icon: NamiPairingFramework.IconID) -> Combine.AnyPublisher<NamiPairingFramework.Room, any Swift.Error>
  final public func updateRoom(id: NamiPairingFramework.RoomID, name: Swift.String, icon: NamiPairingFramework.IconID) -> Combine.AnyPublisher<NamiPairingFramework.Room, any Swift.Error>
  final public func listDevices(query: NamiPairingFramework.DevicesQuery) -> Combine.AnyPublisher<NamiPairingFramework.DevicesResponse, any Swift.Error>
  final public func collectDevices(query: NamiPairingFramework.DevicesQuery) -> Combine.AnyPublisher<[NamiPairingFramework.Device], any Swift.Error>
  final public func deleteDevice(id: NamiPairingFramework.DeviceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func moveDevices(deviceUIDs: [NamiPairingFramework.DeviceUniversalID], roomId: NamiPairingFramework.RoomID) -> Combine.AnyPublisher<NamiPairingFramework.MoveDevicesResponse, any Swift.Error>
  final public func renameDevice(id: NamiPairingFramework.DeviceID, name: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.Device, any Swift.Error>
  final public func sendDeviceCommandRequests(in placeId: NamiPairingFramework.PlaceID, uids: [NamiPairingFramework.DeviceUniversalID], messages: [Foundation.Data]) -> Combine.AnyPublisher<NamiPairingFramework.DevicesCommandResponse, any Swift.Error>
  final public func listAutomation(placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.ListAutomationResponse, any Swift.Error>
  final public func createAutomation(placeId: NamiPairingFramework.PlaceID, alertMode: NamiPairingFramework.AlertMode, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool = true) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  final public func updateAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, alertMode: NamiPairingFramework.AlertMode, zones: [NamiPairingFramework.PlaceZoneID], hour: Swift.Int, minutes: Swift.Int, daysOfWeek: [Swift.String], enabled: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  final public func changeAutomationActive(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID, active: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  final public func enableAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  final public func disableAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  final public func deleteAutomation(placeId: NamiPairingFramework.PlaceID, automationId: NamiPairingFramework.AutomationID) -> Combine.AnyPublisher<NamiPairingFramework.AutomationResponse, any Swift.Error>
  final public func requestPairingChallenge(roomId: NamiPairingFramework.RoomID, deviceCertificate: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.PairingChallengeResponse, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func pairDevice(roomId: NamiPairingFramework.RoomID, deviceName: Swift.String, cloudChallenge: Swift.String, deviceResponse: Swift.String, deviceCertificate: Swift.String, intent: Swift.String?) -> Combine.AnyPublisher<NamiPairingFramework.PairDeviceResponse, any Swift.Error>
  #endif
  final public func notifyPushesAllowed(pushRequest: NamiPairingFramework.NamiPushRegistrationRequest) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func sendTestPush() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func loadAlertNotifications() -> Combine.AnyPublisher<[NamiPairingFramework.AlertNotification], any Swift.Error>
  final public func loadEventsHistory(query: NamiPairingFramework.PlaceEventsQuery) -> Combine.AnyPublisher<NamiPairingFramework.RenderableEventsResponse, any Swift.Error>
  final public func getAllMotionData() -> Combine.AnyPublisher<[NamiPairingFramework.PlaceMotionAggregates], any Swift.Error>
  final public func getPlaceMotionHistory(for placeId: NamiPairingFramework.PlaceID, from: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.PlaceMotionHistory, any Swift.Error>
  final public func getZoneMotionHistory(for zoneIds: [NamiPairingFramework.PlaceZoneID], from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.ZoneMotionHistory, any Swift.Error>
  final public func setAlertMode(_ alertMode: NamiPairingFramework.AlertMode, inPlace place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  final public func setAlertMode(_ alertMode: NamiPairingFramework.AlertMode, inZone zone: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.PlaceZone, any Swift.Error>
  final public func setAlertMode(inPlace place: NamiPairingFramework.PlaceID, zones: [NamiPairingFramework.PlaceZoneID : NamiPairingFramework.AlertMode]) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  final public func disarmAlarm(in place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.Place, any Swift.Error>
  final public func generateInvite(to place: NamiPairingFramework.PlaceID, invitee name: Swift.String, role: NamiPairingFramework.PlaceUserRole) -> Combine.AnyPublisher<NamiPairingFramework.InviteLink, any Swift.Error>
  final public func requestWebToken() -> Combine.AnyPublisher<NamiPairingFramework.AccessToken, any Swift.Error>
  final public func linkingCodeInfo(for code: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.CodeLinkingInfo, any Swift.Error>
  final public func linkingCodeActivete(_ code: Swift.String) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  final public func sessionCodeInfo(for code: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.CodeSessionInfo, any Swift.Error>
  final public func installerSessionActivate(with code: Swift.String) -> Combine.AnyPublisher<NamiPairingFramework.SessionCodeActivateResult, any Swift.Error>
  final public func testIntrusion(in zone: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.AlertNotification, any Swift.Error>
  final public func getMotionDataAggregates(for placeId: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.PlaceMotionAggregates, any Swift.Error>
  final public func getMotionDataAggregates(for zoneId: NamiPairingFramework.PlaceZoneID) -> Combine.AnyPublisher<NamiPairingFramework.ZoneMotionAggregates, any Swift.Error>
  final public func changeEngineConfig(for placeId: NamiPairingFramework.PlaceID, to type: NamiPairingFramework.EngineType, level: Swift.Int) -> Combine.AnyPublisher<[NamiPairingFramework.PlaceZone], any Swift.Error>
  final public func setSensitivityLevel(for placeId: NamiPairingFramework.PlaceID, sensitivityLevel: Swift.Int) -> Combine.AnyPublisher<NamiPairingFramework.SetSensitivityLevelResponse, any Swift.Error>
  final public func getZendeskToken() -> Combine.AnyPublisher<Swift.String, any Swift.Error>
  final public func getRestHistory(roomId: NamiPairingFramework.RoomID, from: Foundation.Date, to: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.RestEventsResponse, any Swift.Error>
  final public func getRestInsights(roomId: NamiPairingFramework.RoomID, day: Foundation.Date) -> Combine.AnyPublisher<NamiPairingFramework.RestInsightsResponse, any Swift.Error>
  final public func getDeviceAttributeStatesHistory(query: NamiPairingFramework.DeviceAttributeStatesQuery) -> Combine.AnyPublisher<NamiPairingFramework.DeviceAttributeStateResponse, any Swift.Error>
  final public func collectDeviceAttributeStatesHistory(query: NamiPairingFramework.DeviceAttributeStatesQuery) -> Combine.AnyPublisher<[NamiPairingFramework.DeviceAttributeState], any Swift.Error>
  final public func getDeviceAttributeStatesRecent(query: NamiPairingFramework.DeviceAttributeStatesQuery) -> Combine.AnyPublisher<NamiPairingFramework.DeviceAttributeStateResponse, any Swift.Error>
  final public func collectDeviceAttributeStatesRecent(query: NamiPairingFramework.DeviceAttributeStatesQuery) -> Combine.AnyPublisher<[NamiPairingFramework.DeviceAttributeState], any Swift.Error>
  final public func getPinHashingParameters(for place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<NamiPairingFramework.PinHashingParameters, any Swift.Error>
  final public func verifyPinCredentials(for place: NamiPairingFramework.PlaceID, pinName: Swift.String, hashedPin: Foundation.Data) -> Combine.AnyPublisher<Swift.Void, NamiPairingFramework.PinVerificationResult>
  final public func createPinCredentials(for place: NamiPairingFramework.PlaceID, pinName: Swift.String, hashedPin: Foundation.Data) -> Combine.AnyPublisher<NamiPairingFramework.PinCredentialRecord, any Swift.Error>
  #if compiler(>=5.3) && $NonescapableTypes
  final public func updatePinCredentials(for place: NamiPairingFramework.PlaceID, pinId: NamiPairingFramework.PinCredentialID, pinName: Swift.String? = nil, hashedPin: Foundation.Data? = nil) -> Combine.AnyPublisher<NamiPairingFramework.PinCredentialRecord, any Swift.Error>
  #endif
  final public func deletePinCredentials(for place: NamiPairingFramework.PlaceID, id: NamiPairingFramework.PinCredentialID) -> Combine.AnyPublisher<NamiPairingFramework.PinCredentialRecord, any Swift.Error>
  final public func listPinCredentials(for place: NamiPairingFramework.PlaceID) -> Combine.AnyPublisher<[NamiPairingFramework.PinCredentialRecord], any Swift.Error>
  @objc deinit
}
public enum AuthenticationError : Swift.Error {
  case loginRequired
  case tokenExpired
  case sessionCodeInvalid
  case unknown
  public static func == (a: NamiPairingFramework.AuthenticationError, b: NamiPairingFramework.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AuthenticatorProtocol {
  func validToken(forceRefresh: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.AccessToken, any Swift.Error>
}
public class Authenticator : NamiPairingFramework.AuthenticatorProtocol {
  public init(base: Foundation.URL, accessToken: NamiPairingFramework.AccessToken, refreshToken: Swift.String)
  public func validToken(forceRefresh: Swift.Bool = false) -> Combine.AnyPublisher<NamiPairingFramework.AccessToken, any Swift.Error>
  public func requestWebToken() -> Combine.AnyPublisher<NamiPairingFramework.AccessToken, any Swift.Error>
  @objc deinit
}
final public class TokenStoreAuthenticator : NamiPairingFramework.AuthenticatorProtocol {
  public init(base: Foundation.URL, session: any NamiPairingFramework.NetworkSession, tokenStore: any NamiPairingFramework.TokenStore)
  final public func validToken(forceRefresh: Swift.Bool) -> Combine.AnyPublisher<NamiPairingFramework.AccessToken, any Swift.Error>
  @objc deinit
}
public enum LinkingError : Swift.Error, Swift.Equatable {
  case failure(reason: Swift.String)
  case parseResponseFailed
  public static func == (a: NamiPairingFramework.LinkingError, b: NamiPairingFramework.LinkingError) -> Swift.Bool
}
extension NamiPairingFramework.NamiDeviceState.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceState.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.NamiDeviceState.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiAutomation.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.NamiAutomation.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.NamiAutomation.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiPlaceUser.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.NamiPlaceUser.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.NamiPlaceUser.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiWiFiCredentialsUpdateStatus : Swift.Hashable {}
extension NamiPairingFramework.NamiWiFiCredentialsUpdateStatus : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiAlertMode : Swift.Hashable {}
extension NamiPairingFramework.NamiAlertMode : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiEngineConfig.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.NamiEngineConfig.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.NamiEngineConfig.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiEngineType : Swift.Hashable {}
extension NamiPairingFramework.NamiEngineType : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiZoneHealth : Swift.Hashable {}
extension NamiPairingFramework.NamiZoneHealth : Swift.RawRepresentable {}
extension NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError : Swift.Equatable {}
extension NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError : Swift.Hashable {}
extension NamiPairingFramework.RemoteTemplateEntrypoint : Swift.Equatable {}
extension NamiPairingFramework.RemoteTemplateEntrypoint : Swift.Hashable {}
extension NamiPairingFramework.NamiPermission : Swift.Equatable {}
extension NamiPairingFramework.NamiPermission : Swift.Hashable {}
extension NamiPairingFramework.NamiPermission : Swift.RawRepresentable {}
extension NamiPairingFramework.StorageError : Swift.Equatable {}
extension NamiPairingFramework.StorageError : Swift.Hashable {}
extension NamiPairingFramework.NamiDeviceCapability : Swift.Hashable {}
extension NamiPairingFramework.NamiDeviceEndpoint.EndpointType.ReadableCluster : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceEndpoint.EndpointType.ReadableCluster : Swift.Hashable {}
extension NamiPairingFramework.NamiDeviceEndpoint.EndpointType.WritableCluster : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceEndpoint.EndpointType.WritableCluster : Swift.Hashable {}
extension NamiPairingFramework.MeasurementSystem : Swift.Equatable {}
extension NamiPairingFramework.MeasurementSystem : Swift.Hashable {}
extension NamiPairingFramework.NamiAlertReason : Swift.Hashable {}
extension NamiPairingFramework.NamiAlertReason : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiMeasurementSystem : Swift.Equatable {}
extension NamiPairingFramework.NamiMeasurementSystem : Swift.Hashable {}
extension NamiPairingFramework.NamiMeasurementSystem : Swift.RawRepresentable {}
extension NamiPairingFramework.KitCategory : Swift.Equatable {}
extension NamiPairingFramework.KitCategory : Swift.Hashable {}
extension NamiPairingFramework.KitCategory : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiDeviceConnectivity : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceConnectivity : Swift.Hashable {}
extension NamiPairingFramework.TimeZoneLoadingError : Swift.Equatable {}
extension NamiPairingFramework.TimeZoneLoadingError : Swift.Hashable {}
extension NamiPairingFramework.NamiAppearance : Swift.Hashable {}
extension NamiPairingFramework.NamiAppearance : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiDeviceType : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceType : Swift.Hashable {}
extension NamiPairingFramework.NamiOutletType : Swift.Equatable {}
extension NamiPairingFramework.NamiOutletType : Swift.Hashable {}
extension NamiPairingFramework.Tokens : Swift.Equatable {}
extension NamiPairingFramework.Tokens : Swift.Hashable {}
extension NamiPairingFramework.Tokens : Swift.RawRepresentable {}
extension NamiPairingFramework.TokenStoreError : Swift.Equatable {}
extension NamiPairingFramework.TokenStoreError : Swift.Hashable {}
extension NamiPairingFramework.KeychainError : Swift.Hashable {}
extension NamiPairingFramework.PacketBoatError : Swift.Equatable {}
extension NamiPairingFramework.PacketBoatError : Swift.Hashable {}
extension NamiPairingFramework.PacketBoatError : Swift.RawRepresentable {}
extension NamiPairingFramework.Seance.Role : Swift.Equatable {}
extension NamiPairingFramework.Seance.Role : Swift.Hashable {}
extension NamiPairingFramework.Seance.State : Swift.Equatable {}
extension NamiPairingFramework.Seance.State : Swift.Hashable {}
extension NamiPairingFramework.Seance.HashingAlgorithm : Swift.Equatable {}
extension NamiPairingFramework.Seance.HashingAlgorithm : Swift.Hashable {}
extension NamiPairingFramework.OperationalDatasetAcquisitionError : Swift.Equatable {}
extension NamiPairingFramework.OperationalDatasetAcquisitionError : Swift.Hashable {}
extension NamiPairingFramework.CodeScannerView : Swift.Sendable {}
extension NamiPairingFramework.CodeScannerView.Coordinator : AVFoundation.AVCaptureMetadataOutputObjectsDelegate {}
extension NamiPairingFramework.QRScanner.ScanError : Swift.Equatable {}
extension NamiPairingFramework.QRScanner.ScanError : Swift.Hashable {}
extension NamiPairingFramework.QRScanner.ScanError : Swift.RawRepresentable {}
@available(*, deprecated, message: "`PositioningResult` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This view initialization closure is to be dropped in the future versions of the SDK.")
extension NamiPairingFramework.PositioningResult : Swift.Equatable {}
@available(*, deprecated, message: "`PositioningResult` is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK. This view initialization closure is to be dropped in the future versions of the SDK.")
extension NamiPairingFramework.PositioningResult : Swift.Hashable {}
extension NamiPairingFramework.ListWiFiNetworks.State : NamiPairingFramework.ViewModelState {}
extension NamiPairingFramework.ListWiFiNetworks.ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {}
extension NamiPairingFramework.OtherWiFiNetwork.State : NamiPairingFramework.ViewModelState {}
extension NamiPairingFramework.OtherWiFiNetwork.ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {}
extension NamiPairingFramework.BluetoothUsageHint.Event : Swift.Equatable {}
extension NamiPairingFramework.BluetoothUsageHint.Event : Swift.Hashable {}
extension NamiPairingFramework.EnterWiFiPassword.Event : Swift.Equatable {}
extension NamiPairingFramework.EnterWiFiPassword.Event : Swift.Hashable {}
@available(*, deprecated, message: "The `HowToPosition` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
extension NamiPairingFramework.HowToPosition.Event : Swift.Hashable {}
@available(*, deprecated, message: "The `InitialScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
extension NamiPairingFramework.InitialScreen.Event : Swift.Hashable {}
@available(*, deprecated, message: "The `PositioningGuidance` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
extension NamiPairingFramework.PositioningGuidance.PositioningQuality : Swift.Hashable {}
@available(*, deprecated, message: "The `PositioningGuidance` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
extension NamiPairingFramework.PositioningGuidance.PositioningState : Swift.Hashable {}
@available(*, deprecated, message: "The `PositioningGuidance` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
extension NamiPairingFramework.PositioningGuidance.Event : Swift.Hashable {}
@available(*, deprecated, message: "The `PositioningComplete` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
extension NamiPairingFramework.PositioningComplete.Event : Swift.Equatable {}
@available(*, deprecated, message: "The `PositioningComplete` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
extension NamiPairingFramework.PositioningComplete.Event : Swift.Hashable {}
@available(*, deprecated, message: "The `ErrorScreen` type is deprecated as the positioning functionality required for the devices no longer in production was removed from the SDK.")
extension NamiPairingFramework.ErrorScreen.Event : Swift.Hashable {}
extension NamiPairingFramework.Pairing.ConnectTo : Swift.Hashable {}
extension NamiPairingFramework.Pairing.ActionOnError : Swift.Hashable {}
extension NamiPairingFramework.Pairing.PairingCancellationdReason : Swift.Equatable {}
extension NamiPairingFramework.Pairing.PairingCancellationdReason : Swift.Hashable {}
extension NamiPairingFramework.Pairing.ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {}
extension NamiPairingFramework.SetupType : Swift.Hashable {}
extension NamiPairingFramework.NoView : Swift.Sendable {}
extension NamiPairingFramework.ValueRepresentation : Swift.Hashable {}
extension NamiPairingFramework.SplineGraph : Swift.Sendable {}
extension NamiPairingFramework.CircleImageButton : Swift.Sendable {}
extension NamiPairingFramework.RoundedRectContainerView : Swift.Sendable {}
@available(iOS 13, macOS 11, *)
extension NamiPairingFramework.ToastView : Swift.Sendable {}
@available(iOS 13, macOS 11, *)
extension NamiPairingFramework.ToastView.ToastAnimationType : Swift.Equatable {}
@available(iOS 13, macOS 11, *)
extension NamiPairingFramework.ToastView.ToastAnimationType : Swift.Hashable {}
extension NamiPairingFramework.NamiXMarkButton : Swift.Sendable {}
extension NamiPairingFramework.NamiXMarkButton.Appearance : Swift.Equatable {}
extension NamiPairingFramework.NamiXMarkButton.Appearance : Swift.Hashable {}
extension NamiPairingFramework.NamiNavBackButton : Swift.Sendable {}
extension NamiPairingFramework.NamiCircularXMarkButton : Swift.Sendable {}
extension NamiPairingFramework.NamiCircularXMarkButton.Appearance : Swift.Equatable {}
extension NamiPairingFramework.NamiCircularXMarkButton.Appearance : Swift.Hashable {}
extension NamiPairingFramework.NamiPageIndexIndicatorView : Swift.Sendable {}
extension NamiPairingFramework.TextFieldView : Swift.Sendable {}
extension NamiPairingFramework.NamiTextFieldStyle : Swift.Equatable {}
extension NamiPairingFramework.NamiTextFieldStyle : Swift.Hashable {}
extension NamiPairingFramework.NamiTextField : Swift.Sendable {}
extension NamiPairingFramework.NamiErrorChatBubble : Swift.Sendable {}
extension NamiPairingFramework.NamiChatBubble : Swift.Sendable {}
extension NamiPairingFramework.NamiTopNavigationScreen : Swift.Sendable {}
extension NamiPairingFramework.LottieAnimationView : Swift.Sendable {}
extension NamiPairingFramework.CircleButton : Swift.Sendable {}
extension NamiPairingFramework.NamiTextStyle.Leading : Swift.Equatable {}
extension NamiPairingFramework.NamiTextStyle.Leading : Swift.Hashable {}
extension NamiPairingFramework.NamiSFSafariView : Swift.Sendable {}
@available(iOS 15, *)
extension NamiPairingFramework.NamiTextHyperLink : Swift.Sendable {}
extension NamiPairingFramework.NamiTextHyperLinkLegacy : Swift.Sendable {}
extension NamiPairingFramework.NotificationButtonStyle : Swift.Sendable {}
extension NamiPairingFramework.NotificationButtonStyle.NotificationButton : Swift.Sendable {}
extension NamiPairingFramework.NamiAuthButtonStyle : Swift.Sendable {}
extension NamiPairingFramework.NamiAuthButtonStyle.NamiAuthButton : Swift.Sendable {}
extension NamiPairingFramework.NamiAuthButtonStyle.AppearanceColorMode : Swift.Equatable {}
extension NamiPairingFramework.NamiAuthButtonStyle.AppearanceColorMode : Swift.Hashable {}
extension NamiPairingFramework.NamiActionButtonStyle : Swift.Sendable {}
extension NamiPairingFramework.NamiActionButtonStyle.NamiActionButton : Swift.Sendable {}
extension NamiPairingFramework.NamiActionButtonStyle.AppearanceHierarchyRank : Swift.Equatable {}
extension NamiPairingFramework.NamiActionButtonStyle.AppearanceHierarchyRank : Swift.Hashable {}
extension NamiPairingFramework.ScrollViewWithOnScrollAction : Swift.Sendable {}
extension NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateStatus : Swift.Equatable {}
extension NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateStatus : Swift.Hashable {}
extension NamiPairingFramework.RemoteTemplateUI_WiFiCredentialsUpdateStatus : Swift.RawRepresentable {}
extension UIKit.UIImage.AnimatableImageFormat : Swift.Equatable {}
extension UIKit.UIImage.AnimatableImageFormat : Swift.Hashable {}
extension UIKit.UIImage.AnimatableImageFormat : Swift.RawRepresentable {}
extension NamiPairingFramework.AnimatableImageView : Swift.Sendable {}
extension NamiPairingFramework.ColorPrimitive : Swift.Equatable {}
extension NamiPairingFramework.ColorPrimitive : Swift.Hashable {}
extension NamiPairingFramework.ColorPrimitive : Swift.RawRepresentable {}
extension NamiPairingFramework.Colors.ColorSaturation : Swift.Equatable {}
extension NamiPairingFramework.Colors.ColorSaturation : Swift.Hashable {}
extension NamiPairingFramework.Colors.ColorSaturation : Swift.RawRepresentable {}
extension NamiPairingFramework.NamiDeviceCapability.ControlMessgeError : Swift.Equatable {}
extension NamiPairingFramework.NamiDeviceCapability.ControlMessgeError : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.OnOff : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.OnOff : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.Warning : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.Warning : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningQuality : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningQuality : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningProcessState : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.WiDarInfo.PositioningProcessState : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.DoorSensorState : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.DoorSensorState : Swift.Hashable {}
extension NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo.BatteryState : Swift.Equatable {}
extension NamiPairingFramework.StateMessage.EndpointState.PowerSupplyInfo.BatteryState : Swift.Hashable {}
extension NamiPairingFramework.SCType : Swift.Equatable {}
extension NamiPairingFramework.SCType : Swift.Hashable {}
extension NamiPairingFramework.SCType : Swift.RawRepresentable {}
extension NamiPairingFramework.SCOption : Swift.Equatable {}
extension NamiPairingFramework.SCOption : Swift.Hashable {}
extension NamiPairingFramework.SCOption : Swift.RawRepresentable {}
extension NamiPairingFramework.SCOption.Format : Swift.Equatable {}
extension NamiPairingFramework.SCOption.Format : Swift.Hashable {}
extension NamiPairingFramework.SCOption.Format : Swift.RawRepresentable {}
extension NamiPairingFramework.SCCodeSample : Swift.Equatable {}
extension NamiPairingFramework.SCCodeSample : Swift.Hashable {}
extension NamiPairingFramework.SCCodeSample : Swift.RawRepresentable {}
extension NamiPairingFramework.SCContentFormat : Swift.Equatable {}
extension NamiPairingFramework.SCContentFormat : Swift.Hashable {}
extension NamiPairingFramework.SCContentFormat : Swift.RawRepresentable {}
extension NamiPairingFramework.SCAllowedRoute : Swift.Equatable {}
extension NamiPairingFramework.SCAllowedRoute : Swift.Hashable {}
extension NamiPairingFramework.SCAllowedRoute : Swift.RawRepresentable {}
extension NamiPairingFramework.SCClientErrorCode : Swift.Equatable {}
extension NamiPairingFramework.SCClientErrorCode : Swift.Hashable {}
extension NamiPairingFramework.SCClientErrorCode : Swift.RawRepresentable {}
extension NamiPairingFramework.OAuthProvider : Swift.Hashable {}
extension NamiPairingFramework.OAuthProvider : Swift.RawRepresentable {}
extension NamiPairingFramework.ZoneHealth : Swift.Equatable {}
extension NamiPairingFramework.ZoneHealth : Swift.Hashable {}
extension NamiPairingFramework.ZoneHealth : Swift.RawRepresentable {}
extension NamiPairingFramework.WiFiCredentialsUpdateStatus : Swift.Equatable {}
extension NamiPairingFramework.WiFiCredentialsUpdateStatus : Swift.Hashable {}
extension NamiPairingFramework.MotionDataResolution : Swift.Equatable {}
extension NamiPairingFramework.MotionDataResolution : Swift.Hashable {}
extension NamiPairingFramework.MotionDataResolution : Swift.RawRepresentable {}
extension NamiPairingFramework.AlertMode : Swift.Equatable {}
extension NamiPairingFramework.AlertMode : Swift.Hashable {}
extension NamiPairingFramework.AlertMode : Swift.RawRepresentable {}
extension NamiPairingFramework.EngineType : Swift.Equatable {}
extension NamiPairingFramework.EngineType : Swift.Hashable {}
extension NamiPairingFramework.EngineType : Swift.RawRepresentable {}
extension NamiPairingFramework.AlertReason : Swift.Equatable {}
extension NamiPairingFramework.AlertReason : Swift.Hashable {}
extension NamiPairingFramework.AlertReason : Swift.RawRepresentable {}
extension NamiPairingFramework.PlaceEventCause : Swift.Hashable {}
extension NamiPairingFramework.PlaceEventCause : Swift.RawRepresentable {}
extension NamiPairingFramework.RenderableEvent.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.RenderableEvent.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.RenderableEvent.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.RenderableEventRenders.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.RenderableEventRenders.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.RenderableEventRenders.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.RenderableEventShape : Swift.Hashable {}
extension NamiPairingFramework.RenderableEventShape : Swift.RawRepresentable {}
extension NamiPairingFramework.RenderableEventField.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.RenderableEventField.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.RenderableEventField.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.RenderableEventType : Swift.Hashable {}
extension NamiPairingFramework.RenderableEventType : Swift.RawRepresentable {}
extension NamiPairingFramework.JitterStrategy : Swift.Equatable {}
extension NamiPairingFramework.JitterStrategy : Swift.Hashable {}
extension NamiPairingFramework.ConflictErrorCode : Swift.Equatable {}
extension NamiPairingFramework.ConflictErrorCode : Swift.Hashable {}
extension NamiPairingFramework.ConflictErrorCode : Swift.RawRepresentable {}
extension NamiPairingFramework.CollisionTrigger.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.CollisionTrigger.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.CollisionTrigger.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.CollisionReaction.CodingKeys : Swift.Equatable {}
extension NamiPairingFramework.CollisionReaction.CodingKeys : Swift.Hashable {}
extension NamiPairingFramework.CollisionReaction.CodingKeys : Swift.RawRepresentable {}
extension NamiPairingFramework.AuthenticationError : Swift.Equatable {}
extension NamiPairingFramework.AuthenticationError : Swift.Hashable {}
