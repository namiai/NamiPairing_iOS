// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target arm64-apple-ios14.5-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name NamiPairingFramework
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import Combine
import CommonCrypto
import CoreBluetooth
import CryptoKit
import DeviceConnections
import Foundation
@_exported import NamiPairingFramework
import Swift
import SwiftUI
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension Foundation.URLRequest {
  public init(method: Swift.String = "GET", base: Foundation.URL, path: Swift.String, query: [Swift.String : Swift.String], headers: [Swift.String : Swift.String] = [:], body: Foundation.Data? = nil)
  public init(method: Swift.String = "GET", base: Foundation.URL, path: Swift.String, query: [Foundation.URLQueryItem] = [], headers: [Swift.String : Swift.String] = [:], body: Foundation.Data? = nil)
}
@_hasMissingDesignatedInitializers final public class InMemoryThreadDatasetStorage : NamiPairingFramework.ThreadSecureStorageProtocol {
  public static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  public static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, NamiPairingFramework.InMemoryThreadDatasetStorage.Thread_SecureStorageError>
  public static func delete(at key: Swift.String, server: Swift.String)
  public typealias Thread_SecureStorageError = NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError
  public enum StorageError : Swift.Error {
    case cantRetrieve
    public static func == (a: NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError, b: NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
public enum AuthenticationError : Swift.Error {
  case loginRequired
  case unknown
  public static func == (a: NamiPairingFramework.AuthenticationError, b: NamiPairingFramework.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct PublicWiFiNetwork : Swift.Equatable {
  public var ssid: Swift.String
  public var rssi: Swift.Int32
  public var open: Swift.Bool
  public var bssid: Foundation.Data
  public init()
  public static func == (a: NamiPairingFramework.PublicWiFiNetwork, b: NamiPairingFramework.PublicWiFiNetwork) -> Swift.Bool
}
public struct PublicPairingAdvertisement : Swift.Equatable {
  public var version: Swift.Int32
  public var productID: Swift.Int32
  public var discriminator: Swift.Int32
  public init()
  public static func == (a: NamiPairingFramework.PublicPairingAdvertisement, b: NamiPairingFramework.PublicPairingAdvertisement) -> Swift.Bool
}
public struct ThreadScanResult : Swift.Equatable {
  public var panID: Swift.UInt32
  public var extendedPanID: Swift.UInt64
  public var networkName: Swift.String
  public var channel: Swift.UInt32
  public var version: Swift.UInt32
  public var extendedAddress: Swift.UInt64
  public var rssi: Swift.Int32
  public var lqi: Swift.UInt32
  public init()
  public static func == (a: NamiPairingFramework.ThreadScanResult, b: NamiPairingFramework.ThreadScanResult) -> Swift.Bool
}
public struct PublicPairingError : Swift.Equatable {
  public enum ErrorType : Swift.Equatable {
    public typealias RawValue = Swift.Int
    case unknownError
    case secureSessionError
    case cloudChallengeError
    case wifiScanError
    case wifiJoinError
    case wifiJoinPasswordError
    case wifiJoinIpError
    case threadScanError
    case threadJoinError
    case UNRECOGNIZED(Swift.Int)
    public init()
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
    public static func == (a: NamiPairingFramework.PublicPairingError.ErrorType, b: NamiPairingFramework.PublicPairingError.ErrorType) -> Swift.Bool
  }
  public var error: NamiPairingFramework.PublicPairingError.ErrorType
  public static func == (a: NamiPairingFramework.PublicPairingError, b: NamiPairingFramework.PublicPairingError) -> Swift.Bool
}
public struct NetworkError : Swift.Error {
  public init(statusCode: Swift.Int, body: Foundation.Data? = nil)
  public init(_ urlError: Foundation.URLError, body: Foundation.Data? = nil)
  public static var unknown: NamiPairingFramework.NetworkError
  public let code: NamiPairingFramework.NetworkErrorCode
  public var isRecoverable: Swift.Bool {
    get
  }
  public var customErrorDescription: Swift.String? {
    get
  }
  public func decodeBody<ErrorBody>(to type: ErrorBody.Type) -> ErrorBody? where ErrorBody : Swift.Decodable
}
public enum NetworkErrorCode : Swift.Equatable {
  case unknown(Swift.Int)
  case connectionError(Foundation.URLError)
  case invalidParameters
  case unauthorized
  case notFound
  case conflict
  case serverError
  public init(statusCode: Swift.Int)
  public init(urlError: Foundation.URLError)
  public var code: Swift.Int {
    get
  }
  public static func == (lhs: NamiPairingFramework.NetworkErrorCode, rhs: NamiPairingFramework.NetworkErrorCode) -> Swift.Bool
}
extension NamiPairingFramework.ThreadOperationalDatasetProvider : NamiPairingFramework.PairingThreadOperationalDatasetProviderProtocol {
  public typealias Pairing_NamiThreadOperationalDataset = NamiPairingFramework.NamiThreadOperationalDataset
}
extension NamiPairingFramework.NamiThreadOperationalDataset : NamiPairingFramework.PairingNamiThreadOperationalDatasetProtocol {
}
public struct Device : NamiPairingFramework.DeviceProtocol, Swift.Decodable, Swift.Equatable {
  public var id: DeviceConnections.DeviceID
  public var uid: DeviceConnections.DeviceUniversalID
  public var urn: Swift.String
  public var model: NamiPairingFramework.DeviceModel
  public var deviceState: NamiPairingFramework.DeviceCloudState?
  public static func == (a: NamiPairingFramework.Device, b: NamiPairingFramework.Device) -> Swift.Bool
  public typealias DeviceCloudState = NamiPairingFramework.DeviceCloudState
  public typealias DeviceModel = NamiPairingFramework.DeviceModel
  public init(from decoder: any Swift.Decoder) throws
}
public struct DeviceCloudState : NamiPairingFramework.DeviceCloudStateProtocol, Swift.Decodable, Swift.Equatable {
  public var payload: Foundation.Data
  public static func == (a: NamiPairingFramework.DeviceCloudState, b: NamiPairingFramework.DeviceCloudState) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct DeviceModel : NamiPairingFramework.DeviceModelProtocol, Swift.Decodable, Swift.Equatable {
  public var codeName: Swift.String
  public var productLabel: Swift.String
  public var productId: DeviceConnections.DeviceProductID
  public static func == (a: NamiPairingFramework.DeviceModel, b: NamiPairingFramework.DeviceModel) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct Place : Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public var id: DeviceConnections.PlaceID
  public static func == (a: NamiPairingFramework.Place, b: NamiPairingFramework.Place) -> Swift.Bool
  public typealias ID = DeviceConnections.PlaceID
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlacesResponse : Swift.Decodable {
  public init(places: [NamiPairingFramework.Place], permissions: [DeviceConnections.URN : DeviceConnections.UserPermissionsSet])
  public var places: [NamiPairingFramework.Place]
  public var permissions: [DeviceConnections.URN : DeviceConnections.UserPermissionsSet]
  public init(from decoder: any Swift.Decoder) throws
}
public struct PlaceZone : NamiPairingFramework.PlaceZoneProtocol, Swift.Decodable, Swift.Equatable, Swift.Identifiable {
  public var id: DeviceConnections.PlaceZoneID
  public var externalId: Swift.String
  public var urn: Swift.String
  public var name: Swift.String
  public static func == (a: NamiPairingFramework.PlaceZone, b: NamiPairingFramework.PlaceZone) -> Swift.Bool
  public typealias ID = DeviceConnections.PlaceZoneID
  public init(from decoder: any Swift.Decoder) throws
}
public struct Room : Swift.Codable, Swift.Equatable, Swift.Identifiable {
  public var id: DeviceConnections.RoomID
  public static func == (a: NamiPairingFramework.Room, b: NamiPairingFramework.Room) -> Swift.Bool
  public typealias ID = DeviceConnections.RoomID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PairingChallengeRequest : Swift.Encodable {
  public init(certificate: Swift.String)
  public var certificate: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PairDeviceRequest : Swift.Encodable {
  public init(deviceName: Swift.String, cloudChallenge: Swift.String, deviceResponse: Swift.String, deviceCertificate: Swift.String, intent: Swift.String?)
  public var deviceName: Swift.String
  public var cloudChallenge: Swift.String
  public var deviceResponse: Swift.String
  public var deviceCertificate: Swift.String
  public var intent: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct UpdatedDevice : NamiPairingFramework.UpdatedDeviceProtocol, Swift.Decodable {
  public var uid: DeviceConnections.DeviceUniversalID
  public static func == (a: NamiPairingFramework.UpdatedDevice, b: NamiPairingFramework.UpdatedDevice) -> Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct WiFiCredentialsUpdateSession : NamiPairingFramework.WiFiCredentialsUpdateSessionProtocol, Swift.Decodable {
  public var id: DeviceConnections.WiFiCredentialsUpdateSessionID
  public var zoneId: DeviceConnections.PlaceZoneID
  public var updatedDevices: [NamiPairingFramework.UpdatedDevice]?
  public static func == (a: NamiPairingFramework.WiFiCredentialsUpdateSession, b: NamiPairingFramework.WiFiCredentialsUpdateSession) -> Swift.Bool
  public typealias UpdatedDevice = NamiPairingFramework.UpdatedDevice
  public init(from decoder: any Swift.Decoder) throws
}
public class NamiPairing<Container> where Container : NamiPairingFramework.PairingStepsContainer {
  public typealias PairingParameters = NamiPairingFramework.Tomonari<Container>.PairingParameters
  public enum SDKError : Swift.Error {
    case sessionActivateNoData
    case sessionActivateMalformedResponse(Foundation.Data)
    case roomUuidNotInTopology
    case incorrectDeviceUID
  }
  public var api: any NamiPairingFramework.PairingWebAPIProtocol
  public var wifiStorage: any NamiPairingFramework.PairingWiFiStorageProtocol
  public var threadDatasetProvider: any NamiPairingFramework.PairingThreadOperationalDatasetProviderProtocol
  public var devicePairingState: Combine.PassthroughSubject<NamiPairingFramework.Tomonari<Container>.DevicePairingState, any Swift.Error> {
    get
  }
  public init<WiFiStorage, SecureStorage>(sessionCode: Swift.String, wifiStorage: WiFiStorage = InMemoryWiFiStorage(), threadDatasetStore: SecureStorage.Type = InMemoryThreadDatasetStorage.self) throws where WiFiStorage : NamiPairingFramework.PairingWiFiStorageProtocol, SecureStorage : NamiPairingFramework.ThreadSecureStorageProtocol
  public func startPairing(roomId: Swift.String, pairingSteps: Container, pairingParameters: NamiPairingFramework.NamiPairing<Container>.PairingParameters = .none) throws -> some SwiftUI.View
  
  public func startPositioning(deviceName: Swift.String, deviceUid: Swift.String, pairingSteps: Container, onPositioningEnded: @escaping (NamiPairingFramework.PositioningResult) -> Swift.Void) throws -> some SwiftUI.View
  
  @objc deinit
}
final public class InMemoryWiFiStorage : NamiPairingFramework.PairingWiFiStorageProtocol {
  public init()
  final public func save(password: Swift.String?, for networkSSID: Swift.String)
  final public func password(for networkSSID: Swift.String) -> Swift.String?
  final public func removeAll()
  @objc deinit
}
public enum PacketBoatError : Swift.String, Swift.Error {
  case wrongDataFormat
  case wrongDataSize
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
final public class PacketBoat {
  public init()
  final public var doneSending: Swift.Bool {
    get
  }
  final public var doneReceiving: Swift.Bool {
    get
  }
  final public func startSending(data: Foundation.Data)
  final public func nextBitToSend(maxSize: Swift.UInt) -> Foundation.Data?
  final public func receivedData() -> Foundation.Data?
  final public func receiveNext(data: Foundation.Data) -> Swift.Result<Swift.Bool, NamiPairingFramework.PacketBoatError>
  @objc deinit
}
public enum SeanceError : Swift.Error {
  case keyDerivationError
  case wrongState(Swift.String)
  case keyAgreementError
  case verificationError
}
public class Seance {
  public init(role: NamiPairingFramework.Seance.Role)
  public enum Role {
    case prover
    case verifier
    public static func == (a: NamiPairingFramework.Seance.Role, b: NamiPairingFramework.Seance.Role) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum State {
    case initial
    case started
    case unverified
    case established
    public static func == (a: NamiPairingFramework.Seance.State, b: NamiPairingFramework.Seance.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let role: NamiPairingFramework.Seance.Role
  public var state: NamiPairingFramework.Seance.State {
    get
  }
  public static func preProcessPassword(_ password: Swift.UInt32, salt: [Swift.UInt8], iterations: Swift.UInt32 = 100000) throws -> Foundation.Data
  public func start(preProcessedPassword: Foundation.Data) throws -> Foundation.Data
  public func makeSharedKey(otherKeyData: Foundation.Data) throws -> Foundation.Data
  public func verify(otherValue: Foundation.Data) throws -> NamiPairingFramework.GhostBox
  @objc deinit
}
public struct GhostMessage {
  public let nonce: Foundation.Data
  public let ciphertext: Foundation.Data
  public let tag: Foundation.Data
}
@_hasMissingDesignatedInitializers final public class GhostBox {
  final public func encrypt(message: Foundation.Data) -> NamiPairingFramework.GhostMessage?
  final public func decrypt(nonce: Foundation.Data, ciphertext: Foundation.Data, tag: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
public struct NamiWiFiNetwork : Swift.Equatable, Swift.Hashable {
  public let ssid: Swift.String
  public let rssi: Swift.Int
  public let bssid: NamiPairingFramework.BSSID
  public let open: Swift.Bool
  public static func == (a: NamiPairingFramework.NamiWiFiNetwork, b: NamiPairingFramework.NamiWiFiNetwork) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias BSSID = Foundation.Data
public struct ScanWiFiNetworksParameters : Swift.Equatable {
  public init(sessionId: DeviceConnections.WiFiCredentialsUpdateSessionID?, currentDeviceUid: DeviceConnections.DeviceUniversalID?, scanFinishedSessionId: Swift.Int? = nil, passwordReEntryRequested: Swift.Bool = false)
  public var sessionId: DeviceConnections.WiFiCredentialsUpdateSessionID?
  public var scanFinishedSessionId: Swift.Int?
  public var currentDeviceUid: DeviceConnections.DeviceUniversalID?
  public var passwordReEntryRequested: Swift.Bool
  public static func == (a: NamiPairingFramework.ScanWiFiNetworksParameters, b: NamiPairingFramework.ScanWiFiNetworksParameters) -> Swift.Bool
}
public struct ScannedWiFiNetworks : Swift.Equatable {
  public init(networks: [NamiPairingFramework.PublicWiFiNetwork], canRetry: Swift.Bool)
  public var networks: [NamiPairingFramework.PublicWiFiNetwork]
  public var canRetry: Swift.Bool
  public static func == (a: NamiPairingFramework.ScannedWiFiNetworks, b: NamiPairingFramework.ScannedWiFiNetworks) -> Swift.Bool
}
public enum ErrorScreen {
  public struct State : Swift.Equatable {
    public var positioningError: NamiPairingFramework.PositioningError
    public var positioningCancelled: Swift.Bool
    public var wantToRetryPositioning: Swift.Bool
    public var buttonsDisabled: Swift.Bool {
      get
    }
    public static func == (a: NamiPairingFramework.ErrorScreen.State, b: NamiPairingFramework.ErrorScreen.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case cancelPositioning
    case retryPositioning
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NamiPairingFramework.ErrorScreen.Event, b: NamiPairingFramework.ErrorScreen.Event) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.ErrorScreen.State
    public typealias Event = NamiPairingFramework.ErrorScreen.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.ErrorScreen.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.ErrorScreen.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(_ event: NamiPairingFramework.ErrorScreen.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum HowToPosition {
  public enum Route : Swift.Equatable {
    case performingPositioning(Swift.String, DeviceConnections.DeviceUniversalID, DeviceConnections.PlaceID)
    public static func == (a: NamiPairingFramework.HowToPosition.Route, b: NamiPairingFramework.HowToPosition.Route) -> Swift.Bool
  }
  public struct State : Swift.Equatable {
    public static func == (a: NamiPairingFramework.HowToPosition.State, b: NamiPairingFramework.HowToPosition.State) -> Swift.Bool
  }
  public enum Event {
    case never
    case wantToDismiss
    case dismissPresented
    case startPositioningTapped
    public static func == (a: NamiPairingFramework.HowToPosition.Event, b: NamiPairingFramework.HowToPosition.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.HowToPosition.State
    public typealias Event = NamiPairingFramework.HowToPosition.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.HowToPosition.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.HowToPosition.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(_ event: NamiPairingFramework.HowToPosition.ViewModel.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum PositioningGuidance {
  public enum PositioningQuality : Swift.Equatable {
    case unknown
    case poor
    case degraded
    case good
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NamiPairingFramework.PositioningGuidance.PositioningQuality, b: NamiPairingFramework.PositioningGuidance.PositioningQuality) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PositioningState : Swift.Equatable {
    case unknown
    case started
    case stopped
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NamiPairingFramework.PositioningGuidance.PositioningState, b: NamiPairingFramework.PositioningGuidance.PositioningState) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct State : Swift.Equatable {
    public var deviceName: Swift.String
    public var deviceUid: DeviceConnections.DeviceUniversalID
    public var placeId: DeviceConnections.PlaceID
    public var positioningQuality: NamiPairingFramework.PositioningGuidance.PositioningQuality
    public var positioningState: NamiPairingFramework.PositioningGuidance.PositioningState
    public var error: NamiPairingFramework.PositioningError?
    public var wantToDismiss: Swift.Bool
    public var wantCancel: Swift.Bool
    public var wantFinish: Swift.Bool
    public var cancelConfirmed: Swift.Bool
    public var canNotFinish: Swift.Bool {
      get
    }
    public var canNotCancel: Swift.Bool {
      get
    }
    public var shouldRetryPositioning: Swift.Bool
    public static func == (a: NamiPairingFramework.PositioningGuidance.State, b: NamiPairingFramework.PositioningGuidance.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case never
    case retryPositioning
    case gotPositioningQuality(NamiPairingFramework.PositioningGuidance.PositioningQuality)
    case gotError(NamiPairingFramework.PositioningError)
    case gotStateError(NamiPairingFramework.PositioningError)
    case wantToDismiss
    case wantFinishTapped
    case wantCancelTapped
    case cancelViewDismissed
    case confirmPositioningCancel
    case positionState(NamiPairingFramework.PositioningGuidance.PositioningState)
    public static func == (a: NamiPairingFramework.PositioningGuidance.Event, b: NamiPairingFramework.PositioningGuidance.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.PositioningGuidance.State
    public typealias Event = NamiPairingFramework.PositioningGuidance.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PositioningGuidance.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PositioningGuidance.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(_ event: NamiPairingFramework.PositioningGuidance.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum InitialScreen {
  public struct State : Swift.Equatable {
    public static func == (a: NamiPairingFramework.InitialScreen.State, b: NamiPairingFramework.InitialScreen.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case never
    case howToPositionTapped
    case dismissPresented
    case dismissSelf
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NamiPairingFramework.InitialScreen.Event, b: NamiPairingFramework.InitialScreen.Event) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.InitialScreen.State
    public typealias Event = NamiPairingFramework.InitialScreen.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.InitialScreen.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.InitialScreen.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(_ event: NamiPairingFramework.InitialScreen.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum PositioningComplete {
  public struct State : Swift.Equatable {
    public var deviceName: Swift.String
    public var wantConfirmPositioningComplete: Swift.Bool
    public static func == (a: NamiPairingFramework.PositioningComplete.State, b: NamiPairingFramework.PositioningComplete.State) -> Swift.Bool
  }
  public enum Event {
    case confirmPositioningComplete
    public static func == (a: NamiPairingFramework.PositioningComplete.Event, b: NamiPairingFramework.PositioningComplete.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.PositioningComplete.State
    public typealias Event = NamiPairingFramework.PositioningComplete.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PositioningComplete.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PositioningComplete.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(_ event: NamiPairingFramework.PositioningComplete.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum PositioningStep {
  case finishPositioningButtonTapped
  case cancelPositioningButtonTapped
  case successIsConfirmed
  case cancelIsConfirmed
  case positioningError(NamiPairingFramework.PositioningError)
}
public enum PositioningResult {
  case finished
  case cancelled
  public static func == (a: NamiPairingFramework.PositioningResult, b: NamiPairingFramework.PositioningResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum PositioningError : Swift.Error, Swift.Equatable {
  case wrapped(any Swift.Error)
  public static func == (lhs: NamiPairingFramework.PositioningError, rhs: NamiPairingFramework.PositioningError) -> Swift.Bool
}
public enum PositioningRoot {
  public enum Route : Swift.Equatable {
    case startScreen(Swift.String, DeviceConnections.DeviceUniversalID, DeviceConnections.PlaceID)
    case howToPosition(Swift.String, DeviceConnections.DeviceUniversalID, DeviceConnections.PlaceID)
    case positionGuidance(Swift.String, DeviceConnections.DeviceUniversalID, DeviceConnections.PlaceID)
    case successScreen(Swift.String)
    case errorScreen(NamiPairingFramework.PositioningError)
    public static func == (a: NamiPairingFramework.PositioningRoot.Route, b: NamiPairingFramework.PositioningRoot.Route) -> Swift.Bool
  }
  public struct State : NamiPairingFramework.StateWithRoute {
    public var route: NamiPairingFramework.PositioningRoot.Route?
    public static func == (a: NamiPairingFramework.PositioningRoot.State, b: NamiPairingFramework.PositioningRoot.State) -> Swift.Bool
    public typealias Route = NamiPairingFramework.PositioningRoot.Route
  }
  public enum Event : Swift.Equatable {
    case empty
    case positioningSucceed
    case positioningEnded
    case positioningCancelled
    case showHowToPosition
    case showPositionGuidance
    case gotError(NamiPairingFramework.PositioningError)
    case restart
    public static func == (a: NamiPairingFramework.PositioningRoot.Event, b: NamiPairingFramework.PositioningRoot.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel<Container> : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol where Container : NamiPairingFramework.PairingStepsContainer {
    public typealias State = NamiPairingFramework.PositioningRoot.State
    public typealias Event = NamiPairingFramework.PositioningRoot.Event
    final public func send(_ event: NamiPairingFramework.PositioningRoot.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public struct PairingDevice : NamiPairingFramework.DeviceProtocol {
  public var id: DeviceConnections.DeviceID
  public var uid: DeviceConnections.DeviceUniversalID
  public var urn: Swift.String
  public var model: NamiPairingFramework.PairingDeviceModel
  public var deviceState: NamiPairingFramework.PairingDeviceCloudState?
  public static func == (a: NamiPairingFramework.PairingDevice, b: NamiPairingFramework.PairingDevice) -> Swift.Bool
  public typealias DeviceCloudState = NamiPairingFramework.PairingDeviceCloudState
  public typealias DeviceModel = NamiPairingFramework.PairingDeviceModel
}
public struct PairingDeviceCloudState : NamiPairingFramework.DeviceCloudStateProtocol {
  public var payload: Foundation.Data
  public static func == (a: NamiPairingFramework.PairingDeviceCloudState, b: NamiPairingFramework.PairingDeviceCloudState) -> Swift.Bool
}
public struct PairingDeviceModel : NamiPairingFramework.DeviceModelProtocol {
  public var codeName: Swift.String
  public var productLabel: Swift.String
  public var productId: DeviceConnections.DeviceProductID
  public static func == (a: NamiPairingFramework.PairingDeviceModel, b: NamiPairingFramework.PairingDeviceModel) -> Swift.Bool
}
public struct PairingPlaceZone : NamiPairingFramework.PlaceZoneProtocol {
  public var id: DeviceConnections.PlaceZoneID
  public var externalId: Swift.String
  public var name: Swift.String
  public static func == (a: NamiPairingFramework.PairingPlaceZone, b: NamiPairingFramework.PairingPlaceZone) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class CodeScannerUIView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct CodeScannerView : SwiftUI.UIViewRepresentable {
  public typealias UIViewType = NamiPairingFramework.CodeScannerUIView
  @objc @_hasMissingDesignatedInitializers final public class Coordinator : ObjectiveC.NSObject {
    @objc final public func metadataOutput(_: AVFoundation.AVCaptureMetadataOutput, didOutput metadataObjects: [AVFoundation.AVMetadataObject], from _: AVFoundation.AVCaptureConnection)
    @objc deinit
  }
  @_Concurrency.MainActor(unsafe) public func makeCoordinator() -> NamiPairingFramework.CodeScannerView.Coordinator
  @_Concurrency.MainActor(unsafe) public func makeUIView(context: NamiPairingFramework.CodeScannerView.Context) -> NamiPairingFramework.CodeScannerUIView
  @_Concurrency.MainActor(unsafe) public func updateUIView(_ uiView: NamiPairingFramework.CodeScannerUIView, context _: NamiPairingFramework.CodeScannerView.Context)
  public typealias Body = Swift.Never
}
public enum QRScanner {
  public enum ScanError : Swift.String, Swift.Identifiable {
    case unknownQR
    public var id: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias ID = Swift.String
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct State : Swift.Equatable {
    public var error: NamiPairingFramework.QRScanner.ScanError?
    public static func == (a: NamiPairingFramework.QRScanner.State, b: NamiPairingFramework.QRScanner.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case reset
    case shouldDismissItself
    case gotData(Swift.String?)
    case dismissScanError
    case pauseScanning
    case scanningUnauthorized
    public static func == (a: NamiPairingFramework.QRScanner.Event, b: NamiPairingFramework.QRScanner.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.QRScannerViewModelProtocol {
    public typealias State = NamiPairingFramework.QRScanner.State
    public typealias Event = NamiPairingFramework.QRScanner.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.QRScanner.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.QRScanner.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public var undecoratedScannerView: NamiPairingFramework.CodeScannerView {
      get
    }
    final public func send(event: NamiPairingFramework.QRScanner.ViewModel.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public struct NamiQRCode : Swift.Equatable {
  public init?(_ string: Swift.String)
  public var discriminator: Swift.Int32
  public static func == (a: NamiPairingFramework.NamiQRCode, b: NamiPairingFramework.NamiQRCode) -> Swift.Bool
}
public struct BluetoothCentralState : Swift.Equatable {
  public static func == (a: NamiPairingFramework.BluetoothCentralState, b: NamiPairingFramework.BluetoothCentralState) -> Swift.Bool
}
extension NamiPairingFramework.BluetoothCentralState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
final public class Tomonari<Container> where Container : NamiPairingFramework.PairingStepsContainer {
  public init(api: any NamiPairingFramework.PairingWebAPIProtocol, wifiStorage: any NamiPairingFramework.PairingWiFiStorageProtocol, threadDatasetProvider: any NamiPairingFramework.PairingThreadOperationalDatasetProviderProtocol, deviceConnectionManager: any DeviceConnections.DeviceConnectionsManagerProtocol)
  public typealias DevicePairingStatePublisher = Combine.PassthroughSubject<NamiPairingFramework.Tomonari<Container>.DevicePairingState, any Swift.Error>
  public typealias DevicePositioningStatePublisher = Combine.PassthroughSubject<NamiPairingFramework.PositioningStep, any Swift.Error>
  public struct PairingParameters : Swift.Equatable {
    public init(qrCode: NamiPairingFramework.NamiQRCode? = nil, updateWiFiCredentialsSessionId: DeviceConnections.WiFiCredentialsUpdateSessionID? = nil, bssid: Foundation.Data? = nil)
    public init(qrCode: NamiPairingFramework.NamiQRCode? = nil, updateWiFiCredentialsSessionId: DeviceConnections.WiFiCredentialsUpdateSessionID? = nil, bssid: [Swift.UInt8])
    public init(qrCode: NamiPairingFramework.NamiQRCode? = nil, updateWiFiCredentialsSessionId: DeviceConnections.WiFiCredentialsUpdateSessionID? = nil, bssid: Swift.String)
    public static var none: NamiPairingFramework.Tomonari<Container>.PairingParameters {
      get
    }
    public let qrCode: NamiPairingFramework.NamiQRCode?
    public let updateWiFiCredentialsSessionId: DeviceConnections.WiFiCredentialsUpdateSessionID?
    public let bssid: Foundation.Data?
    public static func == (a: NamiPairingFramework.Tomonari<Container>.PairingParameters, b: NamiPairingFramework.Tomonari<Container>.PairingParameters) -> Swift.Bool
  }
  public enum DevicePairingState {
    case deviceCommisionedAtCloud(any NamiPairingFramework.DeviceProtocol, in: DeviceConnections.PlaceID)
    case deviceOperable(DeviceConnections.DeviceID, ssid: Swift.String?, bssid: [Swift.UInt8]?, positionAdjustmentNeeded: Swift.Bool?)
    case deviceDecommissioned(DeviceConnections.DeviceID)
    case pairingCancelled
  }
  final public let devicePairingState: NamiPairingFramework.Tomonari<Container>.DevicePairingStatePublisher
  final public let devicePositioningState: NamiPairingFramework.Tomonari<Container>.DevicePositioningStatePublisher
  final public func startPairing(placeId: DeviceConnections.PlaceID, zoneId: DeviceConnections.PlaceZoneID, roomId: DeviceConnections.RoomID, pairingParameters: NamiPairingFramework.Tomonari<Container>.PairingParameters = .none, pairingSteps: Container) -> some SwiftUI.View
  
  final public func startPositioning(deviceName: Swift.String, deviceUid: DeviceConnections.DeviceUniversalID, placeId: DeviceConnections.PlaceID, pairingSteps: Container, onPositioningEnded: @escaping (NamiPairingFramework.PositioningResult) -> Swift.Void) -> some SwiftUI.View
  
  @objc deinit
}
extension Combine.Publisher {
  public func first<T>(_ keyPath: Swift.KeyPath<Self.Output, T>, toEqual value: T) -> Combine.Publishers.FirstWhere<Combine.Publishers.MapKeyPath<Self, T>> where T : Swift.Equatable
}
public enum PairingMachineState : Swift.Equatable, Swift.CustomDebugStringConvertible, Swift.Identifiable {
  case initial
  case gotAdvertisement(NamiPairingFramework.PublicPairingAdvertisement)
  case sentProverPublicKey
  case sentProverSharedKey
  case establishedSession
  case sentDeviceCertificateRequest
  case gotDeviceCertificateResponse(Swift.String)
  case sentCloudChallenge
  case gotCloudChallengeResponse(Foundation.Data)
  case sentCloudPayload
  case gotCloudChallengeOK
  case sentScanWiFiNetworks
  case gotWiFiNetworks([NamiPairingFramework.PublicWiFiNetwork])
  case sentWiFiCredentials
  case gotWiFiIPAddress(Swift.String)
  case sentScanThreadNetworks
  case gotThreadNetworks([NamiPairingFramework.ThreadScanResult])
  case sentJoinThreadNetwork
  case threadJoinFinished(Foundation.Data)
  case sentHandshakeAck
  public var id: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: NamiPairingFramework.PairingMachineState, b: NamiPairingFramework.PairingMachineState) -> Swift.Bool
  public typealias ID = Swift.String
}
public enum PairingMachineError : Swift.Error, Swift.Equatable {
  case unexpectedState
  case unexpectedMessage
  case seanceError(any Swift.Error)
  case pairingError(NamiPairingFramework.PublicPairingError)
  case serializationError(any Swift.Error)
  case deserializationError(any Swift.Error)
  case encryptionError
  public static func == (lhs: NamiPairingFramework.PairingMachineError, rhs: NamiPairingFramework.PairingMachineError) -> Swift.Bool
}
public enum PairingErrorScreen {
  public struct State : Swift.Equatable {
    public var error: NamiPairingFramework.Pairing.Error
    public var actions: [NamiPairingFramework.Pairing.ActionOnError]
    public var chosenAction: NamiPairingFramework.Pairing.ActionOnError?
    public static func == (a: NamiPairingFramework.PairingErrorScreen.State, b: NamiPairingFramework.PairingErrorScreen.State) -> Swift.Bool
  }
  public enum Event {
    case didChooseAction(NamiPairingFramework.Pairing.ActionOnError)
    case reconfigure(NamiPairingFramework.Pairing.Error, [NamiPairingFramework.Pairing.ActionOnError])
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.PairingErrorScreen.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PairingErrorScreen.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PairingErrorScreen.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.PairingErrorScreen.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum BluetoothDeviceFound {
  public struct State : Swift.Equatable {
    public var deviceModel: DeviceConnections.NamiDeviceModel?
    public var deviceName: Swift.String
    public var deviceNameConfirmed: Swift.Bool
    public static func == (a: NamiPairingFramework.BluetoothDeviceFound.State, b: NamiPairingFramework.BluetoothDeviceFound.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case deviceNameConfirmed(Swift.String)
    public static func == (a: NamiPairingFramework.BluetoothDeviceFound.Event, b: NamiPairingFramework.BluetoothDeviceFound.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {
    public typealias State = NamiPairingFramework.BluetoothDeviceFound.State
    public typealias Event = NamiPairingFramework.BluetoothDeviceFound.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.BluetoothDeviceFound.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.BluetoothDeviceFound.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.BluetoothDeviceFound.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum ListWiFiNetworks {
  public struct State {
    public var networks: [NamiPairingFramework.NamiWiFiNetwork]?
    public var selectedNetwork: NamiPairingFramework.NamiWiFiNetwork?
    public var shouldShowBSSIDWarning: Swift.Bool
    public var shouldAskAboutSavedPassword: Swift.Bool
    public var deviceSupportsBSSID: Swift.Bool {
      get
    }
    public var shouldShowProgressView: Swift.Bool {
      get
    }
    public var shouldShowNoNetworksHint: Swift.Bool {
      get
    }
    public var couldShowAddOtherNetwork: Swift.Bool {
      get
    }
    public static func == (a: NamiPairingFramework.ListWiFiNetworks.State, b: NamiPairingFramework.ListWiFiNetworks.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case empty
    case dismissItself
    case tappedConfirmSelection
    case tappedRefreshNetwork
    case tappedOtherNetwork
    case selectNetwork(NamiPairingFramework.NamiWiFiNetwork)
    case selectNetwofkAndConfirm(NamiPairingFramework.NamiWiFiNetwork)
    case didTapUsePassword
    case didTapForgetPassword
    case didSearchForSavedPassword(Swift.String?)
    case confirmingSelection
    case shouldAskAboutSavedPassword(Swift.Bool)
    case gotError(NamiPairingFramework.Pairing.Error)
    public static func == (a: NamiPairingFramework.ListWiFiNetworks.Event, b: NamiPairingFramework.ListWiFiNetworks.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.StoredPasswordRetrievingViewModel {
    public typealias State = NamiPairingFramework.ListWiFiNetworks.State
    public typealias Event = NamiPairingFramework.ListWiFiNetworks.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.ListWiFiNetworks.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.ListWiFiNetworks.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.ListWiFiNetworks.ViewModel.Event)
    final public func usePassword()
    final public func forgetPassword()
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum PowerOnAndScanning {
  public struct State : Swift.Equatable {
    public var showsProgressIndicator: Swift.Bool
    public static func == (a: NamiPairingFramework.PowerOnAndScanning.State, b: NamiPairingFramework.PowerOnAndScanning.State) -> Swift.Bool
  }
  public enum Event {
    case stopShowingProgress
    public static func == (a: NamiPairingFramework.PowerOnAndScanning.Event, b: NamiPairingFramework.PowerOnAndScanning.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.PowerOnAndScanning.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.PowerOnAndScanning.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.PowerOnAndScanning.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.PowerOnAndScanning.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum AskToConnect {
  public struct State : Swift.Equatable {
    public var deviceName: Swift.String
    public var deviceModel: DeviceConnections.NamiDeviceModel
    public var isConnectingToThread: Swift.Bool
    public var updatingWifi: Swift.Bool
    public var devicesCount: Swift.Int
    public var nextTapped: Swift.Bool
    public var doneLoading: Swift.Bool {
      get
    }
    public var zoneName: Swift.String? {
      get
    }
    public var zonesCount: Swift.Int {
      get
    }
    public var isThreadDevice: Swift.Bool {
      get
    }
    public static func == (a: NamiPairingFramework.AskToConnect.State, b: NamiPairingFramework.AskToConnect.State) -> Swift.Bool
  }
  public enum Event {
    case empty
    case tapNext
    case gotZones([NamiPairingFramework.PairingPlaceZone])
    case gotDevicesCount(Swift.Int)
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.AskToConnect.State
    public typealias Event = NamiPairingFramework.AskToConnect.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.AskToConnect.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.AskToConnect.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.AskToConnect.ViewModel.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum OtherWiFiNetwork {
  public struct State {
    public var networkName: Swift.String
    public var password: Swift.String
    public var shouldAskAboutSavedPassword: Swift.Bool
    public static func == (a: NamiPairingFramework.OtherWiFiNetwork.State, b: NamiPairingFramework.OtherWiFiNetwork.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case empty
    case didConfirmName
    case lookForSavedPassword
    case shouldAskAboutSavedPassword(Swift.Bool)
    case didTapUsePassword
    case didTapForgetPassword
    case didSearchForSavedPassword(Swift.String?)
    public static func == (a: NamiPairingFramework.OtherWiFiNetwork.Event, b: NamiPairingFramework.OtherWiFiNetwork.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.StoredPasswordRetrievingViewModel {
    public typealias State = NamiPairingFramework.OtherWiFiNetwork.State
    public typealias Event = NamiPairingFramework.OtherWiFiNetwork.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.OtherWiFiNetwork.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.OtherWiFiNetwork.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.OtherWiFiNetwork.ViewModel.Event)
    final public func usePassword()
    final public func forgetPassword()
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum BluetoothUsageHint {
  public struct State : Swift.Equatable {
    public var nextTapped: Swift.Bool
    public static func == (a: NamiPairingFramework.BluetoothUsageHint.State, b: NamiPairingFramework.BluetoothUsageHint.State) -> Swift.Bool
  }
  public enum Event {
    case tapNext
    public static func == (a: NamiPairingFramework.BluetoothUsageHint.Event, b: NamiPairingFramework.BluetoothUsageHint.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.BluetoothUsageHint.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.BluetoothUsageHint.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.BluetoothUsageHint.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.BluetoothUsageHint.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum EnterWiFiPassword {
  public struct State : Swift.Equatable {
    public var password: Swift.String
    public var networkName: Swift.String {
      get
    }
    public static func == (a: NamiPairingFramework.EnterWiFiPassword.State, b: NamiPairingFramework.EnterWiFiPassword.State) -> Swift.Bool
  }
  public enum Event {
    case confirmPassword
    case goBack
    public static func == (a: NamiPairingFramework.EnterWiFiPassword.Event, b: NamiPairingFramework.EnterWiFiPassword.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class ViewModel : NamiPairingFramework.PairingStepViewModelProtocol {
    public typealias State = NamiPairingFramework.EnterWiFiPassword.State
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.EnterWiFiPassword.ViewModel.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.EnterWiFiPassword.ViewModel.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.EnterWiFiPassword.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public enum Pairing {
  public struct CloudPayload : NamiPairingFramework.WiredPlaceKeysProtocol {
    public var ciphertext: Swift.String
    public var iv: Swift.String
    public var authTag: Swift.String
    public var serverKey: Swift.String
    public static func == (a: NamiPairingFramework.Pairing.CloudPayload, b: NamiPairingFramework.Pairing.CloudPayload) -> Swift.Bool
  }
  public struct DeviceSetupParameters : Swift.Equatable {
    public static func == (a: NamiPairingFramework.Pairing.DeviceSetupParameters, b: NamiPairingFramework.Pairing.DeviceSetupParameters) -> Swift.Bool
  }
  public enum ConnectTo : Swift.Equatable {
    case thread
    case wifi
    public static func == (a: NamiPairingFramework.Pairing.ConnectTo, b: NamiPairingFramework.Pairing.ConnectTo) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error, Swift.Identifiable, Swift.Equatable {
    case underlying(any Swift.Error)
    public var id: Swift.String {
      get
    }
    public static func == (lhs: NamiPairingFramework.Pairing.Error, rhs: NamiPairingFramework.Pairing.Error) -> Swift.Bool
    public typealias ID = Swift.String
  }
  public enum ThreadError : Swift.Error, Swift.Equatable {
    case threadOperationalDatasetMissing
    case threadNetworkNotFound
    case mixedEnvironment
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NamiPairingFramework.Pairing.ThreadError, b: NamiPairingFramework.Pairing.ThreadError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ActionOnError : Swift.Equatable {
    case restart
    case tryAgain
    case ignore
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NamiPairingFramework.Pairing.ActionOnError, b: NamiPairingFramework.Pairing.ActionOnError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Routes : Swift.Equatable {
    case qrCodeScanner
    case bluetoothUsageHint
    case bluetoothEnableInSettings
    case cameraEnableInSettings
    case powerOnAndScanning
    case deviceFound(DeviceConnections.NamiDeviceModel)
    case askToConnect(NamiPairingFramework.Pairing.DeviceSetupParameters)
    case listWiFiNetworks(zoneId: DeviceConnections.PlaceZoneID, wifiNetworks: [NamiPairingFramework.NamiWiFiNetwork]?, bssidLookupComplete: Swift.Bool)
    case finishingSetup
    public static func == (a: NamiPairingFramework.Pairing.Routes, b: NamiPairingFramework.Pairing.Routes) -> Swift.Bool
  }
  public struct State : Swift.Equatable {
    public var placeId: DeviceConnections.PlaceID
    public var zoneId: DeviceConnections.PlaceZoneID
    public var roomId: DeviceConnections.RoomID
    public var updateWiFiCredentialsSessionId: DeviceConnections.WiFiCredentialsUpdateSessionID?
    public var deviceName: Swift.String
    public static func == (a: NamiPairingFramework.Pairing.State, b: NamiPairingFramework.Pairing.State) -> Swift.Bool
  }
  public enum Event : Swift.Equatable {
    case empty
    case centralDidUpdate(NamiPairingFramework.BluetoothCentralState)
    case pairingMachineDidUpdate(NamiPairingFramework.PairingMachineState)
    case startScanning
    case didStartScanning
    case didResetPairingState
    case stopPresenting
    case gotQRCode(NamiPairingFramework.NamiQRCode)
    case bluetoothHintAcknowledged
    case didInitBluetooth
    case gotDeviceProductId(DeviceConnections.DeviceProductID)
    case identifiedModelByProductId(DeviceConnections.NamiDeviceModel)
    case setRoute(NamiPairingFramework.Pairing.Routes)
    case shouldContinuePairing
    case didContinuePairing
    case setDeviceName(Swift.String)
    case gotDeviceCertificate(Swift.String)
    case gotPairingChallenge(challenge: Swift.String, model: DeviceConnections.NamiDeviceModel)
    case gotDeviceChallengeResponse(Foundation.Data)
    case gotPairDeviceResponseFromCloud(NamiPairingFramework.Pairing.CloudPayload, NamiPairingFramework.PairingDevice)
    case shouldStartScanningWiFi
    case doneSearchingForWiFiUpdateSessionDevices([DeviceConnections.DeviceUniversalID])
    case retryScanningWiFi
    case didStartScanningWiFi
    case gotWiFiCredentials(NamiPairingFramework.NamiWiFiNetwork, Swift.String?)
    case didFoundSavedBSSID(Foundation.Data?)
    case bssidNotFound
    case otherNetwork
    case enterPassword(NamiPairingFramework.NamiWiFiNetwork)
    case didSendWiFiCredentials
    case shouldScanForThreadNetwork
    case didStartScanForThreadNetwork
    case shouldSendThreadOperationalDataset(Foundation.Data)
    case didSentThreadOperationalDataset
    case shouldDismissItself
    case dismissalApproved(DeviceConnections.DeviceID?)
    case dismissalWithDeleteApproved(DeviceConnections.DeviceID)
    case dismissStackablePresented
    case dismissFullscreenPresented
    case shouldPairAnother
    case gotAPIError(NamiPairingFramework.Pairing.Error)
    case gotPairingMachineError(NamiPairingFramework.PairingMachineError)
    case gotErrorAction(NamiPairingFramework.Pairing.ActionOnError)
    case threadOperationalDatsetMissing
    case askTryRescanThreadNetworks
    case mixedEnvironment
    public static func == (a: NamiPairingFramework.Pairing.Event, b: NamiPairingFramework.Pairing.Event) -> Swift.Bool
  }
  @_hasMissingDesignatedInitializers final public class ViewModel<Container> where Container : NamiPairingFramework.PairingStepsContainer {
    public typealias State = NamiPairingFramework.Pairing.State
    public typealias Event = NamiPairingFramework.Pairing.Event
    @Combine.Published @_projectedValueProperty($state) final public var state: NamiPairingFramework.Pairing.ViewModel<Container>.State {
      get
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      set
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      _modify
    }
    final public var $state: Combine.Published<NamiPairingFramework.Pairing.ViewModel<Container>.State>.Publisher {
      get
      @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
      set
    }
    final public func send(event: NamiPairingFramework.Pairing.ViewModel<Container>.Event)
    public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
    @objc deinit
  }
}
public protocol PairingStepViewModelProtocol : Combine.ObservableObject {
  associatedtype State : Swift.Equatable
}
public protocol PairingStepEventSendableViewModelProtocol : NamiPairingFramework.PairingStepViewModelProtocol {
  associatedtype Event : Swift.Equatable
  func send(event: Self.Event)
}
public protocol StoredPasswordRetrievingViewModel {
  func usePassword()
  func forgetPassword()
}
public protocol QRScannerViewModelProtocol : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {
  var undecoratedScannerView: NamiPairingFramework.CodeScannerView { get }
}
public protocol PairingStepsContainer {
  associatedtype ViewForBluetoothUsageHint : SwiftUI.View
  associatedtype ViewForPowerOnAndScanning : SwiftUI.View
  associatedtype ViewForEnableBluetoothInSettings : SwiftUI.View
  associatedtype ViewForEnableCameraInSettings : SwiftUI.View
  associatedtype ViewForBluetoothDeviceFound : SwiftUI.View
  associatedtype ViewForAskToConnect : SwiftUI.View
  associatedtype ViewForQRCodeScanner : SwiftUI.View
  associatedtype ViewForListWiFiNetworks : SwiftUI.View
  associatedtype ViewForOtherWiFiNetwork : SwiftUI.View
  associatedtype ViewForEnterWiFiPassword : SwiftUI.View
  associatedtype ViewForFinishingSetup : SwiftUI.View
  associatedtype ViewForPairingError : SwiftUI.View
  associatedtype BackButtonView : SwiftUI.View
  associatedtype ViewForPositioningErrorScreen : SwiftUI.View
  associatedtype ViewForHowToPosition : SwiftUI.View
  associatedtype ViewForInitialPositioningScreen : SwiftUI.View
  associatedtype ViewForPositioningGuidance : SwiftUI.View
  associatedtype ViewForPositioningComplete : SwiftUI.View
  var bluetoothUsageHint: (NamiPairingFramework.BluetoothUsageHint.ViewModel) -> Self.ViewForBluetoothUsageHint { get }
  var powerOnAndScanning: (NamiPairingFramework.PowerOnAndScanning.ViewModel) -> Self.ViewForPowerOnAndScanning { get }
  var enableBluetoothInSettings: () -> Self.ViewForEnableBluetoothInSettings { get }
  var enableCameraInSettings: () -> Self.ViewForEnableCameraInSettings { get }
  var bluetoothDeviceFound: (NamiPairingFramework.BluetoothDeviceFound.ViewModel) -> Self.ViewForBluetoothDeviceFound { get }
  var askToConnect: (NamiPairingFramework.AskToConnect.ViewModel) -> Self.ViewForAskToConnect { get }
  var qrCodeScanner: (NamiPairingFramework.QRScanner.ViewModel) -> Self.ViewForQRCodeScanner { get }
  var listWiFiNetworks: (NamiPairingFramework.ListWiFiNetworks.ViewModel) -> Self.ViewForListWiFiNetworks { get }
  var otherWiFiNetwork: (NamiPairingFramework.OtherWiFiNetwork.ViewModel) -> Self.ViewForOtherWiFiNetwork { get }
  var enterWiFiPassword: (NamiPairingFramework.EnterWiFiPassword.ViewModel) -> Self.ViewForEnterWiFiPassword { get }
  var finishingSetup: () -> Self.ViewForFinishingSetup { get }
  var howToPosition: (NamiPairingFramework.HowToPosition.ViewModel) -> Self.ViewForHowToPosition { get }
  var initialPositioningScreen: (NamiPairingFramework.InitialScreen.ViewModel) -> Self.ViewForInitialPositioningScreen { get }
  var positioningGuidance: (NamiPairingFramework.PositioningGuidance.ViewModel) -> Self.ViewForPositioningGuidance { get }
  var positioningComplete: (NamiPairingFramework.PositioningComplete.ViewModel) -> Self.ViewForPositioningComplete { get }
  var pairingError: (NamiPairingFramework.PairingErrorScreen.ViewModel) -> Self.ViewForPairingError { get }
  var positionError: (NamiPairingFramework.ErrorScreen.ViewModel) -> Self.ViewForPositioningErrorScreen { get }
  var backButton: () -> Self.BackButtonView? { get }
}
extension NamiPairingFramework.PairingStepsContainer {
  public var backButton: () -> NamiPairingFramework.NoView? {
    get
  }
}
public struct NoView : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s20NamiPairingFramework6NoViewV4bodyQrvp", 0) __
}
public protocol PairingThreadOperationalDatasetProviderProtocol {
  associatedtype Pairing_NamiThreadOperationalDataset : NamiPairingFramework.PairingNamiThreadOperationalDatasetProtocol
  func newRandomDataset(networkName: Swift.String?) -> Self.Pairing_NamiThreadOperationalDataset
  func retrieve(placeId: DeviceConnections.PlaceID) -> Self.Pairing_NamiThreadOperationalDataset?
  func removeDataset(for placeId: DeviceConnections.PlaceID)
  func storeDataset(_ dataset: Self.Pairing_NamiThreadOperationalDataset, for placeId: DeviceConnections.PlaceID)
}
public protocol PairingNamiThreadOperationalDatasetProtocol : Swift.Decodable, Swift.Encodable {
  var data: Foundation.Data { get }
  func equalsNumericalPanID<ID>(_ panId: ID) -> Swift.Bool where ID : Swift.FixedWidthInteger
}
public protocol StateWithRoute : Swift.Equatable {
  associatedtype Route : Swift.Equatable
  var route: Self.Route? { get set }
}
public protocol WiDarPositioningViewModelProtocol : Combine.ObservableObject {
  associatedtype State : Swift.Equatable
}
public protocol WiDarPositioningEventSendableViewModelProtocol : NamiPairingFramework.WiDarPositioningViewModelProtocol {
  associatedtype Event : Swift.Equatable
  func send(_ event: Self.Event)
}
public protocol WiDarPositioningRoutBindableViewModelProtocol : NamiPairingFramework.WiDarPositioningEventSendableViewModelProtocol where Self.State : NamiPairingFramework.StateWithRoute {
  func onRouteChange(_ event: Self.Event) -> SwiftUI.Binding<Self.State.Route?>
}
extension NamiPairingFramework.WiDarPositioningRoutBindableViewModelProtocol {
  public func binding(route: Self.State.Route?, event: Self.Event) -> SwiftUI.Binding<Self.State.Route?>
}
public protocol PairingWiFiStorageProtocol {
  func save(password: Swift.String?, for networkSSID: Swift.String)
  func password(for networkSSID: Swift.String) -> Swift.String?
  func removeAll()
}
public protocol PairingWebAPIProtocol {
  associatedtype Pairing_DevicesResponse : NamiPairingFramework.DevicesResponseProtocol
  associatedtype Pairing_PairDeviceResponse : NamiPairingFramework.PairDeviceResponseProtocol
  associatedtype Pairing_PlaceZone : NamiPairingFramework.PlaceZoneProtocol
  associatedtype Pairing_PairingChallengeResponse : NamiPairingFramework.PairingChallengeResponseProtocol
  associatedtype Pairing_WiFiCredentialsUpdateSession : NamiPairingFramework.WiFiCredentialsUpdateSessionProtocol
  func listDevices(query: any NamiPairingFramework.DevicesQueryProtocol) -> Combine.AnyPublisher<Self.Pairing_DevicesResponse, any Swift.Error>
  func listPlaceZones(for placeId: DeviceConnections.PlaceID) -> Combine.AnyPublisher<[Self.Pairing_PlaceZone], any Swift.Error>
  func requestPairingChallenge(roomId: DeviceConnections.RoomID, deviceCertificate: Swift.String) -> Combine.AnyPublisher<Self.Pairing_PairingChallengeResponse, any Swift.Error>
  func pairDevice(roomId: DeviceConnections.RoomID, deviceName: Swift.String, cloudChallenge: Swift.String, deviceResponse: Swift.String, deviceCertificate: Swift.String, intent: Swift.String?) -> Combine.AnyPublisher<Self.Pairing_PairDeviceResponse, any Swift.Error>
  func deleteDevice(id: DeviceConnections.DeviceID) -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  func getWiFiCredentialsUpdateSession(id: DeviceConnections.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<Self.Pairing_WiFiCredentialsUpdateSession, any Swift.Error>
  func deleteDeviceFromSession(uid: DeviceConnections.DeviceUniversalID, sessionId: DeviceConnections.WiFiCredentialsUpdateSessionID) -> Combine.AnyPublisher<Self.Pairing_WiFiCredentialsUpdateSession, any Swift.Error>
}
public protocol DevicesQueryProtocol {
  var placeIds: [DeviceConnections.PlaceID] { get set }
  var zoneIds: [DeviceConnections.PlaceZoneID] { get set }
  var roomIds: [DeviceConnections.RoomID] { get set }
  var uids: [DeviceConnections.DeviceUniversalID] { get set }
  var cursor: Swift.String? { get set }
}
public protocol DevicesResponseProtocol {
  associatedtype Device : NamiPairingFramework.DeviceProtocol
  var devices: [Self.Device] { get }
  var total: Swift.Int { get }
}
public protocol DeviceProtocol : Swift.Equatable {
  associatedtype DeviceCloudState : NamiPairingFramework.DeviceCloudStateProtocol
  associatedtype DeviceModel : NamiPairingFramework.DeviceModelProtocol
  var id: DeviceConnections.DeviceID { get }
  var uid: DeviceConnections.DeviceUniversalID { get }
  var urn: Swift.String { get }
  var model: Self.DeviceModel { get }
  var deviceState: Self.DeviceCloudState? { get }
}
public protocol DeviceCloudStateProtocol : Swift.Equatable {
  var payload: Foundation.Data { get }
}
public protocol PlaceZoneProtocol : Swift.Equatable {
  var id: DeviceConnections.PlaceZoneID { get }
  var externalId: Swift.String { get }
  var name: Swift.String { get }
}
public protocol PairingChallengeResponseProtocol {
  associatedtype DeviceModel : NamiPairingFramework.DeviceModelProtocol
  var challenge: Swift.String { get }
  var model: Self.DeviceModel { get }
}
public protocol DeviceModelProtocol : Swift.Equatable {
  var codeName: Swift.String { get }
  var productLabel: Swift.String { get }
  var productId: DeviceConnections.DeviceProductID { get }
}
public protocol PairDeviceResponseProtocol {
  associatedtype WiredPlaceKeys : NamiPairingFramework.WiredPlaceKeysProtocol
  associatedtype Device : NamiPairingFramework.DeviceProtocol
  var payload: Self.WiredPlaceKeys { get }
  var device: Self.Device { get }
}
public protocol WiredPlaceKeysProtocol : Swift.Equatable {
  var ciphertext: Swift.String { get }
  var iv: Swift.String { get }
  var authTag: Swift.String { get }
  var serverKey: Swift.String { get }
}
public protocol UpdatedDeviceProtocol : Swift.Equatable {
  var uid: DeviceConnections.DeviceUniversalID { get }
}
public protocol WiFiCredentialsUpdateSessionProtocol : Swift.Equatable {
  associatedtype UpdatedDevice : NamiPairingFramework.UpdatedDeviceProtocol
  var id: DeviceConnections.WiFiCredentialsUpdateSessionID { get }
  var zoneId: DeviceConnections.PlaceZoneID { get }
  var updatedDevices: [Self.UpdatedDevice]? { get }
}
public protocol PairingNetworkError : Swift.Error {
  var localizedDescription: Swift.String { get }
}
public typealias PortableTypedCache = NamiPairingFramework.TypedCache
final public class TypedCache {
  public init()
  final public func retrieve<Element>(_ type: Element.Type, toInit: (inout Swift.Set<Combine.AnyCancellable>) -> Element) -> Element where Element : AnyObject
  final public func replace<Element>(_ type: Element.Type, toInit: (inout Swift.Set<Combine.AnyCancellable>) -> Element) -> Element where Element : AnyObject
  final public func delete<Element>(_ type: Element.Type) where Element : AnyObject
  @objc deinit
}
public protocol ThreadSecureStorageProtocol {
  associatedtype Thread_SecureStorageError : Swift.Error
  static func storeOrUpdate(with data: Foundation.Data, at key: Swift.String, server: Swift.String)
  static func retrieve(at key: Swift.String, server: Swift.String) -> Swift.Result<Foundation.Data, Self.Thread_SecureStorageError>
  static func delete(at key: Swift.String, server: Swift.String)
}
public enum MeshCoPType : Swift.Equatable, Swift.Codable {
  case channel(Swift.UInt16)
  case panID(Swift.UInt16)
  case extendedPanID(Swift.UInt64)
  case networkName(Swift.String)
  case pskc([Swift.UInt8])
  case networkKey(Foundation.Data)
  case sequenceCounter(Swift.UInt64)
  case meshLocalPrefix(Swift.UInt64)
  case securityPolicy(Swift.UInt32)
  case activeTimestamp(Swift.UInt64)
  case pendingTimestamp(Swift.UInt64)
  case delayTimer(Swift.UInt32)
  case channelMask([[Swift.UInt8]])
  public static func == (a: NamiPairingFramework.MeshCoPType, b: NamiPairingFramework.MeshCoPType) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
final public class ThreadOperationalDatasetProvider<SecureStorage> where SecureStorage : NamiPairingFramework.ThreadSecureStorageProtocol {
  public init(secureStoreServer: Swift.String, storage: SecureStorage.Type)
  final public func newRandomDataset(networkName: Swift.String?) -> NamiPairingFramework.NamiThreadOperationalDataset
  final public func retrieve(placeId: DeviceConnections.PlaceID) -> NamiPairingFramework.NamiThreadOperationalDataset?
  final public func removeDataset(for placeId: DeviceConnections.PlaceID)
  final public func storeDataset(_ dataset: NamiPairingFramework.NamiThreadOperationalDataset, for placeId: DeviceConnections.PlaceID)
  @objc deinit
}
public typealias PanID = Foundation.Data
public struct NamiThreadOperationalDataset : Swift.Equatable, Swift.Codable {
  public init()
  public init(placeName: Swift.String)
  public init(networkName: Swift.String)
  public init(data: Foundation.Data)
  public let tlvs: [NamiPairingFramework.MeshCoPType]
  public var data: Foundation.Data {
    get
  }
  public func equalsNumericalPanID<ID>(_ panId: ID) -> Swift.Bool where ID : Swift.FixedWidthInteger
  public static func == (a: NamiPairingFramework.NamiThreadOperationalDataset, b: NamiPairingFramework.NamiThreadOperationalDataset) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError : Swift.Equatable {}
extension NamiPairingFramework.InMemoryThreadDatasetStorage.StorageError : Swift.Hashable {}
extension NamiPairingFramework.AuthenticationError : Swift.Equatable {}
extension NamiPairingFramework.AuthenticationError : Swift.Hashable {}
extension NamiPairingFramework.PacketBoatError : Swift.Equatable {}
extension NamiPairingFramework.PacketBoatError : Swift.Hashable {}
extension NamiPairingFramework.PacketBoatError : Swift.RawRepresentable {}
extension NamiPairingFramework.Seance.Role : Swift.Equatable {}
extension NamiPairingFramework.Seance.Role : Swift.Hashable {}
extension NamiPairingFramework.Seance.State : Swift.Equatable {}
extension NamiPairingFramework.Seance.State : Swift.Hashable {}
extension NamiPairingFramework.ErrorScreen.Event : Swift.Hashable {}
extension NamiPairingFramework.HowToPosition.Event : Swift.Equatable {}
extension NamiPairingFramework.HowToPosition.Event : Swift.Hashable {}
extension NamiPairingFramework.PositioningGuidance.PositioningQuality : Swift.Hashable {}
extension NamiPairingFramework.PositioningGuidance.PositioningState : Swift.Hashable {}
extension NamiPairingFramework.InitialScreen.Event : Swift.Hashable {}
extension NamiPairingFramework.PositioningComplete.Event : Swift.Equatable {}
extension NamiPairingFramework.PositioningComplete.Event : Swift.Hashable {}
extension NamiPairingFramework.PositioningResult : Swift.Equatable {}
extension NamiPairingFramework.PositioningResult : Swift.Hashable {}
extension NamiPairingFramework.CodeScannerView.Coordinator : AVFoundation.AVCaptureMetadataOutputObjectsDelegate {}
extension NamiPairingFramework.QRScanner.ScanError : Swift.Equatable {}
extension NamiPairingFramework.QRScanner.ScanError : Swift.Hashable {}
extension NamiPairingFramework.QRScanner.ScanError : Swift.RawRepresentable {}
extension NamiPairingFramework.ListWiFiNetworks.State : Swift.Equatable {}
extension NamiPairingFramework.ListWiFiNetworks.ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {}
extension NamiPairingFramework.PowerOnAndScanning.Event : Swift.Equatable {}
extension NamiPairingFramework.PowerOnAndScanning.Event : Swift.Hashable {}
extension NamiPairingFramework.OtherWiFiNetwork.State : Swift.Equatable {}
extension NamiPairingFramework.OtherWiFiNetwork.ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {}
extension NamiPairingFramework.BluetoothUsageHint.Event : Swift.Equatable {}
extension NamiPairingFramework.BluetoothUsageHint.Event : Swift.Hashable {}
extension NamiPairingFramework.EnterWiFiPassword.Event : Swift.Equatable {}
extension NamiPairingFramework.EnterWiFiPassword.Event : Swift.Hashable {}
extension NamiPairingFramework.Pairing.ConnectTo : Swift.Hashable {}
extension NamiPairingFramework.Pairing.ThreadError : Swift.Hashable {}
extension NamiPairingFramework.Pairing.ActionOnError : Swift.Hashable {}
extension NamiPairingFramework.Pairing.ViewModel : NamiPairingFramework.PairingStepEventSendableViewModelProtocol {}
